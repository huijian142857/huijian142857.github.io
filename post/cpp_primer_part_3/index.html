<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Primer 第五版 学习笔记 Part III - 挥剑对风尘</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="huijian142857" /><meta name="description" content="Copy Control A class controls what happens when objects of class type are copied, moved, assigned, and destroyed by defining five special member functions: copy constructor, move constructor, copy-assignment operator, move-assignment operator, destructor. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy and move assignment operators define what happens when we assign an object of a class" /><meta name="keywords" content="Hugo, even" />






<meta name="generator" content="Hugo 0.128.2 with theme even" />


<link rel="canonical" href="https://huijian142857.gitee.io/post/cpp_primer_part_3/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://huijian142857.gitee.io/post/cpp_primer_part_3/">
  <meta property="og:site_name" content="挥剑对风尘">
  <meta property="og:title" content="C&#43;&#43; Primer 第五版 学习笔记 Part III">
  <meta property="og:description" content="Copy Control A class controls what happens when objects of class type are copied, moved, assigned, and destroyed by defining five special member functions: copy constructor, move constructor, copy-assignment operator, move-assignment operator, destructor. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy and move assignment operators define what happens when we assign an object of a class">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2015-10-08T09:09:00+00:00">
    <meta property="article:modified_time" content="2015-10-08T09:09:00+00:00">
    <meta property="article:tag" content="Cpp">

  <meta itemprop="name" content="C&#43;&#43; Primer 第五版 学习笔记 Part III">
  <meta itemprop="description" content="Copy Control A class controls what happens when objects of class type are copied, moved, assigned, and destroyed by defining five special member functions: copy constructor, move constructor, copy-assignment operator, move-assignment operator, destructor. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy and move assignment operators define what happens when we assign an object of a class">
  <meta itemprop="datePublished" content="2015-10-08T09:09:00+00:00">
  <meta itemprop="dateModified" content="2015-10-08T09:09:00+00:00">
  <meta itemprop="wordCount" content="36569">
  <meta itemprop="keywords" content="Cpp">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="C&#43;&#43; Primer 第五版 学习笔记 Part III">
  <meta name="twitter:description" content="Copy Control A class controls what happens when objects of class type are copied, moved, assigned, and destroyed by defining five special member functions: copy constructor, move constructor, copy-assignment operator, move-assignment operator, destructor. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy and move assignment operators define what happens when we assign an object of a class">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">挥剑对风尘</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">挥剑对风尘</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Primer 第五版 学习笔记 Part III</h1>

      <div class="post-meta">
        <span class="post-time"> 2015-10-08 </span>
        <div class="post-category">
            <a href="/categories/cpp/"> cpp </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#copy-control">Copy Control</a>
      <ul>
        <li><a href="#the-copy-constructor">The Copy Constructor</a></li>
        <li><a href="#the-synthesized-copy-constructor">The Synthesized Copy Constructor</a></li>
        <li><a href="#copy-initialization">Copy Initialization</a></li>
        <li><a href="#the-copy-assignment-operator">The Copy-Assignment Operator</a></li>
        <li><a href="#the-destructor">The Destructor</a></li>
        <li><a href="#the-rule-of-copy-control-operations">The Rule of Copy Control Operations</a></li>
        <li><a href="#using--default">Using = default</a></li>
        <li><a href="#preventing-copies">Preventing Copies</a></li>
        <li><a href="#classes-that-act-like-values">Classes That Act Like Values</a></li>
        <li><a href="#classes-that-act-like-pointers">Classes That Act Like Pointers</a></li>
        <li><a href="#swap">Swap</a></li>
        <li><a href="#classes-that-manage-dynamic-memory">Classes That Manage Dynamic Memory</a></li>
        <li><a href="#rvalue-references">Rvalue References</a></li>
        <li><a href="#move-constructor">Move Constructor</a></li>
        <li><a href="#move-assignment-operator">Move-Assignment Operator</a></li>
        <li><a href="#the-synthesized-move-operations">The Synthesized Move Operations</a></li>
        <li><a href="#move-operation-defined-as-deleted">Move Operation Defined as Deleted</a></li>
        <li><a href="#which-constructor-to-use">Which Constructor to Use</a></li>
        <li><a href="#copy-and-swap-assignment-operators-and-move">Copy-and-Swap Assignment Operators and Move</a></li>
        <li><a href="#move-iterators">Move Iterators</a></li>
        <li><a href="#rvalue-references-and-member-functions">Rvalue References and Member Functions</a></li>
        <li><a href="#the-reference-qualifier">The reference qualifier</a></li>
        <li><a href="#overloading-and-reference-functions">Overloading and Reference Functions</a></li>
      </ul>
    </li>
    <li><a href="#overloaded-operations-and-conversions">Overloaded Operations and Conversions</a>
      <ul>
        <li><a href="#basic-concepts">Basic Concepts</a></li>
        <li><a href="#calling-overloaded-operator-directly">Calling Overloaded Operator Directly</a></li>
        <li><a href="#some-operators-shouldnt-be-overloaded">Some Operators Shouldn’t Be Overloaded</a></li>
        <li><a href="#use-definitions-that-are-consistent-with-the-built-in-meaning">Use Definitions That Are Consistent with the Built-in Meaning</a></li>
        <li><a href="#choosing-member-or-nonmember">Choosing Member or Nonmember</a></li>
        <li><a href="#overloading-the-output-operator">Overloading the Output Operator</a></li>
        <li><a href="#overloading-the-input-operator">Overloading the Input Operator</a></li>
        <li><a href="#arithmetic-and-relational-operators">Arithmetic and Relational Operators</a></li>
        <li><a href="#assignment-operators">Assignment Operators</a></li>
        <li><a href="#compound-assignment-operators">Compound-Assignment Operators</a></li>
        <li><a href="#subscript-operator">Subscript Operator</a></li>
        <li><a href="#increment-and-decrement-operators">Increment and Decrement Operators</a></li>
        <li><a href="#member-access-operators">Member Access Operators</a></li>
        <li><a href="#function-call-operator">Function-Call Operator</a></li>
        <li><a href="#lambdas-are-function-objects">Lambdas Are Function Objects</a></li>
        <li><a href="#library-defined-function-objects">Library-Defined Function Objects</a></li>
        <li><a href="#callable-objects-and-function">Callable Objects and function</a></li>
        <li><a href="#conversion-operators">Conversion Operators</a></li>
        <li><a href="#explicit-conversion-operators">explicit Conversion Operators</a></li>
        <li><a href="#conversion-to--bool">Conversion to  bool</a></li>
        <li><a href="#avoiding-ambiguous-conversions">Avoiding Ambiguous Conversions</a></li>
        <li><a href="#overloaded-functions-and-converting-constructors">Overloaded Functions and Converting Constructors</a></li>
        <li><a href="#overloaded-functions-and-user-defined-conversion">Overloaded Functions and User-Defined Conversion</a></li>
        <li><a href="#function-matching-and-overloaded-operators">Function Matching and Overloaded Operators</a></li>
      </ul>
    </li>
    <li><a href="#object-oriented-programming">Object-Oriented Programming</a>
      <ul>
        <li><a href="#inheritance">Inheritance</a></li>
        <li><a href="#dynamic-binding">Dynamic Binding</a></li>
        <li><a href="#defining-a-base-class">Defining a Base Class</a></li>
        <li><a href="#defining-a-derived-class">Defining a Derived Class</a></li>
        <li><a href="#derived-class-constructors">Derived-Class Constructors</a></li>
        <li><a href="#inheritance-and-static-members">Inheritance and static Members</a></li>
        <li><a href="#classes-used-as-a-base-class">Classes Used as a Base Class</a></li>
        <li><a href="#preventing-inheritance">Preventing Inheritance</a></li>
        <li><a href="#conversions-and-inheritance">Conversions and Inheritance</a></li>
        <li><a href="#virtual-functions">Virtual Functions</a></li>
        <li><a href="#abstract-base-classes">Abstract Base Classes</a></li>
        <li><a href="#access-control-and-inheritance">Access Control and Inheritance</a></li>
        <li><a href="#accessibility-of-derived-to-base-conversion">Accessibility of Derived-to-Base Conversion</a></li>
        <li><a href="#friendship-and-inheritance">Friendship and Inheritance</a></li>
        <li><a href="#exempting-individual-members">Exempting Individual Members</a></li>
        <li><a href="#default-inheritance-protection-levels">Default Inheritance Protection Levels</a></li>
        <li><a href="#class-scope-under-inheritance">Class Scope under Inheritance</a></li>
        <li><a href="#overriding-overloaded-functions">Overriding Overloaded Functions</a></li>
        <li><a href="#virtual-destructors">Virtual Destructors</a></li>
        <li><a href="#synthesized-copy-control-and-inheritance">Synthesized Copy Control and Inheritance</a></li>
        <li><a href="#move-operations-and-inheritance">Move Operations and Inheritance</a></li>
        <li><a href="#derived-class-copy-control-members">Derived-Class Copy-Control Members</a></li>
        <li><a href="#derived-class-assignment-operator">Derived-Class Assignment Operator</a></li>
        <li><a href="#derived-class-destructor">Derived-Class Destructor</a></li>
        <li><a href="#calls-to-virtuals-in-constructors-and-destructors">Calls to Virtuals in Constructors and Destructors</a></li>
        <li><a href="#inherited-constructors">Inherited Constructors</a></li>
        <li><a href="#containers-and-inheritance">Containers and Inheritance</a></li>
        <li><a href="#writing-a-basket-class">Writing a Basket Class</a></li>
      </ul>
    </li>
    <li><a href="#templates-and-generic-programming">Templates and Generic Programming</a>
      <ul>
        <li><a href="#function-templates">Function Templates</a></li>
        <li><a href="#nontype-template-parameters">Nontype Template Parameters</a></li>
        <li><a href="#inline-and--constexpr-function-templates">inline and  constexpr Function Templates</a></li>
        <li><a href="#type-independent-code">Type-Independent Code</a></li>
        <li><a href="#template-compilation">Template Compilation</a></li>
        <li><a href="#class-templates">Class Templates</a></li>
        <li><a href="#member-functions-of-class-templates">Member Functions of Class Templates</a></li>
        <li><a href="#class-templates-and-friends">Class Templates and Friends</a></li>
        <li><a href="#template-type-aliases">Template Type Aliases</a></li>
        <li><a href="#static-members-of-class-templates">static Members of Class Templates</a></li>
        <li><a href="#template-parameters">Template Parameters</a></li>
        <li><a href="#using-class-members-that-are-types">Using Class Members That Are Types</a></li>
        <li><a href="#default-template-arguments">Default Template Arguments</a></li>
        <li><a href="#member-templates">Member Templates</a></li>
        <li><a href="#controlling-instantiations">Controlling Instantiations</a></li>
        <li><a href="#efficiency-and-flexibility">Efficiency and Flexibility</a></li>
        <li><a href="#conversions-and-template-type-parameters">Conversions and Template Type Parameters</a></li>
        <li><a href="#function-parameters-that-use-the-same-template-parameter-type">Function Parameters That Use the Same Template Parameter Type</a></li>
        <li><a href="#normal-conversions-apply-for-ordinary-arguments">Normal Conversions Apply for Ordinary Arguments</a></li>
        <li><a href="#function-template-explicit-arguments">Function-Template Explicit Arguments</a></li>
        <li><a href="#trailing-return-type">Trailing Return Type</a></li>
        <li><a href="#type-transformation">Type Transformation</a></li>
        <li><a href="#function-pointers-and-argument-deduction">Function Pointers and Argument Deduction</a></li>
        <li><a href="#template-argument-deduction-and-references">Template Argument Deduction and References</a></li>
        <li><a href="#reference-collapsing-and-rvalue-reference-parameters">Reference Collapsing and Rvalue Reference Parameters</a></li>
        <li><a href="#understanding-stdmove">Understanding std::move</a></li>
        <li><a href="#forwarding">Forwarding</a></li>
        <li><a href="#overloading-and-templates">Overloading and Templates</a></li>
        <li><a href="#writing-overloaded-templates">Writing Overloaded Templates</a></li>
        <li><a href="#multiple-viable-templates">Multiple Viable Templates</a></li>
        <li><a href="#nontemplate-and-template-overloads">Nontemplate and Template Overloads</a></li>
        <li><a href="#overloaded-templates-and-conversions">Overloaded Templates and Conversions</a></li>
        <li><a href="#missing-declarations-can-cause-the-program-to-misbehave">Missing Declarations Can Cause the Program to Misbehave</a></li>
        <li><a href="#variadic-templates">Variadic Templates</a></li>
        <li><a href="#pack-expansion">Pack Expansion</a></li>
        <li><a href="#forwarding-parameter-packs">Forwarding Parameter Packs</a></li>
        <li><a href="#template-specializations">Template Specializations</a></li>
        <li><a href="#function-overloading-versus-template-specializations">Function Overloading versus Template Specializations</a></li>
        <li><a href="#class-template-specializations">Class Template Specializations</a></li>
        <li><a href="#class-template-partial-specializations">Class-Template Partial Specializations</a></li>
        <li><a href="#specializing-members-but-not-the-class">Specializing Members but Not the Class</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="copy-control">Copy Control</h1>
<p>A class controls what happens when objects of class type are copied, moved, assigned, and destroyed by defining five special member functions: copy constructor, move constructor, copy-assignment operator, move-assignment operator, destructor. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy and move assignment operators define what happens when we assign an object of a class type to another object of that same class type. The destructor defines what happens when an object ceases to exist. If a class does not define all of the copy-control members, the compiler automatically defines the missing operations.</p>
<h2 id="the-copy-constructor">The Copy Constructor</h2>
<p>A constructor is the <strong>copy constructor</strong> if its first parameter is a reference to the class type and any additional parameters have default values. The first parameter must be a reference type, and it is almost always a reference to const, although we can define a reference to nonconst. Unlike the synthesized default constructor, a copy constructor is synthesized even if we define other constructors.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="p">();</span>              <span class="o">//</span> <span class="n">default</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>    <span class="o">//</span> <span class="n">copy</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><!-- more --> 
<h2 id="the-synthesized-copy-constructor">The Synthesized Copy Constructor</h2>
<p>The type of each member determines how that member is copied: Members of class type are copied by the copy constructor for that class; members of built-in type are copied directly. Although we cannot directly copy an array, the synthesized copy constructor copies members of array type by copying each element. Elements of class type are copied by using the element&rsquo;s copy constructor. For example, the synthesized copy constructor:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Sales_data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="p">::</span><span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">orig</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookNo</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">bookNo</span><span class="p">),</span> <span class="o">//</span> <span class="n">use</span> <span class="n">the</span> <span class="n">string</span> <span class="n">copy</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl">    <span class="n">units_sold</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">units_sold</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">revenue</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">revenue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="copy-initialization">Copy Initialization</h2>
<p>We are now in a position to fully understand the differences between <strong>direct initialization</strong> and <strong>copy initialization</strong>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string dots(10, &#39;.&#39;);                // direct initialization
</span></span><span class="line"><span class="cl">string s(dots);                      // direct initialization
</span></span><span class="line"><span class="cl">string s2 = dots;                    // copy initialization
</span></span><span class="line"><span class="cl">string null_book = &#34;9-999-99999-9&#34;;  // copy initialization
</span></span><span class="line"><span class="cl">string nines = string(100, &#39;9&#39;);     // copy initialization
</span></span></code></pre></td></tr></table>
</div>
</div><p>When using direct initialization, we are asking the compiler to use ordinary function matching to select the constructor that best matches the arguments we provide. When we use copy initialization, we are asking the compiler to copy the right-hand operand into the object being created, converting that operand if necessary.</p>
<p>Copy initialization ordinary uses the copy constructor. However, if a class has a move constructor, then copy initialization sometimes uses the move constructor instead of the copy constructor. Copy initialization happens not only when we define variables using an =, but also when we</p>
<ul>
<li>pass an object as an argument to a parameter of nonreference type</li>
<li>return an object from a function that has a nonreference return type</li>
<li>brace initialization the elements in an array or the members of an aggregate class</li>
</ul>
<p>Some class types also use copy initialization for the objects they allocate. For example, the library containers copy initialize their elements when we initialize the container, or when we call an insert or push member. By contrast, elements created by an emplace member are direct initialized.</p>
<p>During a function call, parameters that have a nonreference type are copy initialized. This explains why the copy constructor&rsquo;s own parameters must be a reference. If that parameter were not a reference, then the call would never succeed.</p>
<p>Whether we use copy or direct initialization matters if we use an initializer that requires conversion by an explicit constructors:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">direct</span> <span class="n">initialization</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">constructor</span> <span class="n">that</span> <span class="n">takes</span> <span class="n">a</span> <span class="n">size</span> <span class="n">is</span> <span class="n">explicit</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">);</span> <span class="o">//</span> <span class="n">f</span><span class="s1">&#39;s parameter is copy initialized</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">can</span><span class="s1">&#39;t use an explicit constructor to copy an argument</span>
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>  <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">directly</span> <span class="n">construct</span> <span class="n">a</span> <span class="n">temporary</span> <span class="n">vector</span> <span class="n">from</span> <span class="n">an</span> <span class="ne">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If we want to use an explicit constructor, we must do so explicitly.</p>
<p>During copy initialization, the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly. That is, the compiler is permitted to rewrite</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string null_book = &#34;9-999-99999-9&#34;; // copy initialization
</span></span></code></pre></td></tr></table>
</div>
</div><p>into</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">null_book</span><span class="p">(</span><span class="s2">&#34;9-999-99999-9&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="n">compiler</span> <span class="n">omits</span> <span class="n">the</span> <span class="n">copy</span> <span class="n">constructor</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>However, even if the compiler omits the call to the copy/move constructor, the copy/move constructor must exist and must be accessible at that point in the program.</p>
<h2 id="the-copy-assignment-operator">The Copy-Assignment Operator</h2>
<p><strong>Overloaded operators</strong> are functions that have the name operator followed by the symbol for the operator being defined. Hence, the assignment operator is a function named operator=. The parameters in an overloaded operator represent the operands of the operator. When an operator is a member function, the left-hand operand is bound to implicit this parameter. The <strong>copy-assignment operator</strong> takes an argument of the same type as the class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">assignment</span> <span class="n">operator</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>To be consistent with assignment for built-in types, assignment operators usually return a reference to left-hand operand. As an example, the floowing is equivalent to the synthesized Sales_data copy-assignment operator:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">synthesized</span> <span class="n">copy</span><span class="o">-</span><span class="n">assignment</span> <span class="n">operator</span>
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">bookNo</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">bookNo</span><span class="p">;</span>  <span class="o">//</span> <span class="n">calls</span> <span class="n">the</span> <span class="n">string</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="n">units_sold</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">units_sold</span><span class="p">;</span>  <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="ne">int</span> <span class="n">assignment</span>
</span></span><span class="line"><span class="cl">    <span class="n">revenue</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">revenue</span><span class="p">;</span>   <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">double</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>  <span class="o">//</span> <span class="k">return</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">this</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="the-destructor">The Destructor</h2>
<p>Constructors initialize the nonstatic data members of an object and may do other work; destructors do whatever work is needed to free the resources used by an object and destroy the nonstatic data members of the object. The <strong>destructor</strong> is a member function with the name of the class prefixed by a tilde (~). It has no return value and takes no parameters:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Foo {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    ~Foo();  // destructor
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>In a constructor, members are initialized before the function body is executed, and members are initialized in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.</p>
<p>The built-in types do not have destructors, so nothing is done to destroy members of built-in type.</p>
<p>Unlike ordinary pointers, the smart pointers are class types and have destructors. As a result, members that are smart pointers are automatically destroyed during the destruction phase.</p>
<p>The destructor is used automatically whenever an object of its type is destroyed:</p>
<ul>
<li>variables are destroyed when they go out of scope</li>
<li>members of an object are destroyed when the object of which they are a part is destroyed</li>
<li>elements in a container or an array are destroyed when the container is destroyed</li>
<li>dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object</li>
<li>temporary objects are destroyed at the end of the full expression in which the temporary was created</li>
</ul>
<p>Note: the destructor is not run when a reference or a pointer to an object goes out of scope.</p>
<p>The members are automatically destroyed after the destructor body is run. It is important to realize that the destructor body does not directly destroy the members. Members are destroyed as part of the implicit destruction phase that follows the destructor body.</p>
<h2 id="the-rule-of-copy-control-operations">The Rule of Copy Control Operations</h2>
<p>One rule of thumb to use when you decide whether a class needs to define its own versions of the copy-control members is to decide first whether the class needs a destructor. If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well. The following example just explain this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">HasPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span> <span class="nf">f</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">hp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// copies the given HasPtr, multiple HasPtr objects may be pointing the same memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HasPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">hp</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// ret and hp are destroyed, so HasPtr destructor will be called twice, this is an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span> <span class="n">p</span><span class="p">(</span><span class="s">&#34;some values&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// when f completes, the memory is freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HasPtr</span> <span class="n">q</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// now both p and q point to invalid memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>To avoid using the synthesized copy constructor and copy-assignment operator for this class, we should define our own version:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">HasPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">()):</span> <span class="n">ps</span><span class="p">(</span><span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="n">delete</span> <span class="n">ps</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">):</span> <span class="n">ps</span><span class="p">(</span><span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="nb">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ps</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A second rule of thumb: If a class needs a copy constructor, it almost surely needs a copy-assignment operator. And vice versa, if the class needs an assignment operator, it almost surely needs a copy constructor as well. Nevertheless, needing either the copy constructor or the copy-assignment operator does not indicate the need for a destructor.</p>
<h2 id="using--default">Using = default</h2>
<p>Under the new standard, we can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as = default.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Sales_data</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">copy</span> <span class="n">control</span><span class="p">,</span> <span class="n">use</span> <span class="n">default</span>
</span></span><span class="line"><span class="cl">    <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we specify = default on the declaration in the class body, the synthesized function is implicitly inline (just as any other member function defined in the body of the class). If we don&rsquo;t want it inline, we can specify = default on the definition.</p>
<h2 id="preventing-copies">Preventing Copies</h2>
<p>Under the new standard C++ 11, we can prevent copies by defining the copy constructor and copy-assignment operator as <strong>deleted functions</strong>. A deleted function is one that is declared but may not be used in any other way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">NoCopy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NoCopy</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">NoCopy</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">NoCopy</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span> <span class="o">//</span> <span class="n">no</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl">    <span class="n">NoCopy</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span> <span class="o">//</span> <span class="n">no</span> <span class="n">assignment</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike = default, = delete must appear on the first declaration of a deleted function. Also, we can specify = delete on any function. But the destructor should not be a deleted member, or that member cannot be destroyed.</p>
<p>For some classes, the compiler defines these synthesized members as deleted functions:</p>
<ul>
<li>synthesized destructor is defined as deleted if class has a member whose own destructor is deleted or is inaccessible (private).</li>
<li>synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. It is also deleted if the class has a member with a deleted or inaccessible destructor.</li>
<li>synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, or if the class has a const or reference member.</li>
<li>synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; or has a reference member that does not have an in-class initializer; or has a const member whose type does not explicitly define a default constructor and that member does not have an in-class initializer.</li>
</ul>
<p>In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, then the corresponding member will be a deleted function.</p>
<p>It may be surprising that a member that has a deleted or inaccessible destructor causes the synthesized default and copy constructors to be defined as deleted. The reason is that without it, we could create objects that we could not destroy.</p>
<p>Prior to the new standard, classes prevented copies by declaring their copy constructor and copy-assignment operator as private. However, friends and members of the class can still make copies. To prevent these copies, we declare these members as private but do not define them. An attempt to use an undefined member results in a link-time failure. Classes that want to prevent copying should define their copy constructor and copy-assignment operator using = delete rather than making those members private.</p>
<h2 id="classes-that-act-like-values">Classes That Act Like Values</h2>
<p>To decide what copying an object of type mean, we have two choices: We can define the copy operations to make the class behave like a value or like a pointer. Classes that behave like values have their own state. Classes that act like pointers share state. To illustrate these two approaches, we&rsquo;ll make a class act like a value, then like a pointer.</p>
<p>To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. There are two points to keep in mind when you write an assignment operator:</p>
<ul>
<li>assignment operator must work correctly if an object is assigned to itself</li>
<li>most assignment operators share work with the destructor and copy constructor</li>
</ul>
<p>A good pattern to use is to first copy the right-hand operand into a local temporary. After the copy is done, it is safe to destroy the existing members of the left-hand operand.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">HasPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">()):</span> <span class="n">ps</span><span class="p">(</span><span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">To</span> <span class="n">act</span> <span class="n">like</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span> <span class="n">constructor</span> <span class="n">should</span> <span class="n">copy</span> <span class="n">string</span><span class="p">,</span> <span class="ow">not</span> <span class="n">just</span> <span class="n">the</span> <span class="n">pointer</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">):</span> <span class="n">ps</span><span class="p">(</span><span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">To</span> <span class="n">act</span> <span class="n">like</span> <span class="n">value</span><span class="p">,</span> <span class="n">the</span> <span class="n">copy</span> <span class="n">assignment</span> <span class="n">operator</span> <span class="n">should</span> <span class="n">free</span> <span class="n">the</span> <span class="n">object</span><span class="s1">&#39;s</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">existing</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">copy</span> <span class="n">the</span> <span class="n">string</span> <span class="n">from</span> <span class="n">its</span> <span class="n">right</span><span class="o">-</span><span class="n">hand</span> <span class="n">operand</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span> <span class="n">delete</span> <span class="n">ps</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">auto</span> <span class="n">newp</span> <span class="o">=</span> <span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="o">.</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ps</span> <span class="o">=</span> <span class="n">newp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="classes-that-act-like-pointers">Classes That Act Like Pointers</h2>
<p>The easiest way to make a class act like a pointer is to use shared_ptr to manage the resource in the class. Copying (assigning) a shared_ptr copies (assigns) the pointer to which the shared_ptr points. Sometimes we want to manage a resource directly, so we will do our own reference counting. <strong>Reference counting</strong> works as follows:</p>
<ul>
<li>each constructor (other than copy constructor) creates a counter that keep track of how many objects share state</li>
<li>copy constructor does not allocate a new counter, it just copies data members , including the counter. Then the copy constructor increments this shared counter, indicating that there is another user of that object&rsquo;s state.</li>
<li>the destructor decrements the counter. If the count goes to zero, the destructor deletes that state.</li>
<li>copy assignment operator increments the right-hand operand&rsquo;s counter and decrements the counter of the left-hand operand. If the counter for the left-hand operand goes to zero, we must destroy the state of the left-hand operand.</li>
</ul>
<p>So where to put the reference count ? One way to solve this problem is to store the counter in dynamic memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">HasPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">()):</span> <span class="n">ps</span><span class="p">(</span><span class="n">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">use</span><span class="p">(</span><span class="n">new</span> <span class="n">size_t</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">):</span> <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">i</span><span class="p">),</span> <span class="n">use</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">use</span><span class="p">)</span> <span class="p">{</span> <span class="o">++*</span><span class="n">use</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">HasPtr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span><span class="p">::</span><span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">delete</span> <span class="n">use</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++*</span><span class="n">rhs</span><span class="o">.</span><span class="n">use</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">delete</span> <span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">delete</span> <span class="n">use</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ps</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">ps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">use</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">use</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="swap">Swap</h2>
<p>In addition to defining the copy-control members, classes that manage resources often also define a function named <code>swap</code>. If a class defines its own <code>swap</code>, then the algorithm which need to exchange two elements uses that class-specific version. Otherwise, it uses the <code>swap</code> function defined by the library. The <strong>swap</strong> function involves a copy and two assignments:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HasPtr temp = v1; // make a temporary copy of the value of v1
</span></span><span class="line"><span class="cl">v1 = v2; // assign the value of v2 to v1
</span></span><span class="line"><span class="cl">v2 = temp; // assign the saved value of v1 to v2
</span></span></code></pre></td></tr></table>
</div>
</div><p>In principle, none of the memory allocation is necessary. Rather than allocating new copies of the string, we&rsquo;d like <code>swap</code> to swap the pointers. We can override the default behavior of <code>swap</code> by defining a version of <code>swap</code> that operate on our class.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class HasPtr {
</span></span><span class="line"><span class="cl">    friend void swap(HasPtr&amp;, HasPtr&amp;);
</span></span><span class="line"><span class="cl">    // other members
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">inline void swap(HasPtr &amp;lhs, HasPtr &amp;rhs){
</span></span><span class="line"><span class="cl">    swap(lhs.ps, rhs.ps);
</span></span><span class="line"><span class="cl">    swap(lhs.i, rhs.i);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Classes that define swap often use swap to define their assignment operator. These operators use a technique known as <strong>copy and swap</strong>. This technique swaps the left-hand operand with a copy of the right-hand operand:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">swap</span> <span class="n">the</span> <span class="n">content</span> <span class="n">of</span> <span class="n">the</span> <span class="n">left</span><span class="o">-</span><span class="n">hand</span> <span class="n">operand</span> <span class="n">with</span> <span class="n">local</span> <span class="n">variable</span> <span class="n">rhs</span>
</span></span><span class="line"><span class="cl">    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="o">//</span> <span class="n">rhs</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">this</span> <span class="n">object</span> <span class="n">had</span> <span class="n">used</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="o">//</span> <span class="n">rhs</span> <span class="n">is</span> <span class="n">destroyed</span><span class="p">,</span> <span class="n">which</span> <span class="n">deletes</span> <span class="n">the</span> <span class="n">pointer</span> <span class="ow">in</span> <span class="n">rhs</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this version of the assignment operator, the parameter is not a reference. Instead, we pass the right-hand operand by value. Copying a HasPtr allocates a new copy of that object&rsquo;s string. When it finishes, rhs is destroyed and the destructor deletes the memory to which rhs now points. The interesting thing about this technique is that it automatically handles self assignment and is automatically exception safe.</p>
<h2 id="classes-that-manage-dynamic-memory">Classes That Manage Dynamic Memory</h2>
<p>Some classes need to allocate a varying amount of storage at run time. Such classes often can use a library container to hold their data. However, this strategy does not work for every class; some classes need to do their own allocation. Such classes generally must define their own copy-control members to manage the memory they allocate. As an example, we’ll implement a simplification of the library vector<string> class.</p>
<p>In our StrVec class, We&rsquo;ll use an allocator to obtain raw memory. Then we can use the allocator&rsquo;s construct member to create objects in that space when we need to add an element, and use the destroy member to remove an element. Each StrVec will have three pointers into the space it uses for its elements:</p>
<ul>
<li>elements, which points to the first element in the allocated memory</li>
<li>first_free, which points just after the last actual element</li>
<li>cap, which points just past the end of the allocated memory</li>
</ul>
<p>In addition to these pointers, StrVec will have a member named alloc that is an allocator<string>. The alloc member will allocate the memory used by a StrVec. Our class will also have four utility functions:</p>
<ul>
<li><code>alloc_n_copy</code> will allocate space and copy a given range of elements.</li>
<li><code>free</code> will destroy the constructed elements and deallocate the space.</li>
<li><code>chk_n_alloc</code> will ensure that there is room to add at least one more element to the StrVec. If there isn’t room for another element, chk_n_alloc will call reallocate to get more space.</li>
<li><code>reallocate</code> will reallocate the StrVec when it runs out of space</li>
</ul>
<p>Copying a string copies the data because ordinarily after we copy a string, there are two users of that string. However, when reallocate copies the strings in a StrVec, there will be only one user of these strings after the copy. So copying the data in these strings is unnecessary.</p>
<p>Under the new standard, we can avoid copying the strings by using two facilities. First, the library classes define &ldquo;move constructors&rdquo;. The move constructors operate by &ldquo;moving&rdquo; resources from the given object to the object being constructed. For example, the string move constructor copies the pointer rather than allocating space for copying the characters themselves. Second, we&rsquo;ll use a library function named <strong>move</strong>, defined in utility header. There are two points about move:</p>
<ul>
<li>When reallocate constructs strings in the new memory, it must call move to signal that it wants to use the string move constructor. If it omits this call, the copy constructor will be used.</li>
<li>We usually do not provide a using declaration for move. When we use move, we call std::move, not move.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">StrVec</span><span class="p">()</span><span class="o">:</span> <span class="n">elements</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">first_free</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">cap</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">StrVec</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">StrVec</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">StrVec</span><span class="p">()</span> <span class="p">{</span> <span class="n">free</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">first_free</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="nf">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span><span class="o">*</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span><span class="o">*</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">first_free</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">size_t</span> <span class="n">new_cap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">size_t</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">chk_n_alloc</span><span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">())</span> <span class="n">reallocate</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">*&gt;</span> <span class="n">alloc_n_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">e</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">alloc_n_move</span><span class="p">(</span><span class="n">size_t</span> <span class="n">new_cap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">free</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">reallocate</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">first_free</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ensure there is room for another element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">chk_n_alloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// construct a copy of s in the element to which first_free points
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the string copy constructor will be called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// allocate storage and copy elements into the newly allocated space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">*&gt;</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">alloc_n_copy</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// the first data points to the start of the allocated memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the second points to one element past the last constructed element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">data</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">free</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// destroy old elements in reverse order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// destroy function runs the string destructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">first_free</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">elements</span><span class="p">;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">elements</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrVec</span><span class="o">::</span><span class="n">StrVec</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">newdata</span> <span class="o">=</span> <span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">elements</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_free</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrVec</span><span class="o">&amp;</span> <span class="n">StrVec</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">elements</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_free</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">reallocate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">newcapacity</span> <span class="o">=</span> <span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">alloc_n_move</span><span class="p">(</span><span class="n">newcapacity</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">alloc_n_move</span><span class="p">(</span><span class="n">size_t</span> <span class="n">new_cap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// allocate new memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">newdata</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">new_cap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// move data from old memory to the new
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">;</span> <span class="c1">// points the next free position in the new array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">auto</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">elements</span><span class="p">;</span> <span class="c1">// points to the next element in the old array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// move returns a result that causes construct to use the string move constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the memory managed by those strings will not be copied, and each string we construct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// will take over ownership of the memory from the string to which elem points
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">dest</span><span class="o">++</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">elem</span><span class="o">++</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">free</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">elements</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_free</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cap</span> <span class="o">=</span> <span class="n">elements</span> <span class="o">+</span> <span class="n">new_cap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">size_t</span> <span class="n">new_cap</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">new_cap</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">alloc_n_move</span><span class="p">(</span><span class="n">new_cap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">resize</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">string</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">first_free</span> <span class="o">!=</span> <span class="n">elements</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">first_free</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">capacity</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="n">reverse</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">StrVec</span> <span class="n">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">words</span><span class="p">.</span><span class="n">reverse</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;how&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;are&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;you&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">words</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note: One of the major features in the new standard is the ability to move rather than copy an object. The library containers, string, and shared_ptr clases support move as well as copy. The IO and unique_ptr classes can be moved but not copied.</p>
<h2 id="rvalue-references">Rvalue References</h2>
<p>To support move operations, the new standard introduced a new kind of reference, an <strong>rvalue reference</strong>. An rvalue reference is a reference that must be bound to an rvalue. An rvalue reference is obtained by using &amp;&amp; rather than &amp;. As we&rsquo;ll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. Generally speaking, an lvalue expression refers to an object&rsquo;s identity whereas an rvalue expression refers to an object&rsquo;s value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">r</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="o">&amp;&amp;</span><span class="n">rr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">bind</span> <span class="n">an</span> <span class="n">rvalue</span> <span class="n">reference</span> <span class="n">to</span> <span class="n">an</span> <span class="n">lvalue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span> <span class="n">is</span> <span class="n">an</span> <span class="n">rvalue</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">we</span> <span class="n">can</span> <span class="n">bind</span> <span class="n">a</span> <span class="n">reference</span> <span class="n">to</span> <span class="k">const</span> <span class="n">to</span> <span class="n">an</span>
</span></span><span class="line"><span class="cl"><span class="n">rvalue</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">42</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">bind</span> <span class="n">rr2</span> <span class="n">to</span> <span class="n">the</span> <span class="n">result</span> <span class="n">of</span> <span class="n">the</span> <span class="n">multiplication</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Variables are lvalues. As a result, we cannot bind an rvalue reference to a variable defined as an rvalue reference type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int &amp;&amp;rr1 = 42; // ok: literals are rvalues
</span></span><span class="line"><span class="cl">int &amp;&amp;rr2 = rr1; // error: the expression rr1 is an lvalue!
</span></span></code></pre></td></tr></table>
</div>
</div><p>Alghough we cannot directly bind an rvalue reference to an lvalue, we can explicitly cast an lvalue to its corresponding rvalue reference type. We can also obtain an rvalue reference bound to an lvaue by calling a new library function named <code>move</code>, which is defined in the utility header. The move function uses facilities to return an rvalue reference to its given object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int &amp;&amp;rr3 = std::move(rr1); // ok
</span></span></code></pre></td></tr></table>
</div>
</div><p>Calling move tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. It is essential to realize that the call to move promises that we do not intend to use rr1 again except to assign to it or to destroy it. After a call to move, we cannot make any assumptions about the value of the moved-from object. We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.</p>
<p>Code that uses move should use std::move, not move. Doing so avoids potential name collisions.</p>
<h2 id="move-constructor">Move Constructor</h2>
<p>To enable move operations for our own types, we define a move constructor and a move-assignment operator. These members are similar to the corresponding copy operations, but they “steal” resources from their given object rather than copy them.</p>
<p>Like the copy constructor, the <strong>move constructor</strong> has an initial parameter that is a reference to the class type. Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. As in the copy constructor, any additional parameters must all have default arguments. In addition to moving resources, the move constructor must ensure that the moved-from object is left in a state such that destroying that object will be harmless. In particular, once its resources are moved, the original object must no longer point to those moved resources. Responsibility for those resources has been assumed by the newly created object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">StrVec::StrVec(StrVec &amp;&amp;s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) {
</span></span><span class="line"><span class="cl">    // leave s in a state in which it is safe to run the destructor
</span></span><span class="line"><span class="cl">    s.elements = s.first_free = s.cap = nullptr;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike the copy constructor, the move constructor does not allocate any new memory; it takes over the memory in the given object. As a result, move operations ordinarily will not throw any exceptions. As we’ll see, unless the library knows that our move constructor won’t throw, it will do extra work to cater to the possibliity that moving an object of our class type might throw. One way inform the library is to specify <code>noexcept</code> on our constructor. We specify noexcept on a function after its parameter list. Move constructors and move assignment operators that cannot throw exceptions should be marked as noexcept.</p>
<p>So why noexcept is needed ? The push_back operation in the class StrVec might require that the vector be reallocated. As we’ve just seen, moving an object generally changes the value of the moved-from object. If reallocation uses a move constructor which throw an exception after moving some but not all of elements, the moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. In this case, vector would be unable to meet its requirement that the vector is left unchanged. On the other hand, if vector uses the copy constructor and an exception happens, it can easily meet this requirement. In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. If we want objects of our type to be moved rather than copied in circumstances such as vector reallocation, we must explicity tell the library that our move constructor is safe to use by using noexcept.</p>
<h2 id="move-assignment-operator">Move-Assignment Operator</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">StrVec&amp; StrVec::operator=(StrVec &amp;&amp;rhs) noexcept {
</span></span><span class="line"><span class="cl">    // direct test for self-assignment
</span></span><span class="line"><span class="cl">    if (this != &amp;rhs) {
</span></span><span class="line"><span class="cl">        free();
</span></span><span class="line"><span class="cl">        elements = rhs.elements;
</span></span><span class="line"><span class="cl">        first_free = rhs.first_free;
</span></span><span class="line"><span class="cl">        cap = rhs.cap;
</span></span><span class="line"><span class="cl">        // leave rhs in a destructible state
</span></span><span class="line"><span class="cl">        rhs.elements = rhs.first_free = rhs.cap = nullptr;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">    return *this;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Moving from an object does not destroy that object: Sometime after the move operation completes, the moved-from object will be destroyed. Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in which the destructor can be run. After a move operation, the moved-from object must remain a valid, destructible object but users may make no assumptions about its value.</p>
<h2 id="the-synthesized-move-operations">The Synthesized Move Operations</h2>
<p>Recall that if we do not declare our own copy constructor or copy-assignment operator the compiler always synthesizes these operations. The compiler will synthesize a move constructor or a move-assignment operator only if the class doesn’t define any of its own copy-control members and if every nonstatic data member of the class can be moved.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">compiler</span> <span class="n">will</span> <span class="n">synthesize</span> <span class="n">the</span> <span class="n">move</span> <span class="n">operations</span> <span class="k">for</span> <span class="n">X</span> <span class="ow">and</span> <span class="n">hasX</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="ne">int</span> <span class="n">i</span><span class="p">;</span> <span class="o">//</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">types</span> <span class="n">can</span> <span class="n">be</span> <span class="n">moved</span>
</span></span><span class="line"><span class="cl">	<span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="o">//</span> <span class="n">string</span> <span class="n">defines</span> <span class="n">its</span> <span class="n">own</span> <span class="n">move</span> <span class="n">operations</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">hasX</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">X</span> <span class="n">mem</span><span class="p">;</span> <span class="o">//</span> <span class="n">X</span> <span class="n">has</span> <span class="n">synthesized</span> <span class="n">move</span> <span class="n">operations</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">X</span> <span class="n">x</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">synthesized</span> <span class="n">move</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="n">hasX</span> <span class="n">hx</span><span class="p">,</span> <span class="n">hx2</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">hx</span><span class="p">);</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">synthesized</span> <span class="n">move</span> <span class="n">constructor</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="move-operation-defined-as-deleted">Move Operation Defined as Deleted</h2>
<p>Unlike the copy operations, a move operation is never implicitly defined as a <strong>deleted function</strong>. However, if we explicitly ask the compiler to generate a move operation by using = default, and the compiler is unable to move all the members, then the move operation will be defined as deleted. The rules for when a synthesized move operation is defined as deleted:</p>
<ul>
<li>Unlike the copy constructor, the move constructor is defined as deleted if the class has a member that defines its own copy constructor but does not also define a move constructor, or if the class has a member that doesn’t define its own copy operations and for which the compiler is unable to synthesize a move constructor. Similarly for move-assignment.</li>
<li>The move constructor or move-assignment operator is defined as deleted if the class has a member whose own move constructor or move-assignment operator is deleted or inaccessible.</li>
<li>Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.</li>
<li>Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a const or reference member.</li>
</ul>
<p>Note: Classes that define a move constructor or move-assignment operator must also define their own copy operations. Otherwise, those members are deleted by default.</p>
<h2 id="which-constructor-to-use">Which Constructor to Use</h2>
<p>When a class has both a move constructor and a copy constructor, the compiler uses ordinary function matching to determine which constructor to use. Similarly for assignment. If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling move.</p>
<h2 id="copy-and-swap-assignment-operators-and-move">Copy-and-Swap Assignment Operators and Move</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">HasPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">added</span> <span class="n">move</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl">	<span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">p</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">:</span> <span class="n">ps</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">ps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">assignment</span> <span class="n">operator</span> <span class="n">is</span> <span class="n">both</span> <span class="n">the</span> <span class="n">move</span><span class="o">-</span><span class="n">assignment</span> <span class="ow">and</span> <span class="n">copy</span><span class="o">-</span><span class="n">assignment</span> <span class="n">operator</span>
</span></span><span class="line"><span class="cl">	<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If we add a move constructor to this class, it will effectively get a move assignment operator as well. Now let’s look at the assignment operator. That operator has a nonreference parameter, which means the parameter is copy initialized. Copy initialization uses either the copy constructor or the move constructor; lvalues are copied and rvalues are moved. As a result, this single assignment operator acts as both the copy-assignment and move-assignment operator.</p>
<p>The third rule of thumb: All five copy-control members should be thought of as a unit. Ordinarily, if a class defines any of these operations, it usually should define them all.</p>
<h2 id="move-iterators">Move Iterators</h2>
<p>The reallocate member of StrVec used a for loop to call construct to copy the elements from the old memory to the new. As an alternative to writing that loop, it would be easier if we could call uninitialized_copy to construct the newly allocated space. However, uninitialized_copy does what it says: It copies the elements. There is no analogous library function to “move” objects into unconstructed memory.</p>
<p>Instead, the new library defines a <strong>move iterator</strong> adaptor. A move iterator adapts its given iterator by changing the behavior of the iterator’s dereference operator. Ordinarily, an iterator dereference operator returns an lvalue reference to the element. Unlike other iterators, the dereference operator of a move iterator yields an rvalue reference.</p>
<p>We transform an ordinary iterator to a move iterator by calling the library <code>make_move_iterator</code> function. This function takes an iterator and returns a move iterator. All of the original iterator’s other operations work as usual.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void StrVec::reallocate()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // allocate space for twice as many elements as the current size
</span></span><span class="line"><span class="cl">    auto newcapacity = size() ? 2 * size() : 1;
</span></span><span class="line"><span class="cl">    auto first = alloc.allocate(newcapacity);
</span></span><span class="line"><span class="cl">    // move the elements
</span></span><span class="line"><span class="cl">    auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
</span></span><span class="line"><span class="cl">    free(); // free the old space
</span></span><span class="line"><span class="cl">    elements = first; // update the pointers
</span></span><span class="line"><span class="cl">    first_free = last;
</span></span><span class="line"><span class="cl">    cap = elements + newcapacity;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>uninitialized_copy calls construct on each element in the input sequence to “copy” that element into the destination. That algorithm uses the iterator dereference operator to fetch elements from the input sequence.  Because we passed move iterators, the dereference operator yields an rvalue reference, which means construct will use the move constructor to construct the elements. You should pass move iterators to algorithms only when you are confident that the algorithm does not access an element after it has assigned to that element or passed that element to a user-defined function.</p>
<p>Because a moved-from object has indeterminate state, calling std::move on an object is a dangerous operation. When we call move, we must be absolutely certain that there can be no other users of the moved-from object.</p>
<h2 id="rvalue-references-and-member-functions">Rvalue References and Member Functions</h2>
<p>Member functions other than constructors and assignment can benefit from providing both copy and move versions. For example, the library containers that define push_back provide two versions:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">copy</span><span class="p">:</span> <span class="n">binds</span> <span class="n">to</span> <span class="n">any</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">X</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">move</span><span class="p">:</span> <span class="n">binds</span> <span class="n">only</span> <span class="n">to</span> <span class="n">modifiable</span> <span class="n">rvalues</span> <span class="n">of</span> <span class="n">type</span> <span class="n">X</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Overloaded functions that distinguish between moving and copying a parameter typically have one version that takes a const T&amp; and one that takes a T&amp;&amp;. Ordinarily, there is no need to define versions of the operation that take a const X&amp;&amp; or a (plain) X&amp;. Usually, we pass an rvalue reference when we want to “steal” from the argument. In order to do so, the argument must not be const. Similarly, copying from an object should not change the object being copied.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">StrVec</span><span class="p">::</span><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">chk_n_alloc</span><span class="p">();</span> <span class="o">//</span> <span class="n">ensure</span> <span class="n">that</span> <span class="n">there</span> <span class="n">is</span> <span class="n">room</span> <span class="k">for</span> <span class="n">another</span> <span class="n">element</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">construct</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">element</span> <span class="n">to</span> <span class="n">which</span> <span class="n">first_free</span> <span class="n">points</span>
</span></span><span class="line"><span class="cl">	<span class="n">alloc</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">StrVec</span><span class="p">::</span><span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">chk_n_alloc</span><span class="p">();</span> <span class="o">//</span> <span class="n">reallocates</span> <span class="n">the</span> <span class="n">StrVec</span> <span class="k">if</span> <span class="n">necessary</span>
</span></span><span class="line"><span class="cl">	<span class="n">alloc</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The difference is that the rvalue reference version of push_back calls move to pass its parameter to construct. As we’ve seen, the construct function uses the type of its second and subsequent arguments to determine which constructor to use.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">StrVec</span> <span class="n">vec</span><span class="p">;</span> <span class="o">//</span> <span class="n">empty</span> <span class="n">StrVec</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;some string or another&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">vec</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">vec</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="s2">&#34;done&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">push_back</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we call push_back the type of the argument determines whether the new element is copied or moved into the container. These calls differ as to whether the argument is an lvalue (s) or an rvalue (the temporary string created from &ldquo;done&rdquo;).</p>
<h2 id="the-reference-qualifier">The reference qualifier</h2>
<p>The following usage can be surprising when we assign to the rvalue. Prior to the new standard, there was no way to prevent such usage. In order to maintain backward compatability, the library classes continue to allow assignment to rvalues, However, we might want to prevent such usage in our own classes. In this case, we’d like to force the left-hand operand to be an lvalue.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string s1 = &#34;a value&#34;, s2 = &#34;another&#34;;
</span></span><span class="line"><span class="cl">s1 + s2 = &#34;wow!&#34;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>C++ 11, We indicate the lvalue/rvalue property of &ldquo;this&rdquo; in the same way that we define const member functions; we place a <strong>reference qualifier</strong> after the parameter list.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">;</span> <span class="o">//</span> <span class="n">may</span> <span class="n">assign</span> <span class="n">only</span> <span class="n">to</span> <span class="n">modifiable</span> <span class="n">lvalues</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Foo</span> <span class="o">&amp;</span><span class="n">Foo</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="k">do</span> <span class="n">whatever</span> <span class="n">is</span> <span class="n">needed</span> <span class="n">to</span> <span class="n">assign</span> <span class="n">rhs</span> <span class="n">to</span> <span class="n">this</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The reference qualifier can be either &amp; or &amp;&amp;, indicating that &ldquo;this&rdquo; may point to an lvalue or rvalue, respectively. Like the const qualifier, a reference qualifier may appear only on a (nonstatic) member function and must appear in both the declaration and definition of the function.</p>
<p>A function can be both const and reference qualified. In such cases, the reference qualifier must follow the const qualifier:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span> <span class="n">someMem</span><span class="p">()</span> <span class="o">&amp;</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="k">const</span> <span class="n">qualifier</span> <span class="n">must</span> <span class="n">come</span> <span class="n">first</span>
</span></span><span class="line"><span class="cl">	<span class="n">Foo</span> <span class="n">anotherMem</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="k">const</span> <span class="n">qualifier</span> <span class="n">comes</span> <span class="n">first</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="overloading-and-reference-functions">Overloading and Reference Functions</h2>
<p>Just as we can overload a member function based on whether it is const, we can also overload a function based on its reference qualifier.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span> <span class="o">//</span> <span class="n">may</span> <span class="n">run</span> <span class="n">on</span> <span class="n">modifiable</span> <span class="n">rvalues</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span> <span class="o">//</span> <span class="n">may</span> <span class="n">run</span> <span class="n">on</span> <span class="n">any</span> <span class="n">kind</span> <span class="n">of</span> <span class="n">Foo</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">of</span> <span class="n">Foo</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">this</span> <span class="n">object</span> <span class="n">is</span> <span class="n">an</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">so</span> <span class="n">we</span> <span class="n">can</span> <span class="n">sort</span> <span class="ow">in</span> <span class="n">place</span>
</span></span><span class="line"><span class="cl"><span class="n">Foo</span> <span class="n">Foo</span><span class="p">::</span><span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">this</span> <span class="n">object</span> <span class="n">is</span> <span class="n">either</span> <span class="k">const</span> <span class="ow">or</span> <span class="n">it</span> <span class="n">is</span> <span class="n">an</span> <span class="n">lvalue</span><span class="p">;</span> <span class="n">either</span> <span class="n">way</span> <span class="n">we</span> <span class="n">can</span><span class="s1">&#39;t sort in place</span>
</span></span><span class="line"><span class="cl"><span class="n">Foo</span> <span class="n">Foo</span><span class="p">::</span><span class="n">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">ret</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span> <span class="o">//</span> <span class="n">make</span> <span class="n">a</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl">    <span class="n">sort</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ret</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">end</span><span class="p">());</span> <span class="o">//</span> <span class="n">sort</span> <span class="n">the</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="o">//</span> <span class="k">return</span> <span class="n">the</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The object is an rvalue, which means it has no other users, so we can change the object itself. When we run sorted on a const rvalue or on an lvalue, we can’t change this object, so we copy data before sorting it. Overload resolution uses the lvalue/rvalue property of the object that calls sorted to determine which version is used:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">retVal</span><span class="p">()</span><span class="o">.</span><span class="n">sorted</span><span class="p">();</span> <span class="o">//</span> <span class="n">retVal</span><span class="p">()</span> <span class="n">is</span> <span class="n">an</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">calls</span> <span class="n">Foo</span><span class="p">::</span><span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">retFoo</span><span class="p">()</span><span class="o">.</span><span class="n">sorted</span><span class="p">();</span> <span class="o">//</span> <span class="n">retFoo</span><span class="p">()</span> <span class="n">is</span> <span class="n">an</span> <span class="n">lvalue</span><span class="p">,</span> <span class="n">calls</span> <span class="n">Foo</span><span class="p">::</span><span class="n">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we define two or more members that have the same name and the same parameter list, we must provide a reference qualifier on all or none of those functions:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">must</span> <span class="n">have</span> <span class="n">reference</span> <span class="n">qualifier</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">Comp</span> <span class="n">is</span> <span class="n">type</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">the</span> <span class="n">function</span> <span class="n">type</span> <span class="p">(</span><span class="n">see</span> <span class="err">§</span> <span class="mf">6.7</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span> <span class="mi">249</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">that</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">compare</span> <span class="ne">int</span> <span class="n">values</span>
</span></span><span class="line"><span class="cl">    <span class="n">using</span> <span class="n">Comp</span> <span class="o">=</span> <span class="ne">bool</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">(</span><span class="n">Comp</span><span class="o">*</span><span class="p">);</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">different</span> <span class="n">parameter</span> <span class="n">list</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">sorted</span><span class="p">(</span><span class="n">Comp</span><span class="o">*</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">neither</span> <span class="n">version</span> <span class="n">is</span> <span class="n">reference</span> <span class="n">qualified</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="overloaded-operations-and-conversions">Overloaded Operations and Conversions</h1>
<p>C++ lets us define what the operators mean when applied to objects of class type. It also lets us define conversions for class types. Class-type conversions are used like the built-in conversions to implicitly convert an object of one type to another type when needed. Operator overloading lets us define the meaning of an operator when applied to operand(s) of a class type. Judicious use of operator overloading can make our programs easier to write and easier to read.</p>
<h2 id="basic-concepts">Basic Concepts</h2>
<p>Overloaded operators are functions with special names: the keyword <code>operator</code> followed by the symbol for the operator being defined. An overloaded operator function has the same number of parameters as the operator has operands. When an overloaded operator is a member function, <code>this</code> is bound to the left-hand operand. Member operator functions have one less (explicit) parameter than the number of operands.</p>
<p>We cannot change the meaning of an operator when applied to operands of built-in type. We can overload only existing operators and cannot invent new operator symbols. For example, we cannot define <code>operator**</code> to provide exponentiation. Four symbols (+, -, *, and &amp;) serve as both unary and binary operators. Either or both of these operators can be overloaded. An overloaded operator has the same precedence and associativity as the corresponding built-in operator.</p>
<h2 id="calling-overloaded-operator-directly">Calling Overloaded Operator Directly</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// equivalent calls to a nonmember operator function
</span></span><span class="line"><span class="cl">data1 + data2;            // normal expression
</span></span><span class="line"><span class="cl">operator+(data1, data2);  // equivalent function call
</span></span></code></pre></td></tr></table>
</div>
</div><p>These calls are equivalent: Both call the nonmember function operator+, passing data1 as the first argument and data2 as the second. And we call a member operator function explicitly in the same way that we call any other member function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">data1 += data2;          // expression-based &#39;&#39;call&#39;&#39;
</span></span><span class="line"><span class="cl">data1.operator+=(data2); // equivalent call to a member operator function
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="some-operators-shouldnt-be-overloaded">Some Operators Shouldn’t Be Overloaded</h2>
<p>Because the overloaded versions of these operators do not preserve order of evaluation and/or short-circuit evaluation, it is usually a bad idea to overload them. Ordinarily, the comma, address-of, logical  AND , and logical  OR operators should  not be overloaded.</p>
<h2 id="use-definitions-that-are-consistent-with-the-built-in-meaning">Use Definitions That Are Consistent with the Built-in Meaning</h2>
<ul>
<li>If the class does IO, define the shift operators to be consistent with how IO is done for the built-in types.</li>
<li>If the class has an operation to test for equality, define operator==. If the class has operator==, it should usually have operator!= as well.</li>
<li>If the class has a single, natural ordering operation, define operator&lt;. If the class has operator&lt;, it should probably have all of the relational operators.</li>
<li>The return type of an overloaded operator usually should be compatible with the return from the built-in version of the operator.</li>
</ul>
<p>Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type.</p>
<h2 id="choosing-member-or-nonmember">Choosing Member or Nonmember</h2>
<p>When we define an overloaded operator, we must decide whether to make the operator a class member or an ordinary nonmember function.</p>
<ul>
<li>The assignment (=), subscript ([]), call (()), and member access arrow (-&gt;) operators  must be defined as members.</li>
<li>The compound-assignment operators ordinarily  ought to be members. However, unlike assignment, they are not required to be members.</li>
<li>Operators that change the state of their object or that are closely tied to their given type—such as increment, decrement, and dereference—usually should be members.</li>
<li>Symmetric operators—those that might convert either operand, such as the arithmetic, equality, relational, and bitwise operators—usually should be defined as ordinary nonmember functions.</li>
</ul>
<p>Programmers expect to be able to use symmetric operators in expressions with mixed types. For example, we can add an int and a double. The addition is symmetric because we can use either type as the left-hand or the right-hand operand. If we want to provide similar mixed-type expressions involving class objects, then the operator must be defined as a nonmember function. When we define an operator as a member function, then the left-hand operand must be an object of the class of which that operator is a member. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;world&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">t</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s2">&#34;!&#34;</span><span class="p">;</span>  <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">we</span> <span class="n">can</span> <span class="n">add</span> <span class="n">a</span> <span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">to</span> <span class="n">a</span> <span class="n">string</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">u</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span> <span class="o">//</span> <span class="n">would</span> <span class="n">be</span> <span class="n">an</span> <span class="n">error</span> <span class="k">if</span> <span class="o">+</span> <span class="n">were</span> <span class="n">a</span> <span class="n">member</span> <span class="n">of</span> <span class="n">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If operator+ were a member of the string class, the first addition would be equivalent to s.operator+(&quot;!&quot;). Likewise, &ldquo;hi&rdquo; + s would be equivalent to &ldquo;hi&rdquo;.operator+(s). However, the type of &ldquo;hi&rdquo; is const char*, and that is a built-in type; it does not even have member functions.</p>
<h2 id="overloading-the-output-operator">Overloading the Output Operator</h2>
<p>Ordinarily, the first parameter of an output operator is a reference to a nonconst ostream object. The ostream is nonconst because writing to the stream changes its state. The parameter is a reference because we cannot copy an ostream object. The second parameter ordinarily should be a reference to const of the class type we want to print. The parameter is a reference to avoid copying the argument. It can be const because (ordinarily) printing an object does not change that object. To be consistent with other output operators, operator&laquo; normally returns its ostream parameter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">units_sold</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">revenue</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">avg_price</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Generally, output operators should print the contents of the object, with minimal formatting. They should not print a newline.</p>
<p>Input and output operators that conform to the conventions of the iostream library must be ordinary nonmember functions.</p>
<h2 id="overloading-the-input-operator">Overloading the Input Operator</h2>
<p>Ordinarily the first parameter of an input operator is a reference to the stream from which it is to read, and the second parameter is a reference to the (nonconst) object into which to read. The operator usually returns a reference to its given stream.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    double price; // no need to initialize; we&#39;ll read into price before we use it
</span></span><span class="line"><span class="cl">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
</span></span><span class="line"><span class="cl">    if (is) // check that the inputs succeeded
</span></span><span class="line"><span class="cl">        item.revenue = item.units_sold * price;
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        item = Sales_data(); // input failed: give the object the default state
</span></span><span class="line"><span class="cl">    return is;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Input operators must deal with the possibility that the input might fail; output operators generally don’t bother. Some input operators need to do additional data verification. In such cases, the input operator might need to set the stream’s condition state to indicate failure, even though technically speaking the actual IO was successful. Usually an input operator should set only the <code>failbit</code>. Setting <code>eofbit</code> would imply that the file was exhausted, and setting <code>badbit</code> would indicate that the stream was corrupted. These errors are best left to the IO library itself to indicate.</p>
<h2 id="arithmetic-and-relational-operators">Arithmetic and Relational Operators</h2>
<p>Ordinarily, we define the arithmetic and relational operators as nonmember functions in order to allow conversions for either the left- or right-hand operand.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">assumes</span> <span class="n">that</span> <span class="n">both</span> <span class="n">objects</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">book</span>
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span>
</span></span><span class="line"><span class="cl"><span class="n">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Sales_data</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">;</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">data</span> <span class="n">members</span> <span class="n">from</span> <span class="n">lhs</span> <span class="n">into</span> <span class="n">sum</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span> <span class="o">//</span> <span class="n">add</span> <span class="n">rhs</span> <span class="n">into</span> <span class="n">sum</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Classes that define both an arithmetic operator and the related compound assignment ordinarily ought to implement the arithmetic operator by using the compound assignment.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="o">.</span><span class="n">units_sold</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">units_sold</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">lhs</span><span class="o">.</span><span class="n">revenue</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">revenue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="ne">bool</span> <span class="n">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Classes for which there is a logical meaning for equality normally should define operator==. Classes that define == make it easier for users to use the class with the library algorithms.</p>
<p>For Sales_data, there is no single logical definition of &lt;. Thus, it is better for this class not to define &lt; at all. If a single logical definition for &lt; exists, classes usually should define the &lt; operator. However, if the class also has ==, define &lt; only if the definitions of &lt; and == yield consistent results.</p>
<h2 id="assignment-operators">Assignment Operators</h2>
<p>In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type, a class can define additional assignment operators that allow other types as the right-hand operand. As one example, the library vector class defines a third assignment operator that takes a braced list of elements. We can add this operator to our StrVec class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class StrVec {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    StrVec &amp;operator=(std::initializer_list&lt;std::string&gt;);
</span></span><span class="line"><span class="cl">    // other members as in § 13.5 (p. 526)
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Assignment operators can be overloaded. Assignment operators, regardless of parameter type, must be defined as member functions.</p>
<h2 id="compound-assignment-operators">Compound-Assignment Operators</h2>
<p>Compound assignment operators are not required to be members. However, we prefer to define all assignments, including compound assignments, in the class. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">member</span> <span class="n">binary</span> <span class="n">operator</span><span class="p">:</span> <span class="n">left</span><span class="o">-</span><span class="n">hand</span> <span class="n">operand</span> <span class="n">is</span> <span class="n">bound</span> <span class="n">to</span> <span class="n">the</span> <span class="n">implicit</span> <span class="n">this</span> <span class="n">pointer</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">assumes</span> <span class="n">that</span> <span class="n">both</span> <span class="n">objects</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">book</span>
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="p">::</span><span class="n">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">units_sold</span> <span class="o">+=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">units_sold</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">revenue</span> <span class="o">+=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">revenue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Assignment operators must, and ordinarily compound-assignment operators should, be defined as members. These operators should return a reference to the left-hand operand.</p>
<h2 id="subscript-operator">Subscript Operator</h2>
<p>Classes that represent containers from which elements can be retrieved by position often define the subscript operator, operator[]. The subscript operator must be a member function. If a class has a subscript operator, it usually should define two versions: one that returns a plain reference and the other that is a const member and returns a reference to const.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">StrVec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="ow">in</span> <span class="err">§</span> <span class="mf">13.5</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span> <span class="mi">526</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span> <span class="o">//</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">first</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">array</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="increment-and-decrement-operators">Increment and Decrement Operators</h2>
<p>The increment (++) and decrement (&ndash;) operators are most often implemented for iterator classes. These operators let the class move between the elements of a sequence. Classes that define increment or decrement operators should define both the prefix and postfix versions. These operators usually should be defined as members.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class StrBlobPtr {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    // increment and decrement
</span></span><span class="line"><span class="cl">    StrBlobPtr&amp; operator++(); // prefix operators
</span></span><span class="line"><span class="cl">    StrBlobPtr&amp; operator--();
</span></span><span class="line"><span class="cl">    // other members as before
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>To be consistent with the built-in operators, the prefix operators should return a reference to the incremented or decremented object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// prefix: return a reference to the incremented/decremented object
</span></span><span class="line"><span class="cl">StrBlobPtr&amp; StrBlobPtr::operator++()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // if curr already points past the end of the container, can&#39;t increment it
</span></span><span class="line"><span class="cl">    check(curr, &#34;increment past end of StrBlobPtr&#34;);
</span></span><span class="line"><span class="cl">    ++curr; // advance the current state
</span></span><span class="line"><span class="cl">    return *this;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">StrBlobPtr&amp; StrBlobPtr::operator--()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // if curr is zero, decrementing it will yield an invalid subscript
</span></span><span class="line"><span class="cl">    --curr; // move the current state back one element
</span></span><span class="line"><span class="cl">    check(-1, &#34;decrement past begin of StrBlobPtr&#34;);
</span></span><span class="line"><span class="cl">    return *this;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>There is one problem with defining both the prefix and postfix operators: Normal overloading cannot distinguish between these operators. To solve this problem, the postfix versions take an extra (unused) parameter of type int.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class StrBlobPtr {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    // increment and decrement
</span></span><span class="line"><span class="cl">    StrBlobPtr operator++(int); // postfix operators
</span></span><span class="line"><span class="cl">    StrBlobPtr operator--(int);
</span></span><span class="line"><span class="cl">    // other members as before
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>To be consistent with the built-in operators, the postfix operators should return the old (unincremented or undecremented) value. That value is returned as a value, not a reference. The postfix versions have to remember the current state of the object before incrementing the object:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// postfix: increment/decrement the object but return the unchanged value
</span></span><span class="line"><span class="cl">StrBlobPtr StrBlobPtr::operator++(int)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // no check needed here; the call to prefix increment will do the check
</span></span><span class="line"><span class="cl">    StrBlobPtr ret = *this; // save the current value
</span></span><span class="line"><span class="cl">    ++*this; // advance one element; prefix ++ checks the increment
</span></span><span class="line"><span class="cl">    return ret; // return the saved state
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">StrBlobPtr StrBlobPtr::operator--(int)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // no check needed here; the call to prefix decrement will do the check
</span></span><span class="line"><span class="cl">    StrBlobPtr ret = *this; // save the current value
</span></span><span class="line"><span class="cl">    --*this; // move backward one element; prefix -- checks the decrement
</span></span><span class="line"><span class="cl">    return ret; // return the saved state
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>The int parameter is not used, so we do not give it a name. If we want to call the postfix version using a function call, then we must pass a value for the integer argument:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">StrBlobPtr p(a1); // p points to the vector inside a1
</span></span><span class="line"><span class="cl">p.operator++(0); // call postfix operator++
</span></span><span class="line"><span class="cl">p.operator++(); // call prefix operator++
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="member-access-operators">Member Access Operators</h2>
<p>The dereference (*) and arrow (-&gt;) operators are often used in classes that represent iterators and in smart pointer classes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">StrBlobPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s2">&#34;dereference past end&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span> <span class="o">//</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">is</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">to</span> <span class="n">which</span> <span class="n">this</span> <span class="n">object</span> <span class="n">points</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">*</span> <span class="n">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="n">delegate</span> <span class="n">the</span> <span class="n">real</span> <span class="n">work</span> <span class="n">to</span> <span class="n">the</span> <span class="n">dereference</span> <span class="n">operator</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">operator</span><span class="o">*</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Operator arrow must be a member. The dereference operator is not required to be a member but usually should be a member as well.
The overloaded arrow operator  must return either a pointer to a class type or an object of a class type that defines its own operator arrow.</p>
<h2 id="function-call-operator">Function-Call Operator</h2>
<p>Classes that overload the call operator allow objects of its type to be used as if they were a function. Because such classes can also store state, they can be more flexible than ordinary functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">absInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">operator</span><span class="p">()(</span><span class="ne">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="err">?</span> <span class="o">-</span><span class="n">val</span> <span class="p">:</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We use the call operator by applying an argument list to an absInt object in a way that looks like a function call. Even though absObj is an object, not a function, we can “call” this object. Calling an object runs its overloaded call operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = -42;
</span></span><span class="line"><span class="cl">absInt absObj; // object that has a function-call operator
</span></span><span class="line"><span class="cl">int ui = absObj(i); // passes i to absObj.operator()
</span></span></code></pre></td></tr></table>
</div>
</div><p>The function-call operator must be a member function. A class may define multiple versions of the call operator, each of which must differ as to the number or types of their parameters. Objects of classes that define the call operator are referred to as <strong>function objects</strong>. Such objects “act like functions” because we can call them.</p>
<p>As an example, we’ll define a class that prints a string argument.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">PrintString</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="n">char</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="p">):</span> <span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">sep</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span> <span class="o">//</span> <span class="n">stream</span> <span class="n">on</span> <span class="n">which</span> <span class="n">to</span> <span class="n">write</span>
</span></span><span class="line"><span class="cl">    <span class="n">char</span> <span class="n">sep</span><span class="p">;</span> <span class="o">//</span> <span class="n">character</span> <span class="n">to</span> <span class="nb">print</span> <span class="n">after</span> <span class="n">each</span> <span class="n">output</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we define PrintString objects, we can use the defaults or supply our own values for the separator or output stream:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">PrintString printer; // uses the defaults; prints to cout
</span></span><span class="line"><span class="cl">printer(s); // prints s followed by a space on cout
</span></span><span class="line"><span class="cl">PrintString errors(cerr, &#39;\n&#39;);
</span></span><span class="line"><span class="cl">errors(s); // prints s followed by a newline on cerr
</span></span></code></pre></td></tr></table>
</div>
</div><p>Function objects are most often used as arguments to the generic algorithms. For example, we can use the library for_each algorithm and our PrintString class to print the contents of a container:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for_each(vs.begin(), vs.end(), PrintString(cerr, &#39;\n&#39;));
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="lambdas-are-function-objects">Lambdas Are Function Objects</h2>
<p>In the previous section, we used a PrintString object as an argument in a call to for_each. This usage is similar to the programs that used lambda expressions.  When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class. The classes generated from a lambda contain an overloaded function-call operator. For example, the lambda that we passed as the last argument to stable_sort:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">sort</span> <span class="n">words</span> <span class="n">by</span> <span class="n">size</span><span class="p">,</span> <span class="n">but</span> <span class="n">maintain</span> <span class="n">alphabetical</span> <span class="n">order</span> <span class="k">for</span> <span class="n">words</span> <span class="n">of</span> <span class="n">the</span> <span class="n">same</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl"><span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">            <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">();});</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>acts like an unnamed object of a class that would look something like</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">ShorterString</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By default, lambdas may not change their captured variables. As a result, by default, the function-call operator in a class generated from a lambda is a const member function. If the lambda is declared as mutable, then the call operator is not const. We can rewrite the call to stable_sort to use this class instead of the lambda expression:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">stable_sort(words.begin(), words.end(), ShorterString());
</span></span></code></pre></td></tr></table>
</div>
</div><p>As we’ve seen, when a lambda captures a variable by reference, the compiler is permitted to use the reference directly without storing that reference as a data member in the generated class. In contrast, variables that are captured by value are copied into the lambda. As a result, classes generated from lambdas that capture variables by value have data members corresponding to each such variable. As an example, the lambda that we used to find the first string whose length was greater than or equal to a given bound:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">get</span> <span class="n">an</span> <span class="n">iterator</span> <span class="n">to</span> <span class="n">the</span> <span class="n">first</span> <span class="n">element</span> <span class="n">whose</span> <span class="n">size</span><span class="p">()</span> <span class="n">is</span> <span class="o">&gt;=</span> <span class="n">sz</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>would generate a class that looks something like</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SizeComp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SizeComp</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">):</span> <span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="o">//</span> <span class="n">parameter</span> <span class="k">for</span> <span class="n">each</span> <span class="n">captured</span> <span class="n">variable</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">call</span> <span class="n">operator</span> <span class="n">with</span> <span class="n">the</span> <span class="n">same</span> <span class="k">return</span> <span class="n">type</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="ow">and</span> <span class="n">body</span> <span class="n">as</span> <span class="n">the</span> <span class="n">lambda</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">sz</span><span class="p">;</span> <span class="o">//</span> <span class="n">a</span> <span class="n">data</span> <span class="n">member</span> <span class="k">for</span> <span class="n">each</span> <span class="n">variable</span> <span class="n">captured</span> <span class="n">by</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike our ShorterString class, this class has a data member and a constructor to initialize that member. This synthesized class does not have a default constructor; to use this class, we must pass an argument:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// get an iterator to the first element whose size() is &gt;= sz
</span></span><span class="line"><span class="cl">auto wc = find_if(words.begin(), words.end(), SizeComp(sz));
</span></span></code></pre></td></tr></table>
</div>
</div><p>Classes generated from a lambda expression have a deleted default constructor, deleted assignment operators, and a default destructor. Whether the class has a defaulted or deleted copy/move constructor depends in the usual ways on the types of the captured data members.</p>
<h2 id="library-defined-function-objects">Library-Defined Function Objects</h2>
<p>The standard library defines a set of classes that represent the arithmetic, relational, and logical operators. Each class defines a call operator that applies the named operation. These classes are templates to which we supply a single type. That type specifies the parameter type for the call operator. For example, plus<string> applies the string addition operator to string objects; for plus<int> the operands are ints; and so on.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plus&lt;int&gt; intAdd; // function object that can add two int values
</span></span><span class="line"><span class="cl">negate&lt;int&gt; intNegate; // function object that can negate an int value
</span></span><span class="line"><span class="cl">// uses intAdd::operator(int, int) to add 10 and 20
</span></span><span class="line"><span class="cl">int sum = intAdd(10, 20); // equivalent to sum = 30
</span></span><span class="line"><span class="cl">sum = intNegate(intAdd(10, 20)); // equivalent to sum = 30
</span></span><span class="line"><span class="cl">// uses intNegate::operator(int) to generate -10 as the second parameter
</span></span><span class="line"><span class="cl">// to intAdd::operator(int, int)
</span></span><span class="line"><span class="cl">sum = intAdd(10, intNegate(10)); // sum = 0
</span></span></code></pre></td></tr></table>
</div>
</div><p>These types are defined in the functional header.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Arithmetic      Relational          Logical
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">plus&lt;T&gt;         equal_to&lt;T&gt;         logical_and&lt;T&gt;
</span></span><span class="line"><span class="cl">minus&lt;T&gt;        not_equal_to&lt;T&gt;     logical_or&lt;T&gt;
</span></span><span class="line"><span class="cl">multiplies&lt;T&gt;   greater&lt;T&gt;          logical_not&lt;T&gt;
</span></span><span class="line"><span class="cl">divides&lt;T&gt;      greater_equal&lt;T&gt;
</span></span><span class="line"><span class="cl">modulus&lt;T&gt;      less&lt;T&gt;
</span></span><span class="line"><span class="cl">negate&lt;T&gt;       less_equal&lt;T&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>The function-object classes that represent operators are often used to override the default operator used by an algorithm. As we’ve seen, by default, the sorting algorithms use operator&lt;, which ordinarily sorts the sequence into ascending order. To sort into descending order, we can pass an object of type greater.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// passes a temporary function object that applies the &lt; operator to two strings
</span></span><span class="line"><span class="cl">sort(svec.begin(), svec.end(), greater&lt;string&gt;());
</span></span></code></pre></td></tr></table>
</div>
</div><p>One important aspect of these library function objects is that the library guarantees that they will work for pointers.  Recall that comparing two unrelated pointers is undefined. However, we might want to sort a vector of pointers based on their addresses in memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;string *&gt; nameTable; // vector of pointers
</span></span><span class="line"><span class="cl">// error: the pointers in nameTable are unrelated, so &lt; is undefined
</span></span><span class="line"><span class="cl">sort(nameTable.begin(), nameTable.end(),
</span></span><span class="line"><span class="cl">    [](string *a, string *b) { return a &lt; b; });
</span></span><span class="line"><span class="cl">// ok: library guarantees that less on pointer types is well defined
</span></span><span class="line"><span class="cl">sort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;());
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="callable-objects-and-function">Callable Objects and function</h2>
<p>C++ has several kinds of callable objects: functions and pointers to functions, lambdas, objects created by <code>bind</code>, and classes that overload the function-call operator. Sometimes we want to treat several callable objects that share a call signature as if they had the same type. For example, consider the following different types of callable objects:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ordinary function
</span></span><span class="line"><span class="cl">int add(int i, int j) { return i + j; }
</span></span><span class="line"><span class="cl">// lambda, which generates an unnamed function-object class
</span></span><span class="line"><span class="cl">auto mod = [](int i, int j) { return i % j; };
</span></span><span class="line"><span class="cl">// function-object class
</span></span><span class="line"><span class="cl">struct div 
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    int operator()(int denominator, int divisor) 
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">        return denominator / divisor;
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Even though each has a distinct type, they all share the same call signature:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int(int, int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>We might want to use these callables to build a simple desk calculator. To do so, we’d want to define a function table to store “pointers” to these callables. In C++, function tables are easy to implement using a map.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// maps an operator to a pointer to a function taking two ints and returning an int
</span></span><span class="line"><span class="cl">map&lt;string, int(*)(int,int)&gt; binops;
</span></span></code></pre></td></tr></table>
</div>
</div><p>We could put a pointer to add into binops as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ok: add is a pointer to function of the appropriate type
</span></span><span class="line"><span class="cl">binops.insert({&#34;+&#34;, add});
</span></span></code></pre></td></tr></table>
</div>
</div><p>However, we can’t store mod or div in binops:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">binops.insert({&#34;%&#34;, mod}); // error: mod is not a pointer to function
</span></span></code></pre></td></tr></table>
</div>
</div><p>The problem is that mod is a lambda, and each lambda has its own class type. That type does not match the type of the values stored in binops. We can solve this problem using a new library type named function that is defined in the functional header. <code>function</code> is a template. We can declare a function type that can represent callable objects that return an int result and have two int parameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">function&lt;int(int, int)&gt; f1 = add; // function pointer
</span></span><span class="line"><span class="cl">function&lt;int(int, int)&gt; f2 = div(); // object of a function-object class
</span></span><span class="line"><span class="cl">function&lt;int(int, int)&gt; f3 = [](int i, int j) // lambda
</span></span><span class="line"><span class="cl">{ return i * j; };
</span></span><span class="line"><span class="cl">cout &lt;&lt; f1(4,2) &lt;&lt; endl; // prints 6
</span></span><span class="line"><span class="cl">cout &lt;&lt; f2(4,2) &lt;&lt; endl; // prints 2
</span></span><span class="line"><span class="cl">cout &lt;&lt; f3(4,2) &lt;&lt; endl; // prints 8
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can now redefine our map using this function type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">map&lt;string, function&lt;int(int, int)&gt;&gt; binops;
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can add each of our callable objects, be they function pointers, lambdas, or function objects, to this map:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">map&lt;string, function&lt;int(int, int)&gt;&gt; binops = {
</span></span><span class="line"><span class="cl">{&#34;+&#34;, add}, // function pointer
</span></span><span class="line"><span class="cl">{&#34;-&#34;, std::minus&lt;int&gt;()}, // library function object
</span></span><span class="line"><span class="cl">{&#34;/&#34;, div()}, // user-defined function object
</span></span><span class="line"><span class="cl">{&#34;*&#34;, [](int i, int j) { return i * j; }}, // unnamed lambda
</span></span><span class="line"><span class="cl">{&#34;%&#34;, mod} }; // named lambda object
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we index binops, we get a reference to an object of type function. The function type overloads the call operator. That call operator takes its own arguments and passes them along to its stored callable object:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">binops[&#34;+&#34;](10, 5); // calls add(10, 5)
</span></span><span class="line"><span class="cl">binops[&#34;-&#34;](10, 5); // uses the call operator of the minus&lt;int&gt; object
</span></span><span class="line"><span class="cl">binops[&#34;/&#34;](10, 5); // uses the call operator of the div object
</span></span><span class="line"><span class="cl">binops[&#34;*&#34;](10, 5); // calls the lambda function object
</span></span><span class="line"><span class="cl">binops[&#34;%&#34;](10, 5); // calls the lambda function object
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>function</code> class in the new library is not related to classes named <code>unary_function</code> and <code>binary_function</code> that were part of earlier versions of the library. These classes have been deprecated by the more general <code>bind</code> function.</p>
<h2 id="conversion-operators">Conversion Operators</h2>
<p>Converting constructors and conversion operators define class-type conversions. Such conversions are also referred to as user-defined conversions. A <strong>conversion operator</strong> is a special kind of member function that converts a value of a class type to a value of some other type. A conversion function typically has the general form</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">operator</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>where type represents a type. Conversion operators can be defined for any type (other than void) that can be a function return type. Conversions to an array or a function type are not permitted.  Conversions to pointer types—both data and function pointers—and to reference types are allowed.</p>
<p>Conversion operators have no explicitly stated return type and no parameters, and they must be defined as member functions. Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually should be defined as const members.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SmallInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">SmallInt</span><span class="p">(</span><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">throw</span> <span class="n">std</span><span class="p">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s2">&#34;Bad SmallInt value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="ne">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The conversion operator converts SmallInt objects to int:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SmallInt si;
</span></span><span class="line"><span class="cl">si = 4; // implicitly converts 4 to SmallInt then calls SmallInt::operator=
</span></span><span class="line"><span class="cl">si + 3; // implicitly converts si to int followed by integer addition
</span></span></code></pre></td></tr></table>
</div>
</div><p>Although the compiler will apply only one user-defined conversion at a time, an implicit user-defined conversion can be preceded or followed by a standard (built-in) conversion. As a result, we can pass any arithmetic type to the SmallInt constructor.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">double</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">converted</span> <span class="n">to</span> <span class="ne">int</span> <span class="n">using</span> <span class="n">the</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">conversion</span>
</span></span><span class="line"><span class="cl"><span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">the</span> <span class="n">SmallInt</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">SmallInt</span> <span class="n">conversion</span> <span class="n">operator</span> <span class="n">converts</span> <span class="n">si</span> <span class="n">to</span> <span class="ne">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">si</span> <span class="o">+</span> <span class="mf">3.14</span><span class="p">;</span> <span class="o">//</span> <span class="n">that</span> <span class="ne">int</span> <span class="n">is</span> <span class="n">converted</span> <span class="n">to</span> <span class="n">double</span> <span class="n">using</span> <span class="n">the</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">conversion</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because conversion operators are implicitly applied, there is no way to pass arguments to these functions. Hence, conversion operators may not be defined to take parameters. Although a conversion function does not specify a return type, each conversion function must return a value of its corresponding type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SmallInt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">operator</span> <span class="ne">int</span><span class="p">(</span><span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">nonmember</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SmallInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">operator</span> <span class="ne">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="k">return</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="ne">int</span><span class="p">(</span><span class="ne">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">parameter</span> <span class="n">list</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="ne">int</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="mi">42</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">pointer</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Conversion operators are misleading when there is no obvious single mapping between the class type and the conversion type. For example, consider a class that represents a Date. We might think it would be a good idea to provide a conversion from Date to int. Alternatively, the conversion operator might return an int representing the number of days that have elapsed since some epoch point, such as January 1, 1970. The problem is that there is no single one-to-one mapping between an object of type Date and a value of type int. In such cases, it is better not to define the conversion operator. Instead, the class ought to define one or more ordinary members to extract the information in these various forms.</p>
<h2 id="explicit-conversion-operators">explicit Conversion Operators</h2>
<p>In practice, classes rarely provide conversion operators. It is not uncommon for classes to define conversions to bool.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 42;
</span></span><span class="line"><span class="cl">cin &lt;&lt; i; // this code would be legal if the conversion to bool were not explicit!
</span></span></code></pre></td></tr></table>
</div>
</div><p>This program attempts to use the output operator on an input stream. There is no &laquo; defined for istream, so the code is almost surely in error. However, this code could use the bool conversion operator to convert cin to bool. The resulting bool value would then be promoted to int and used as the left-hand operand to the built-in version of the left-shift operator. To prevent such problems, the new standard introduced explicit conversion operators:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SmallInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">the</span> <span class="n">compiler</span> <span class="n">won</span><span class="s1">&#39;t automatically apply this conversion</span>
</span></span><span class="line"><span class="cl">    <span class="n">explicit</span> <span class="n">operator</span> <span class="ne">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the conversion operator is explicit, we can still do the conversion. However, with one exception, we must do so explicitly through a cast.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">the</span> <span class="n">SmallInt</span> <span class="n">constructor</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">explicit</span>
</span></span><span class="line"><span class="cl"><span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">implicit</span> <span class="n">is</span> <span class="n">conversion</span> <span class="n">required</span><span class="p">,</span> <span class="n">but</span> <span class="n">operator</span> <span class="ne">int</span> <span class="n">is</span> <span class="n">explicit</span>
</span></span><span class="line"><span class="cl"><span class="n">static_cast</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">explicitly</span> <span class="n">request</span> <span class="n">the</span> <span class="n">conversion</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The exception is that the compiler will apply an explicit conversion to an expression used as a condition. That is, an explicit conversion will be used implicitly to convert an expression used as</p>
<ul>
<li>The condition of an if, while, or do statement</li>
<li>The condition expression in a for statement header</li>
<li>An operand to the logical  NOT (!),  OR (||), or  AND (&amp;&amp;) operators</li>
<li>The condition expression in a conditional (?:) operator</li>
</ul>
<h2 id="conversion-to--bool">Conversion to  bool</h2>
<p>Under the new standard, the IO library defines an explicit conversion to bool. Whenever we use a stream object in a condition, we use the operator bool that is defined for the IO types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while (std::cin &gt;&gt; value)
</span></span></code></pre></td></tr></table>
</div>
</div><p>The condition in the while executes the input operator, which reads into value and returns cin. To evaluate the condition, cin is implicitly converted by the istream operator bool conversion function. That function returns true if the condition state of cin is good, and false otherwise. Conversion to bool is usually intended for use in conditions. As a result, operator bool ordinarily should be defined as explicit.</p>
<h2 id="avoiding-ambiguous-conversions">Avoiding Ambiguous Conversions</h2>
<p>If a class has one or more conversions, it is important to ensure that there is only one way to convert from the class type to the target type. If there is more than one way to perform a conversion, it will be hard to write unambiguous code. There are two ways that multiple conversion paths can occur. The first happens when two classes provide mutual conversions. For example, mutual conversions exist when a class A defines a converting constructor that takes an object of class B and B itself defines a conversion operator to type A. The second way to generate multiple conversion paths is to define multiple conversions from or to types that are themselves related by conversions. The most obvious instance is the built-in arithmetic types. A given class ordinarily ought to define at most one conversion to or from an arithmetic type. So, ordinarily it is a bad idea to define classes with mutual conversions or to define conversions to or from two arithmetic types.</p>
<p>In the following example, we’ve defined two ways to obtain an A from a B: either by using B’s conversion operator or by using the A constructor that takes a B:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">usually</span> <span class="n">a</span> <span class="n">bad</span> <span class="n">idea</span> <span class="n">to</span> <span class="n">have</span> <span class="n">mutual</span> <span class="n">conversions</span> <span class="n">between</span> <span class="n">two</span> <span class="k">class</span> <span class="n">types</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">converts</span> <span class="n">a</span> <span class="n">B</span> <span class="n">to</span> <span class="n">an</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="n">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">also</span> <span class="n">converts</span> <span class="n">a</span> <span class="n">B</span> <span class="n">to</span> <span class="n">an</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span> <span class="n">ambiguous</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">B</span><span class="p">::</span><span class="n">operator</span> <span class="n">A</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="o">//</span> <span class="ow">or</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">::</span><span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because there are two ways to obtain an A from a B, the compiler doesn’t know which conversion to run; the call to f is ambiguous. If we want to make this call, we have to explicitly call the conversion operator or the constructor:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">operator</span> <span class="n">A</span><span class="p">());</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">use</span> <span class="sa">B</span><span class="s1">&#39;s conversion operator</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">use</span> <span class="n">A</span><span class="s1">&#39;s constructor</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The following class has converting constructors from two different arithmetic types, and conversion operators to two different arithmetic types:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">A</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="ne">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="o">//</span> <span class="n">usually</span> <span class="n">a</span> <span class="n">bad</span> <span class="n">idea</span> <span class="n">to</span> <span class="n">have</span> <span class="n">two</span>
</span></span><span class="line"><span class="cl">    <span class="n">A</span><span class="p">(</span><span class="n">double</span><span class="p">);</span> <span class="o">//</span> <span class="n">conversions</span> <span class="n">from</span> <span class="n">arithmetic</span> <span class="n">types</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="ne">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">usually</span> <span class="n">a</span> <span class="n">bad</span> <span class="n">idea</span> <span class="n">to</span> <span class="n">have</span> <span class="n">two</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="n">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">conversions</span> <span class="n">to</span> <span class="n">arithmetic</span> <span class="n">types</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">long</span> <span class="n">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span> <span class="n">error</span> <span class="n">ambiguous</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">::</span><span class="n">operator</span> <span class="ne">int</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="o">//</span> <span class="ow">or</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">::</span><span class="n">operator</span> <span class="n">double</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">long</span> <span class="n">lg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a2</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span> <span class="n">ambiguous</span><span class="p">:</span> <span class="n">A</span><span class="p">::</span><span class="n">A</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">A</span><span class="p">::</span><span class="n">A</span><span class="p">(</span><span class="n">double</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the call to f2, neither conversion is an exact match to long double. However, the call is ambiguous. We encounter the same problem when we try to initialize a2 from a long. Neither constructor is an exact match for long. The call to f2, and the initialization of a2, are ambiguous because the standard conversions that were needed had the same rank.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">short s = 42;
</span></span><span class="line"><span class="cl">// promoting short to int is better than converting short to double
</span></span><span class="line"><span class="cl">A a3(s); // uses A::A(int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>When two user-defined conversions are used, the rank of the standard conversion, if any, preceding or following the conversion function is used to select the best match.</p>
<h2 id="overloaded-functions-and-converting-constructors">Overloaded Functions and Converting Constructors</h2>
<p>Choosing among multiple conversions is further complicated when we call an overloaded function. If two or more conversions provide a viable match, then the conversions are considered equally good.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">C</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">C</span><span class="p">(</span><span class="ne">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">D</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">D</span><span class="p">(</span><span class="ne">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">manip</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span> <span class="n">ambiguous</span><span class="p">:</span> <span class="n">manip</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="ow">or</span> <span class="n">manip</span><span class="p">(</span><span class="n">D</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here both C and D have constructors that take an int. Hence, the call is ambiguous. The caller can disambiguate by explicitly constructing the correct type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">manip</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">calls</span> <span class="n">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Needing to use a constructor or a cast to convert an argument in a call to an overloaded function frequently is a sign of bad design.</p>
<h2 id="overloaded-functions-and-user-defined-conversion">Overloaded Functions and User-Defined Conversion</h2>
<p>In a call to an overloaded function, if two (or more) user-defined conversions provide a viable match, the conversions are considered equally good. The rank of any standard conversions that might or might not be required is not considered.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">E</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">E</span><span class="p">(</span><span class="n">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">error</span> <span class="n">ambiguous</span><span class="p">:</span> <span class="n">two</span> <span class="n">different</span> <span class="n">user</span><span class="o">-</span><span class="n">defined</span> <span class="n">conversions</span> <span class="n">could</span> <span class="n">be</span> <span class="n">used</span>
</span></span><span class="line"><span class="cl"><span class="n">manip2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="o">//</span> <span class="n">manip2</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="ow">or</span> <span class="n">manip2</span><span class="p">(</span><span class="n">E</span><span class="p">(</span><span class="n">double</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this case, C has a conversion from int and E has a conversion from double. For the call manip2(10), both manip2 functions are viable. Because calls to the overloaded functions require  different user-defined conversions from one another, this call is ambiguous. In particular, even though one of the calls requires a standard conversion and the other is an exact match, the compiler will still flag this call as an error.</p>
<h2 id="function-matching-and-overloaded-operators">Function Matching and Overloaded Operators</h2>
<p>Overloaded operators are overloaded functions. Normal function matching is used to determine which operator—built-in or overloaded—to apply to a given expression. However, when an operator function is used in an expression, the set of candidate functions is broader than when we call a function using the call operator.  If a has a class type, the expression a sym b might be</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a.operatorsym (b); // a has operatorsym as a member function
</span></span><span class="line"><span class="cl">operatorsym(a, b); // operatorsym is an ordinary function
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a call is through an object of a class type (or through a reference or pointer to such an object), then only the member functions of that class are considered. When we use an overloaded operator in an expression, there is nothing to indicate whether we’re using a member or nonmember function. Therefore, the set of candidate functions for an operator used in an expression can contain both nonmember and member functions. As an example, we’ll define an addition operator for our SmallInt class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">SmallInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">friend</span>
</span></span><span class="line"><span class="cl">    <span class="n">SmallInt</span> <span class="n">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">SmallInt</span><span class="p">(</span><span class="ne">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span> <span class="o">//</span> <span class="n">conversion</span> <span class="n">from</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl">    <span class="n">operator</span> <span class="ne">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span> <span class="o">//</span> <span class="n">conversion</span> <span class="n">to</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can use this class to add two SmallInts, but we will run into ambiguity problems if we attempt to perform mixed-mode arithmetic:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">SmallInt</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">SmallInt</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">overloaded</span> <span class="n">operator</span><span class="o">+</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">ambiguous</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first addition uses the overloaded version of + that takes two SmallInt values. The second addition is ambiguous, because we can convert 0 to a SmallInt and use the SmallInt version of +, or convert s3 to int and use the built-in addition operator on ints. Providing both conversion functions to an arithmetic type and overloaded operators for the same class type may lead to ambiguities between the overloaded operators and the built-in operators.</p>
<h1 id="object-oriented-programming">Object-Oriented Programming</h1>
<p>The key ideas in object-oriented programming are data abstraction, inheritance, and dynamic binding. Using data abstraction, we can define classes that separate interface from implementation. Through inheritance, we can define classes that model the relationships among similar types. Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.</p>
<h2 id="inheritance">Inheritance</h2>
<p>Classes related by <strong>inheritance</strong> form a hierarchy. Typically there is a <strong>base class</strong> at the root of the hierarchy, from which the other classes inherit, directly or indirectly. These inheriting classes are known as <strong>derived classes</strong>. The base class defines those members that are common to the types in the hierarchy. Each derived class defines those members that are specific to the derived class itself.</p>
<p>To model our different kinds of pricing strategies, we’ll define a class named Quote, which will be the base class of our hierarchy. A Quote object will represent undiscounted books. From Quote we will inherit a second class, named Bulk_quote, to represent books that can be sold with a quantity discount. In C++, a base class distinguishes functions that are type dependent from those that it expects its derived classes to inherit without change. The base class defines as <strong>virtual</strong> those functions it expects its derived classes to define for themselves.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">isbn</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">derivation</span> <span class="n">list</span><span class="p">,</span> <span class="n">Bulk_quote</span> <span class="n">inherits</span> <span class="n">from</span> <span class="n">Quote</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Bulk_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because Bulk_quote uses public in its derivation list, we can use objects of type Bulk_quote  as if they were Quote objects. A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself. A derived class may include the virtual keyword on these functions but is not required to do so. The new standard lets a derived class explicitly note that it intends a member function to override a virtual that it inherits. It does so by specifying <code>override</code> after its parameter list.</p>
<h2 id="dynamic-binding">Dynamic Binding</h2>
<p>Through dynamic binding, we can use the same code to process objects of either type Quote or Bulk_quote interchangeably.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">double</span> <span class="n">print_total</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Quote</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">object</span> <span class="n">bound</span> <span class="n">to</span> <span class="n">the</span> <span class="n">item</span> <span class="n">parameter</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">calls</span> <span class="n">either</span> <span class="n">Quote</span><span class="p">::</span><span class="n">net_price</span> <span class="ow">or</span> <span class="n">Bulk_quote</span><span class="p">::</span><span class="n">net_price</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">net_price</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;ISBN: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">Quote</span><span class="p">::</span><span class="n">isbn</span>
</span></span><span class="line"><span class="cl">    <span class="o">&lt;&lt;</span> <span class="s2">&#34; # sold: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; total due: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because the parameter is a reference to Quote, we can call this function on either a Quote object or a Bulk_quote object. Because net_price is a virtual function, and because print_total calls net_price through a reference, the version of net_price that is run will depend on the type of the object that we pass to print_total:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// basic has type Quote; bulk has type Bulk_quote
</span></span><span class="line"><span class="cl">print_total(cout, basic, 20); // calls Quote version of net_price
</span></span><span class="line"><span class="cl">print_total(cout, bulk, 20); // calls Bulk_quote version of net_price
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because the decision as to which version to run depends on the type of the argument, that decision can’t be made until run time. Therefore, dynamic binding is sometimes known as <strong>run-time binding</strong>. In C++, dynamic binding happens when a virtual function is called through a reference (or a pointer) to a base class.</p>
<h2 id="defining-a-base-class">Defining a Base Class</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">book</span><span class="p">,</span> <span class="n">double</span> <span class="n">sales_price</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">bookNo</span><span class="p">(</span><span class="n">book</span><span class="p">),</span> <span class="n">price</span><span class="p">(</span><span class="n">sales_price</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">isbn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bookNo</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">total</span> <span class="n">sales</span> <span class="n">price</span> <span class="k">for</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">number</span> <span class="n">of</span> <span class="n">items</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">derived</span> <span class="n">classes</span> <span class="n">will</span> <span class="n">override</span> <span class="ow">and</span> <span class="n">apply</span> <span class="n">different</span> <span class="n">discount</span> <span class="n">algorithms</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="o">~</span><span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">dynamic</span> <span class="n">binding</span> <span class="k">for</span> <span class="n">the</span> <span class="n">destructor</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span> <span class="o">//</span> <span class="n">ISBN</span> <span class="n">number</span> <span class="n">of</span> <span class="n">this</span> <span class="n">item</span>
</span></span><span class="line"><span class="cl"><span class="n">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="o">//</span> <span class="n">normal</span><span class="p">,</span> <span class="n">undiscounted</span> <span class="n">price</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Base classes ordinarily should define a <strong>virtual destructor</strong>. Virtual destructors are needed even if they do no work.</p>
<p>In C++, a base class must distinguish the functions it expects its derived classes to override from those that it expects its derived classes to inherit without change. The base class defines as virtual those functions it expects its derived classes to override. When we call a virtual function  through a pointer or reference , the call will be dynamically bound. Any nonstatic member function, other than a constructor, may be virtual. The virtual keyword appears only on the declaration inside the class and may not be used on a function definition that appears outside the class body.</p>
<p>A derived class inherits the members defined in its base class. Like any other code that uses the base class, a derived class may access the <code>public</code> members of its base class but may not access the <code>private</code> members. However, sometimes a base class has members that it wants to let its derived classes use while still prohibiting access to those same members by other users. We specify such members after a <code>protected</code> access specifier.</p>
<h2 id="defining-a-derived-class">Defining a Derived Class</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Bulk_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Quote</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Bulk_quote</span> <span class="n">inherits</span> <span class="n">from</span> <span class="n">Quote</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">,</span> <span class="n">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span><span class="n">overrides</span> <span class="n">the</span> <span class="n">base</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">order</span> <span class="n">to</span> <span class="n">implement</span> <span class="n">the</span> <span class="n">bulk</span> <span class="n">purchase</span> <span class="n">discount</span> <span class="n">policy</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">min_qty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">minimum</span> <span class="n">purchase</span> <span class="k">for</span> <span class="n">the</span> <span class="n">discount</span> <span class="n">to</span> <span class="n">apply</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">discount</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="o">//</span> <span class="n">fractional</span> <span class="n">discount</span> <span class="n">to</span> <span class="n">apply</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the derivation is public, the public members of the base class become part of the interface of the derived class as well.</p>
<p>If a derived class does not override a virtual from its base, then, like any other member, the derived class inherits the version defined in its base class. A derived class may include the virtual keyword on the functions it overrides, but it is not required to do so. The new standard lets a derived class explicitly note that it intends a member function to override a virtual that it inherits. It does so by specifying <code>override</code> after the parameter list, or after the const or reference qualifier(s) if the member is a const or reference function.</p>
<p>A derived object contains multiple parts: a subobject containing the (nonstatic) members defined in the derived class itself, plus subobjects corresponding to each base class from which the derived class inherits. Thus, a Bulk_quote object will contain four data elements: the bookNo and price data members that it inherits from Quote, and the min_qty and discount members, which are defined by Bulk_quote. The base and derived parts of an object are not guaranteed to be stored contiguously. Because a derived object contains subparts corresponding to its base class(es), we can use an object of a derived type as if it were an object of its base type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Quote item; // object of base type
</span></span><span class="line"><span class="cl">Bulk_quote bulk; // object of derived type
</span></span><span class="line"><span class="cl">Quote *p = &amp;item; // p points to a Quote object
</span></span><span class="line"><span class="cl">p = &amp;bulk; // p points to the Quote part of bulk
</span></span><span class="line"><span class="cl">Quote &amp;r = bulk; // r bound to the Quote part of bulk
</span></span></code></pre></td></tr></table>
</div>
</div><p>This conversion is often referred to as the derived-to-base conversion. The fact that the derived-to-base conversion is implicit means that we can use an object of derived type or a reference to a derived type when a reference to the base type is required. Similarly, we can use a pointer to a derived type where a pointer to the base type is required.</p>
<h2 id="derived-class-constructors">Derived-Class Constructors</h2>
<p>Although a derived object contains members that it inherits from its base, it cannot directly initialize those members. Like any other code that creates an object of the base-class type, a derived class must use a base-class constructor to initialize its base-class part. The base-class part of an object is initialized, along with the data members of the derived class, during the initialization phase of the constructor. Analogously to how we initialize a member, a derived-class constructor uses its constructor initializer list to pass arguments to a base-class constructor. For example, the Bulk_quote constructor with four parameters:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="n">double</span> <span class="n">p</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="n">double</span> <span class="n">disc</span><span class="p">)</span> <span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">min_qty</span><span class="p">(</span><span class="n">qty</span><span class="p">),</span> <span class="n">discount</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As with a data member, unless we say otherwise, the base part of a derived object is default initialized. To use a different base-class constructor, we provide a constructor initializer using the name of the base class. The base class is initialized first, and then the members of the derived class are initialized in the order in which they are declared in the class.</p>
<p>A derived class may access the public and protected members of its base class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="k">if</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">number</span> <span class="n">of</span> <span class="n">items</span> <span class="n">are</span> <span class="n">purchased</span><span class="p">,</span> <span class="n">use</span> <span class="n">the</span> <span class="n">discounted</span> <span class="n">price</span>
</span></span><span class="line"><span class="cl"><span class="n">double</span> <span class="n">Bulk_quote</span><span class="p">::</span><span class="n">net_price</span><span class="p">(</span><span class="n">size_t</span> <span class="n">cnt</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">min_qty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cnt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">cnt</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>It is essential to understand that each class defines its own interface. Interactions with an object of a class-type should use the interface of that class, even if that object is the base-class part of a derived object. As a result, derived-class constructors may not directly initialize the members of its base class. The constructor body of a derived constructor can assign values to its public or protected base-class members. Although it can assign to those members, it generally  should not do so. Like any other user of the base class, a derived class should respect the interface of its base class by using a constructor to initialize its inherited members.</p>
<h2 id="inheritance-and-static-members">Inheritance and static Members</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">void</span> <span class="n">statmem</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Derived</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>static members obey normal access control. If the member is private in the base class, then derived classes have no access to it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">Derived</span><span class="p">::</span><span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">derived_obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">::</span><span class="n">statmem</span><span class="p">();</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">Base</span> <span class="n">defines</span> <span class="n">statmem</span>
</span></span><span class="line"><span class="cl">    <span class="n">Derived</span><span class="p">::</span><span class="n">statmem</span><span class="p">();</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">Derived</span> <span class="n">inherits</span> <span class="n">statmem</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">derived</span> <span class="n">objects</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">access</span> <span class="k">static</span> <span class="n">from</span> <span class="n">base</span>
</span></span><span class="line"><span class="cl">    <span class="n">derived_obj</span><span class="o">.</span><span class="n">statmem</span><span class="p">();</span> <span class="o">//</span> <span class="n">accessed</span> <span class="n">through</span> <span class="n">a</span> <span class="n">Derived</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">    <span class="n">statmem</span><span class="p">();</span> <span class="o">//</span> <span class="n">accessed</span> <span class="n">through</span> <span class="n">this</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="classes-used-as-a-base-class">Classes Used as a Base Class</h2>
<p>A class must be defined, not just declared, before we can use it as a base class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Quote; // declared but not defined
</span></span><span class="line"><span class="cl">// error: Quote must be defined
</span></span><span class="line"><span class="cl">class Bulk_quote : public Quote { ... };
</span></span></code></pre></td></tr></table>
</div>
</div><p>A base class can itself be a derived class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Base { /* ... */ } ;
</span></span><span class="line"><span class="cl">class D1: public Base { /* ... */ };
</span></span><span class="line"><span class="cl">class D2: public D1 { /* ... */ };
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this hierarchy, Base is a direct base to D1 and an indirect base to D2. A direct base class is named in the derivation list. Effectively, the most derived object contains a subobject for its direct base and for each of its indirect bases.</p>
<h2 id="preventing-inheritance">Preventing Inheritance</h2>
<p>Under the new standard, we can prevent a class from being used as a base by following the class name with final:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class NoDerived final { /* */ }; // NoDerived can&#39;t be a base class
</span></span><span class="line"><span class="cl">class Base { /* */ };
</span></span><span class="line"><span class="cl">// Last is final; we cannot inherit from Last
</span></span><span class="line"><span class="cl">class Last final : Base { /* */ }; // Last can&#39;t be a base class
</span></span><span class="line"><span class="cl">class Bad : NoDerived { /* */ }; // error: NoDerived is final
</span></span><span class="line"><span class="cl">class Bad2 : Last { /* */ }; // error: Last is final
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="conversions-and-inheritance">Conversions and Inheritance</h2>
<p>Ordinarily, we can bind a reference or a pointer only to an object that has the same type as the corresponding reference or pointer or to a type that involves an acceptable const conversion. Classes related by inheritance are an important exception: We can bind a pointer or reference to a base-class type to an object of a type derived from that base class. For example, we can use a Quote&amp; to refer to a Bulk_quote object, and we can assign the address of a Bulk_quote object to a Quote*.</p>
<p>The fact that we can bind a reference (or pointer) to a base-class type to a derived object has a crucially important implication: When we use a reference (or pointer) to a base-class type, we don’t know the actual type of the object to which the pointer or reference is bound. That object can be an object of the base class or it can be an object of a derived class.</p>
<p>There Is No Implicit Conversion from Base to Derived. We cannot convert from base to derived even when a base pointer or reference is bound to a derived object:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Bulk_quote bulk;
</span></span><span class="line"><span class="cl">Quote *itemP = &amp;bulk; // ok: dynamic type is Bulk_quote
</span></span><span class="line"><span class="cl">Bulk_quote *bulkP = itemP; // error: can&#39;t convert base to derived
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the base class has one or more virtual functions, we can use a dynamic_cast to request a conversion that is checked at run time. Alternatively, in those caseswhen we know that the conversion from base to derived is safe, we can use a static_cast to override the compiler.</p>
<p>The automatic derived-to-base conversion applies only for conversions to a reference or pointer type. There is no such conversion from a derived-class type to the base-class type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span> <span class="o">//</span> <span class="n">object</span> <span class="n">of</span> <span class="n">derived</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl"><span class="n">Quote</span> <span class="n">item</span><span class="p">(</span><span class="n">bulk</span><span class="p">);</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">Quote</span><span class="p">::</span><span class="n">Quote</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="n">item</span> <span class="o">=</span> <span class="n">bulk</span><span class="p">;</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">Quote</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When item is constructed, the Quote copy constructor is run. That constructor knows only about the bookNo and price members. It copies those members from the Quote part of bulk and  ignores the members that are part of the Bulk_quote portion of bulk. Because the Bulk_quote part is ignored, we say that the Bulk_quote portion of bulk is <strong>sliced down</strong>.
When we initialize or assign an object of a base type from an object of a derived type, only the base-class part of the derived object is copied, moved, or assigned. The derived part of the object is ignored.</p>
<h2 id="virtual-functions">Virtual Functions</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Quote base(&#34;0-201-82470-1&#34;, 50);
</span></span><span class="line"><span class="cl">print_total(cout, base, 10); // calls Quote::net_price
</span></span><span class="line"><span class="cl">Bulk_quote derived(&#34;0-201-82470-1&#34;, 50, 5, .19);
</span></span><span class="line"><span class="cl">print_total(cout, derived, 10); // calls Bulk_quote::net_price
</span></span></code></pre></td></tr></table>
</div>
</div><p>It is crucial to understand that dynamic binding happens only when a virtual function is called through a pointer or a reference.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">base = derived; // copies the Quote part of derived into base
</span></span><span class="line"><span class="cl">base.net_price(20); // calls Quote::net_price
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we call a virtual function on an expression that has a plain—nonreference and nonpointer—type, that call is bound at compile time. For example, We can change the value of the object that base represents, but there is no way to change the type of that object. Hence, this call is resolved, at compile time, to the Quote version of net_price.</p>
<p>The key idea behind OOP is <strong>polymorphism</strong>. Polymorphism is derived from a Greek word meaning “many forms.” We speak of types related by inheritance as polymorphic types, because we can use the “many forms” of these types while ignoring the differences among them.</p>
<p>A function that is virtual in a base class is implicitly virtual in its derived classes. When a derived class overrides a virtual, the parameters in the base and derived classes must match exactly.</p>
<p>It is legal for a derived class to define a function with the same name as a virtual in its base class but with a different parameter list. In practice, such declarations often are a mistake—the class author intended to override a virtual from the base class but made a mistake in specifying the parameter list. Under the new standard we can specify <code>override</code> on a virtual function in a derived class.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="n">void</span> <span class="n">f2</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f3</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">D1</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">f1</span> <span class="n">matches</span> <span class="n">f1</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">base</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f2</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">B</span> <span class="n">has</span> <span class="n">no</span> <span class="n">f2</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="n">function</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f3</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">f3</span> <span class="ow">not</span> <span class="n">virtual</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f4</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">B</span> <span class="n">doesn</span><span class="s1">&#39;t have a function named f4</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can also designate a function as final. Any attempt to override a function that has been defined as <code>final</code> will be flagged as an error:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">D2</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">inherits</span> <span class="n">f2</span><span class="p">()</span> <span class="ow">and</span> <span class="n">f3</span><span class="p">()</span> <span class="n">from</span> <span class="n">B</span> <span class="ow">and</span> <span class="n">overrides</span> <span class="n">f1</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="k">const</span> <span class="n">final</span><span class="p">;</span> <span class="o">//</span> <span class="n">subsequent</span> <span class="n">classes</span> <span class="n">can</span><span class="s1">&#39;t override f1(int)</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">D3</span> <span class="p">:</span> <span class="n">D2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f2</span><span class="p">();</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">overrides</span> <span class="n">f2</span> <span class="n">inherited</span> <span class="n">from</span> <span class="n">the</span> <span class="n">indirect</span> <span class="n">base</span><span class="p">,</span> <span class="n">B</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="ne">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">D2</span> <span class="n">declared</span> <span class="n">f2</span> <span class="n">as</span> <span class="n">final</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Like any other function, a virtual function can have default arguments. If a call uses a default argument, the value that is used is the one defined by the static type through which the function is called. That is, when a call is made through a reference or pointer to base, the default argument(s) will be those defined in the base class. The base-class arguments will be used even when the derived version of the function is run.</p>
<p>In some cases, we want to prevent dynamic binding of a call to a virtual function; we want to force the call to use a particular version of that virtual. We can use the scope operator to do so. For example, this code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// calls the version from the base class regardless of the dynamic type of baseP
</span></span><span class="line"><span class="cl">double undiscounted = baseP-&gt;Quote::net_price(42);
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ordinarily, only code inside member functions (or friends) should need to use the scope operator to circumvent the virtual mechanism. Why might we wish to circumvent the virtual mechanism? The most common reason is when a derived-class virtual function calls the version from the base class. In such cases, the base-class version might do work common to all types in the hierarchy. The versions defined in the derived classes would do whatever additional work is particular to their own type.
If a derived virtual function that intended to call its base-class version omits the scope operator, the call will be resolved at run time as a call to the derived version itself, resulting in an infinite recursion.</p>
<h2 id="abstract-base-classes">Abstract Base Classes</h2>
<p>In practice, we’d like to prevent users from creating Disc_quote objects at all. This class represents the general concept of a discounted book, not a concrete discount strategy. We can enforce this design intent, by defining net_price as a <strong>pure virtual</strong> function. Unlike ordinary virtuals, a pure virtual function does not have to be defined. It is worth noting that we can provide a definition for a pure virtual. However, the function body must be defined outside the class.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="k">class</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">discount</span> <span class="n">rate</span> <span class="ow">and</span> <span class="n">quantity</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">derived</span> <span class="n">classes</span> <span class="n">will</span> <span class="n">implement</span> <span class="n">pricing</span> <span class="n">strategies</span> <span class="n">using</span> <span class="n">these</span> <span class="n">data</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Disc_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Disc_quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Disc_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="n">double</span> <span class="n">price</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="n">double</span> <span class="n">disc</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">quantity</span><span class="p">(</span><span class="n">qty</span><span class="p">),</span> <span class="n">discount</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">quantity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="n">purchase</span> <span class="n">size</span> <span class="k">for</span> <span class="n">the</span> <span class="n">discount</span> <span class="n">to</span> <span class="n">apply</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">discount</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="o">//</span> <span class="n">fractional</span> <span class="n">discount</span> <span class="n">to</span> <span class="n">apply</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A class containing (or inheriting without overridding) a pure virtual function is an <strong>abstract base class</strong>. An abstract base class defines an interface for subsequent classes to override. We cannot (directly) create objects of a type that is an abstract base class. Classes that inherit from Disc_quote must define net_price or those classes will be abstract as well.</p>
<p>Now we can reimplement Bulk_quote to inherit from Disc_quote rather than inheriting directly from Quote:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">discount</span> <span class="n">kicks</span> <span class="ow">in</span> <span class="n">when</span> <span class="n">a</span> <span class="n">specified</span> <span class="n">number</span> <span class="n">of</span> <span class="n">copies</span> <span class="n">of</span> <span class="n">the</span> <span class="n">same</span> <span class="n">book</span> <span class="n">are</span> <span class="n">sold</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">the</span> <span class="n">discount</span> <span class="n">is</span> <span class="n">expressed</span> <span class="n">as</span> <span class="n">a</span> <span class="n">fraction</span> <span class="n">to</span> <span class="n">use</span> <span class="n">to</span> <span class="n">reduce</span> <span class="n">the</span> <span class="n">normal</span> <span class="n">price</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Bulk_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Disc_quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="n">double</span> <span class="n">price</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="n">double</span> <span class="n">disc</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">Disc_quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">overrides</span> <span class="n">the</span> <span class="n">base</span> <span class="n">version</span> <span class="n">to</span> <span class="n">implement</span> <span class="n">the</span> <span class="n">bulk</span> <span class="n">purchase</span> <span class="n">discount</span> <span class="n">policy</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This version of Bulk_quote has a direct base class, Disc_quote, and an indirect base class, Quote. Each Bulk_quote object has three subobjects: an (empty) Bulk_quote part, a Disc_quote subobject, and a Quote subobject.
As we’ve seen, each class controls the initialization of objects of its type. Therefore, even though Bulk_quote has no data members of its own, it provides the same four-argument constructor as in our original class.</p>
<h2 id="access-control-and-inheritance">Access Control and Inheritance</h2>
<p>As we’ve seen, a class uses protected for those members that it is willing to share with its derived classes but wants to protect from general access. The protected specifier can be thought of as a blend of private and public:</p>
<ul>
<li>Like private, protected members are inaccessible to users of the class.</li>
<li>Like public, protected members are accessible to members and friends of classes derived from this class.</li>
</ul>
<p>In addition, protected has another important property:</p>
<ul>
<li>A derived class member or friend may access the protected members of the base class only through a derived object. The derived class has no special access to the protected members of base-class objects.</li>
</ul>
<p>To understand this last rule, consider the following example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Base {
</span></span><span class="line"><span class="cl">protected:
</span></span><span class="line"><span class="cl">    int prot_mem; // protected member
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">class Sneaky : public Base {
</span></span><span class="line"><span class="cl">    friend void clobber(Sneaky&amp;); // can access Sneaky::prot_mem
</span></span><span class="line"><span class="cl">    friend void clobber(Base&amp;); // can&#39;t access Base::prot_mem
</span></span><span class="line"><span class="cl">    int j; // j is private by default
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">// ok: clobber can access the private and protected members in Sneaky objects
</span></span><span class="line"><span class="cl">void clobber(Sneaky &amp;s) { s.j = s.prot_mem = 0; }
</span></span><span class="line"><span class="cl">// error: clobber can&#39;t access the protected members in Base
</span></span><span class="line"><span class="cl">void clobber(Base &amp;b) { b.prot_mem = 0; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>That function is just a friend of Sneaky.</p>
<p>Access to a member that a class inherits is controlled by a combination of the access specifier for that member in the base class, and the access specifier in the derivation list of the derived class. As an example, consider the following hierarchy:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">pub_mem</span><span class="p">();</span> <span class="o">//</span> <span class="n">public</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl"><span class="n">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="o">//</span> <span class="n">protected</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">char</span> <span class="n">priv_mem</span><span class="p">;</span> <span class="o">//</span> <span class="n">private</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">Pub_Derv</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">derived</span> <span class="n">classes</span> <span class="n">can</span> <span class="n">access</span> <span class="n">protected</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">private</span> <span class="n">members</span> <span class="n">are</span> <span class="n">inaccessible</span> <span class="n">to</span> <span class="n">derived</span> <span class="n">classes</span>
</span></span><span class="line"><span class="cl">    <span class="n">char</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">priv_mem</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">Priv_Derv</span> <span class="p">:</span> <span class="n">private</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">private</span> <span class="n">derivation</span> <span class="n">doesn</span><span class="s1">&#39;t affect access in the derived class</span>
</span></span><span class="line"><span class="cl">    <span class="ne">int</span> <span class="n">f1</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The derivation access specifier has no effect on whether members (and friends) of a derived class may access the members of its own direct base class. Access to the members of a base class is controlled by the access specifiers in the base class itself. The purpose of the derivation access specifier is to control the access that  users of the derived class—including other classes derived from the derived class—have to the members inherited from Base:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Pub_Derv d1; // members inherited from Base are public
</span></span><span class="line"><span class="cl">Priv_Derv d2; // members inherited from Base are private
</span></span><span class="line"><span class="cl">d1.pub_mem(); // ok: pub_mem is public in the derived class
</span></span><span class="line"><span class="cl">d2.pub_mem(); // error: pub_mem is private in the derived class
</span></span></code></pre></td></tr></table>
</div>
</div><p>The derivation access specifier used by a derived class also controls access from classes that inherit from that derived class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct Derived_from_Public : public Pub_Derv {
</span></span><span class="line"><span class="cl">    // ok: Base::prot_mem remains protected in Pub_Derv
</span></span><span class="line"><span class="cl">    int use_base() { return prot_mem; }
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">struct Derived_from_Private : public Priv_Derv {
</span></span><span class="line"><span class="cl">    // error: Base::prot_mem is private in Priv_Derv
</span></span><span class="line"><span class="cl">    int use_base() { return prot_mem; }
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Had we defined another class, say, Prot_Derv, that used protected inheritance, the public members of Base would be protected members in that class. Users of Prot_Derv would have no access to pub_mem, but the members and friends of Prot_Derv could access that inherited member.</p>
<h2 id="accessibility-of-derived-to-base-conversion">Accessibility of Derived-to-Base Conversion</h2>
<p>Whether the derived-to-base conversion is accessible depends on which code is trying to use the conversion and may depend on the access specifier used in the derived class’ derivation. Assuming D inherits from B:</p>
<ul>
<li>User code may use the derived-to-base conversion only if D inherits publicly from B. User code may not use the conversion if D inherits from B using either protected or private.</li>
<li>Member functions and friends of D can use the conversion to B regardless of how D inherits from B. The derived-to-base conversion to a direct base class is always accessible to members and friends of a derived class.</li>
<li>Member functions and friends of classes derived from D may use the derived-to-base conversion if D inherits from B using either public or protected. Such code may not use the conversion if D inherits privately from B.</li>
</ul>
<p>In the absence of inheritance, we can think of a class as having two different kinds of users: ordinary users and implementors. Ordinary users write code that uses objects of the class type; such code can access only the public (interface) members of the class. Implementors write the code contained in the members and friends of the class. The members and friends of the class can access both the public and private (implementation) sections.</p>
<p>Under inheritance, there is a third kind of user, namely, derived classes. A base class makes protected those parts of its implementation that it is willing to let its derived classes use. The protected members remain inaccessible to ordinary user code; private members remain inaccessible to derived classes and their friends.</p>
<p>Like any other class, a class that is used as a base class makes its interface members public . A class that is used as a base class may divide its implementation into those members that are accessible to derived classes and those that remain accessible only to the base class and its friends. An implementation member should be protected if it provides an operation or data that a derived class will need to use in its own implementation. Otherwise, implementation members should be private.</p>
<h2 id="friendship-and-inheritance">Friendship and Inheritance</h2>
<p>Just as friendship is not transitive, friendship is also not inherited.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Base {
</span></span><span class="line"><span class="cl">    // added friend declaration; other members as before
</span></span><span class="line"><span class="cl">    friend class Pal; // Pal has no access to classes derived from Base
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">class Pal {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    int f(Base b) { return b.prot_mem; } // ok: Pal is a friend of Base
</span></span><span class="line"><span class="cl">    int f2(Sneaky s) { return s.j; } // error: Pal not friend of Sneaky
</span></span><span class="line"><span class="cl">    // access to a base class is controlled by the base class, even inside a derived object
</span></span><span class="line"><span class="cl">    int f3(Sneaky s) { return s.prot_mem; } // ok: Pal is a friend
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>The fact that f3 is legal may seem surprising, but it follows directly from the notion that each class controls access to its own members. Pal is a friend of Base, so Pal can access the members of Base objects. That access includes access to Base objects that are embedded in an object of a type derived from Base.</p>
<h2 id="exempting-individual-members">Exempting Individual Members</h2>
<p>Sometimes we need to change the access level of a name that a derived class inherits. We can do so by providing a using declaration:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Derived</span> <span class="p">:</span> <span class="n">private</span> <span class="n">Base</span> <span class="p">{</span> <span class="o">//</span> <span class="n">note</span><span class="p">:</span> <span class="n">private</span> <span class="n">inheritance</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">maintain</span> <span class="n">access</span> <span class="n">levels</span> <span class="k">for</span> <span class="n">members</span> <span class="n">related</span> <span class="n">to</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">    <span class="n">using</span> <span class="n">Base</span><span class="p">::</span><span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">protected</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">using</span> <span class="n">Base</span><span class="p">::</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because Derived uses private inheritance, the inherited members, size and n, are (by default) private members of Derived. The using declarations adjust the accessibility of these members. Users of Derived can access the size member, and classes subsequently derived from Derived can access n.</p>
<p>A using declaration inside a class can name any accessible member of a direct or indirect base class. Access to a name specified in a using declaration depends on the access specifier preceding the using declaration. That is, if a using declaration appears in a private part of the class, that name is accessible to members and friends only. If the declaration is in a public section, the name is available to all users of the class. If the declaration is in a protected section, the name is accessible to the members, friends, and derived classes.</p>
<h2 id="default-inheritance-protection-levels">Default Inheritance Protection Levels</h2>
<p>By default, a derived class defined with the class keyword has private inheritance; a derived class defined with struct has public inheritance:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Base { /* ... */ };
</span></span><span class="line"><span class="cl">struct D1 : Base { /* ... */ }; // public inheritance by default
</span></span><span class="line"><span class="cl">class D2 : Base { /* ... */ }; // private inheritance by default
</span></span></code></pre></td></tr></table>
</div>
</div><p>The only differences are the default access specifier for members and the default derivation access specifier. There are no other distinctions.</p>
<h2 id="class-scope-under-inheritance">Class Scope under Inheritance</h2>
<p>Each class defines its own scope within which its members are defined. Under inheritance, the scope of a derived class is nested inside the scope of its base classes. If a name is unresolved within the scope of the derived class, the enclosing base-class scopes are searched for a definition of that name.</p>
<p>Name Lookup Happens at Compile Time. The static type of an object, reference, or pointer determines which members of that object are visible.</p>
<p>As usual, names defined in an inner scope (e.g., a derived class) hide uses of that name in the outer scope. Aside from overriding inherited virtual functions, a derived class usually should not reuse names defined in its base class.</p>
<p>As Usual, Name Lookup Happens before Type Checking. As we’ve seen, functions declared in an inner scope do not overload functions declared in an outer scope. As a result, functions defined in a derived class do  not overload members defined in its base class(es). As in any other scope, if a member in a derived class has the same name as a base-class member, then the derived member hides the base-class member within the scope of the derived class. The base member is hidden even if the functions have different parameter lists:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct Base {
</span></span><span class="line"><span class="cl">    int memfcn();
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">struct Derived : Base {
</span></span><span class="line"><span class="cl">    int memfcn(int); // hides memfcn in the base
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">Derived d; Base b;
</span></span><span class="line"><span class="cl">b.memfcn(); // calls Base::memfcn
</span></span><span class="line"><span class="cl">d.memfcn(10); // calls Derived::memfcn
</span></span><span class="line"><span class="cl">d.memfcn(); // error: memfcn with no arguments is hidden
</span></span><span class="line"><span class="cl">d.Base::memfcn(); // ok: calls Base::memfcn
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="overriding-overloaded-functions">Overriding Overloaded Functions</h2>
<p>A derived class can override zero or more instances of the overloaded functions it inherits. If a derived class wants to make all the overloaded versions available through its type, then it must override all of them or none of them. Instead of overriding every base-class version that it inherits, a derived class can provide a using declaration for the overloaded member. A using declaration specifies only a name; it may not specify a parameter list. Thus, a using declaration for a base-class member function adds all the overloaded instances of that function to the scope of the derived class.</p>
<h2 id="virtual-destructors">Virtual Destructors</h2>
<p>The primary direct impact that inheritance has on copy control for a base class is that a base class generally should define a virtual destructor. As with any other function, we arrange to run the proper destructor by defining the destructor as virtual in the base class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Quote {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    // virtual destructor needed if a base pointer pointing to a derived object is deleted
</span></span><span class="line"><span class="cl">    virtual ~Quote() = default; // dynamic binding for the destructor
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Like any other virtual, the virtual nature of the destructor is inherited. Thus, classes derived from Quote have virtual destructors, whether they use the synthesized destructor or define their own version. So long as the base class destructor is virtual, when we delete a pointer to base, the correct destructor will be run:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Quote *itemP = new Quote; // same static and dynamic type
</span></span><span class="line"><span class="cl">delete itemP; // destructor for Quote called
</span></span><span class="line"><span class="cl">itemP = new Bulk_quote; // static and dynamic types differ
</span></span><span class="line"><span class="cl">delete itemP; // destructor for Bulk_quote called
</span></span></code></pre></td></tr></table>
</div>
</div><p>Executing delete on a pointer to base that points to a derived object has undefined behavior if the base’s destructor is not virtual.</p>
<p>Destructors for base classes are an important exception to the rule of thumb that if a class needs a destructor, it also needs copy and assignment.</p>
<p>The fact that a base class needs a virtual destructor has an important indirect impact on the definition of base and derived classes: If a class defines a destructor—even if it uses = default to use the synthesized version—the compiler will not synthesize a move operation for that class.</p>
<h2 id="synthesized-copy-control-and-inheritance">Synthesized Copy Control and Inheritance</h2>
<p>The synthesized copy-control members in a base or a derived class execute like any other synthesized constructor, assignment operator, or destructor: They memberwise initialize, assign, or destroy the members of the class itself. In addition, these synthesized members initialize, assign, or destroy the direct base part of an object by using the corresponding operation from the base class.</p>
<p>It is worth noting that it doesn’t matter whether the base-class member is itself synthesized or has a an user-provided definition. All that matters is that the corresponding member is accessible and that it is not a deleted function.</p>
<p>The synthesized default constructor, or any of the copy-control members of either a base or a derived class, may be defined as deleted for the same reasons as in any other class. In addition, the way in which a base class is defined can cause a derived-class member to be defined as deleted:</p>
<ul>
<li>
<p>If the default constructor, copy constructor, copy-assignment operator, or destructor in the base class is deleted or inaccessible, then the corresponding member in the derived class is defined as deleted, because the compiler can’t use the base-class member to construct, assign, or destroy the base-class part of the object.</p>
</li>
<li>
<p>If the base class has an inaccessible or deleted destructor, then the synthesized default and copy constructors in the derived classes are defined as deleted, because there is no way to destroy the base part of the derived object.</p>
</li>
<li>
<p>As usual, the compiler will not synthesize a deleted move operation. If we use = default to request a move operation, it will be a deleted function in the derived if the corresponding operation in the base is deleted or inaccessible, because the base class part cannot be moved. The move constructor will also be deleted if the base class destructor is deleted or inaccessible.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span><span class="p">,</span> <span class="ow">not</span> <span class="n">including</span> <span class="n">a</span> <span class="n">move</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">D</span> <span class="p">:</span> <span class="n">public</span> <span class="n">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">no</span> <span class="n">constructors</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="n">d</span><span class="p">;</span> <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">D</span><span class="s1">&#39;s synthesized default constructor uses B&#39;</span><span class="n">s</span> <span class="n">default</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="n">d2</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">D</span><span class="s1">&#39;s synthesized copy constructor is deleted</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="n">d3</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">implicitly</span> <span class="n">uses</span> <span class="n">D</span><span class="s1">&#39;s deleted copy constructor</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because the copy constructor is defined, the compiler will not synthesize a move constructor for class B. If a class derived from B wanted to allow its objects to be copied or moved, that derived class would have to define its own versions of these constructors.</p>
<h2 id="move-operations-and-inheritance">Move Operations and Inheritance</h2>
<p>As we’ve seen, most base classes define a virtual destructor. As a result, by default, base classes generally do not get synthesized move operations. Moreover, by default, classes derived from a base class that doesn’t have move operations don’t get synthesized move operations either.</p>
<p>Because lack of a move operation in a base class suppresses synthesized move for its derived classes, base classes ordinarily should define the move operations if it is sensible to do so. Our Quote class can use the synthesized versions. However, Quote must define these members explicitly. Once it defines its move operations, it must also explicitly define the copy versions as well:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">memberwise</span> <span class="n">default</span> <span class="n">initialize</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">memberwise</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">memberwise</span> <span class="n">copy</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">assign</span>
</span></span><span class="line"><span class="cl">    <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span> <span class="o">//</span> <span class="n">move</span> <span class="n">assign</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="o">~</span><span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now, Quote objects will be memberwise copied, moved, assigned, and destroyed. Moreover, classes derived from Quote will automatically obtain synthesized move operations as well, unless they have members that otherwise preclude move.</p>
<h2 id="derived-class-copy-control-members">Derived-Class Copy-Control Members</h2>
<p>When a derived class defines a copy or move operation, that operation is responsible for copying or moving the entire object, including base-class members. We ordinarily use the corresponding base-class constructor to initialize the base part of the object:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Base</span> <span class="p">{</span> <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span> <span class="p">}</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">D</span><span class="p">:</span> <span class="n">public</span> <span class="n">Base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">by</span> <span class="n">default</span><span class="p">,</span> <span class="n">the</span> <span class="n">base</span> <span class="k">class</span> <span class="n">default</span> <span class="n">constructor</span> <span class="n">initializes</span> <span class="n">the</span> <span class="n">base</span> <span class="n">part</span> <span class="n">of</span> <span class="n">an</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">to</span> <span class="n">use</span> <span class="n">the</span> <span class="n">copy</span> <span class="ow">or</span> <span class="n">move</span> <span class="n">constructor</span><span class="p">,</span> <span class="n">we</span> <span class="n">must</span> <span class="n">explicitly</span> <span class="n">call</span> <span class="n">that</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">constructor</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">constructor</span> <span class="n">initializer</span> <span class="n">list</span>
</span></span><span class="line"><span class="cl">    <span class="n">D</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">):</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">the</span> <span class="n">base</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl">    <span class="o">/*</span> <span class="n">initializers</span> <span class="k">for</span> <span class="n">members</span> <span class="n">of</span> <span class="n">D</span> <span class="o">*/</span> <span class="p">{</span> <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">D</span><span class="p">(</span><span class="n">D</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">):</span> <span class="n">Base</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">//</span> <span class="n">move</span> <span class="n">the</span> <span class="n">base</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl">    <span class="o">/*</span> <span class="n">initializers</span> <span class="k">for</span> <span class="n">members</span> <span class="n">of</span> <span class="n">D</span> <span class="o">*/</span> <span class="p">{</span> <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By default, the base-class default constructor initializes the base-class part of a derived object. If we want copy (or move) the base-class part, we must explicitly use the copy (or move) constructor for the base class in the derived’s constructor initializer list.</p>
<h2 id="derived-class-assignment-operator">Derived-Class Assignment Operator</h2>
<p>Like the copy and move constructors, a derived-class assignment operator, must assign its base part explicitly:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Base</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span><span class="o">&amp;</span><span class="p">)</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">invoked</span> <span class="n">automatically</span>
</span></span><span class="line"><span class="cl"><span class="n">D</span> <span class="o">&amp;</span><span class="n">D</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Base</span><span class="p">::</span><span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span> <span class="o">//</span> <span class="n">assigns</span> <span class="n">the</span> <span class="n">base</span> <span class="n">part</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">assign</span> <span class="n">the</span> <span class="n">members</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">derived</span> <span class="k">class</span><span class="p">,</span> <span class="n">as</span> <span class="n">usual</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">handling</span> <span class="bp">self</span><span class="o">-</span><span class="n">assignment</span> <span class="ow">and</span> <span class="n">freeing</span> <span class="n">existing</span> <span class="n">resources</span> <span class="n">as</span> <span class="n">appropriate</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="derived-class-destructor">Derived-Class Destructor</h2>
<p>Recall that the data members of an object are implicitly destroyed after the destructor body completes. Similarly, the base-class parts of an object are also implicitly destroyed. As a result, unlike the constructors and assignment operators, a derived destructor is responsible only for destroying the resources allocated by the derived class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class D: public Base {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    // Base::~Base invoked automatically
</span></span><span class="line"><span class="cl">    ~D() { /* do what it takes to clean up derived members */ }
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Objects are destroyed in the opposite order from which they are constructed: The derived destructor is run first, and then the base-class destructors are invoked, back up through the inheritance hierarchy.</p>
<h2 id="calls-to-virtuals-in-constructors-and-destructors">Calls to Virtuals in Constructors and Destructors</h2>
<p>As we’ve seen, the base-class part of a derived object is constructed first. While the base-class constructor is executing, the derived part of the object is uninitialized. Similarly, derived objects are destroyed in reverse order, so that when a base class destructor runs, the derived part has already been destroyed. As a result, while these base-class members are executing, the object is incomplete.</p>
<p>To accommodate this incompleteness, the compiler treats the object as if its type changes during construction or destruction. That is, while an object is being constructed it is treated as if it has the same class as the constructor; calls to virtual functions will be bound as if the object has the same type as the constructor itself.</p>
<p>To understand this behavior, consider what would happen if the derived-class version of a virtual was called from a base-class constructor. However, those members are uninitialized while a base constructor is running. If such access were allowed, the program would probably crash.</p>
<p>If a constructor or destructor calls a virtual, the version that is run is the one corresponding to the type of the constructor or destructor itself.</p>
<h2 id="inherited-constructors">Inherited Constructors</h2>
<p>Under the new standard, a derived class can reuse the constructors defined by its direct base class. If the derived class does not directly define these constructors, the compiler synthesizes them as usual. A derived class inherits its base-class constructors by providing a using declaration that names its (direct) base class. As an example, we can redefine our Bulk_quote class to inherit its constructors from Disc_quote:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Bulk_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Disc_quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">using</span> <span class="n">Disc_quote</span><span class="p">::</span><span class="n">Disc_quote</span><span class="p">;</span> <span class="o">//</span> <span class="n">inherit</span> <span class="n">Disc_quote</span><span class="s1">&#39;s constructors</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ordinarily, a using declaration only makes a name visible in the current scope. When applied to a constructor, a using declaration causes the compiler to generate code. The compiler generates a derived constructor corresponding to each constructor in the base. That is, for each constructor in the base class, the compiler generates a constructor in the derived class that has the same parameter list. These compiler-generated constructors have the form:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">derived(parms) : base(args) { }
</span></span></code></pre></td></tr></table>
</div>
</div><p>In our Bulk_quote class, the inherited constructor would be equivalent to:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="n">double</span> <span class="n">price</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="n">double</span> <span class="n">disc</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">Disc_quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike using declarations for ordinary members, a constructor using declaration does not change the access level of the inherited constructor(s). Moreover, a using declaration can’t specify explicit or constexpr. If a constructor in the base is explicit or constexpr, the inherited constructor has the same property.</p>
<p>If a base-class constructor has default arguments, those arguments are not inherited. Instead, the derived class gets multiple inherited constructors in which each parameter with a default argument is successively omitted.</p>
<p>If a base class has several constructors, then with two exceptions, the derived class inherits each of the constructors from its base class. The first exception is that a derived class can inherit some constructors and define its own versions of other constructors. The second exception is that the default, copy, and move constructors are not inherited.</p>
<h2 id="containers-and-inheritance">Containers and Inheritance</h2>
<p>We cannot put objects of types related by inheritance directly into a container, because there is no way to define a container that holds elements of differing types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;Quote&gt; basket;
</span></span><span class="line"><span class="cl">basket.push_back(Quote(&#34;0-201-82470-1&#34;, 50));
</span></span><span class="line"><span class="cl">// ok, but copies only the Quote part of the object into basket
</span></span><span class="line"><span class="cl">basket.push_back(Bulk_quote(&#34;0-201-54848-8&#34;, 50, 10, .25));
</span></span><span class="line"><span class="cl">// calls version defined by Quote, prints 750, i.e., 15 * $50
</span></span><span class="line"><span class="cl">cout &lt;&lt; basket.back().net_price(15) &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><p>The elements in basket are Quote objects. When we add a Bulk_quote object to the vector its derived part is ignored. Because derived objects are “sliced down” when assigned to a base-type object, containers and types related by inheritance do not mix well.</p>
<p>When we need a container that holds objects related by inheritance, we typically define the container to hold pointers (preferably smart pointers) to the base class.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;
</span></span><span class="line"><span class="cl">basket.push_back(make_shared&lt;Quote&gt;(&#34;0-201-82470-1&#34;, 50));
</span></span><span class="line"><span class="cl">basket.push_back(
</span></span><span class="line"><span class="cl">make_shared&lt;Bulk_quote&gt;(&#34;0-201-54848-8&#34;, 50, 10, .25));
</span></span><span class="line"><span class="cl">// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount
</span></span><span class="line"><span class="cl">cout &lt;&lt; basket.back()-&gt;net_price(15) &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="writing-a-basket-class">Writing a Basket Class</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Basket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">Basket</span> <span class="n">uses</span> <span class="n">synthesized</span> <span class="n">default</span> <span class="n">constructor</span> <span class="ow">and</span> <span class="n">copy</span><span class="o">-</span><span class="n">control</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sale</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sale</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="nb">prints</span> <span class="n">the</span> <span class="n">total</span> <span class="n">price</span> <span class="k">for</span> <span class="n">each</span> <span class="n">book</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">overall</span> <span class="n">total</span> <span class="k">for</span> <span class="n">all</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">basket</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">total_receipt</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">function</span> <span class="n">to</span> <span class="n">compare</span> <span class="n">shared_ptrs</span> <span class="n">needed</span> <span class="n">by</span> <span class="n">the</span> <span class="n">multiset</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="ne">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">multiset</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">multiple</span> <span class="n">quotes</span><span class="p">,</span> <span class="n">ordered</span> <span class="n">by</span> <span class="n">the</span> <span class="n">compare</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">decltype</span><span class="p">(</span><span class="n">compare</span><span class="p">)</span><span class="o">*&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">items</span><span class="p">{</span><span class="n">compare</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The elements in our multiset are shared_ptrs and there is no less-than operator for shared_ptr. As a result, we must provide our own comparison operation to order the elements. Here, we define a private static member, named compare, that compares the isbns of the objects to which the shared_ptrs point. We initialize our multiset to use this comparison function through an in-class initializer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// multiset to hold multiple quotes, ordered by the compare member
</span></span><span class="line"><span class="cl">std::multiset&lt;std::shared_ptr&lt;Quote&gt;, decltype(compare)*&gt;
</span></span><span class="line"><span class="cl">    items{compare};
</span></span></code></pre></td></tr></table>
</div>
</div><p>The multiset member is named items, and we’re initializing items to use our compare function. <code>decltype(compare)*</code> in the template parameter specifies the type of the comparator. It doesn&rsquo;t tell which function is to be used. So we need specify a compare function. A better approach might be to use a function class type; then the function call can be resolved at compile time, and a default-constructed object will do the right thing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">compare</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="p">()(</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="p">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">compare</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The member function total_receipt prints an itemized bill for the contents of the basket and returns the price for all the items in the basket:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">double</span> <span class="n">Basket</span><span class="p">::</span><span class="n">total_receipt</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="o">//</span> <span class="n">holds</span> <span class="n">the</span> <span class="n">running</span> <span class="n">total</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">iter</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">the</span> <span class="n">first</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">batch</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">with</span> <span class="n">the</span> <span class="n">same</span> <span class="n">ISBN</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">upper_bound</span> <span class="n">returns</span> <span class="n">an</span> <span class="n">iterator</span> <span class="n">to</span> <span class="n">the</span> <span class="n">element</span> <span class="n">just</span> <span class="n">past</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">that</span> <span class="n">batch</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">cbegin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="o">.</span><span class="n">cend</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">iter</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">we</span> <span class="n">know</span> <span class="n">there</span><span class="s1">&#39;s at least one element with this key in the Basket</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">line</span> <span class="n">item</span> <span class="k">for</span> <span class="n">this</span> <span class="n">book</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum</span> <span class="o">+=</span> <span class="n">print_total</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="o">**</span><span class="n">iter</span><span class="p">,</span> <span class="n">items</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;Total Sale: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">final</span> <span class="n">overall</span> <span class="n">total</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We skip over all the elements that match the current key by calling upper_bound. Inside the for loop, we call print_total to print the details for each book in the basket. When we dereference iter, we get a shared_ptr that points to the object we want to print. To get that object, we must dereference that shared_ptr. Thus, **iter is a Quote object.</p>
<p>Users of Basket still have to deal with dynamic memory, because add_item takes a shared_ptr. As a result, users have to write code such as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Basket bsk;
</span></span><span class="line"><span class="cl">bsk.add_item(make_shared&lt;Quote&gt;(&#34;123&#34;, 45));
</span></span><span class="line"><span class="cl">bsk.add_item(make_shared&lt;Bulk_quote&gt;(&#34;345&#34;, 45, 3, .15));
</span></span></code></pre></td></tr></table>
</div>
</div><p>Our next step will be to redefine add_item so that it takes a Quote object instead of a shared_ptr. This new version of add_item will handle the memory allocation so that our users no longer need to do so. We’ll define two versions, one that will copy its given object and the other that will move from it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">sale</span><span class="p">);</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">the</span> <span class="n">given</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">add_item</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span> <span class="n">sale</span><span class="p">);</span> <span class="o">//</span> <span class="n">move</span> <span class="n">the</span> <span class="n">given</span> <span class="n">object</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The only problem is that add_item doesn’t know what type to allocate. Somewhere there will be a new expression such as: <code>new Quote(sale)</code>. Unfortunately, this expression allocates an object of type Quote and copies the Quote portion of sale. However, sale might refer to a Bulk_quote object, in which case, that object will be sliced down. We’ll solve this problem by giving our Quote classes a virtual member that allocates a copy of itself.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">virtual</span> <span class="n">function</span> <span class="n">to</span> <span class="k">return</span> <span class="n">a</span> <span class="n">dynamically</span> <span class="n">allocated</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">itself</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">these</span> <span class="n">members</span> <span class="n">use</span> <span class="n">reference</span> <span class="n">qualifiers</span><span class="p">;</span> <span class="n">see</span> <span class="err">§</span><span class="mf">13.6</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span> <span class="mi">546</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span>  <span class="n">Quote</span><span class="o">*</span>  <span class="n">clone</span><span class="p">()</span>  <span class="k">const</span>  <span class="o">&amp;</span>  <span class="p">{</span><span class="k">return</span>  <span class="n">new</span> <span class="n">Quote</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">    <span class="n">virtual</span> <span class="n">Quote</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="k">return</span> <span class="n">new</span> <span class="n">Quote</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">));}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Bulk_quote</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Quote</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="o">*</span>  <span class="n">clone</span><span class="p">()</span>  <span class="k">const</span>  <span class="o">&amp;</span>  <span class="p">{</span><span class="k">return</span>  <span class="n">new</span> <span class="n">Bulk_quote</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Bulk_quote</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="k">return</span> <span class="n">new</span> <span class="n">Bulk_quote</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">));}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because we have a copy and a move version of add_item, we defined lvalue and rvalue versions of clone. Each clone function allocates a new object of its own type. The const lvalue reference member copies itself into that newly allocated object; the rvalue reference member moves its own data. Using clone, it is easy to write our new versions of add_item:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Basket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">sale</span><span class="p">)</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">the</span> <span class="n">given</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sale</span><span class="o">.</span><span class="n">clone</span><span class="p">()));</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">add_item</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span> <span class="n">sale</span><span class="p">)</span> <span class="o">//</span> <span class="n">move</span> <span class="n">the</span> <span class="n">given</span> <span class="n">object</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">items</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">sale</span><span class="p">)</span><span class="o">.</span><span class="n">clone</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">as</span> <span class="n">before</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Our clone function is also virtual. Whether the Quote or Bulk_quote function is run, depends on the dynamic type of sale. We bind a shared_ptr to that object and call insert to add this newly allocated object to items. Note that because shared_ptr supports the derived-to-base conversion, we can bind a <code>shared_ptr&lt;Quote&gt;</code> to a <code>Bulk_quote*</code>.</p>
<h1 id="templates-and-generic-programming">Templates and Generic Programming</h1>
<p>When we write a generic program, we write the code in a way that is independent of any particular type. For example, the library provides a single, generic definition of each container, such as vector. Templates are the foundation of generic programming. A template is a blueprint or formula for creating classes or functions. When we use a generic type, such as vector, or a generic function, such as find, we supply the information needed to transform that blueprint into a specific class or function.</p>
<h2 id="function-templates">Function Templates</h2>
<p>Rather than defining a new function for each type, we can define a <strong>function template</strong>. A function template is a formula from which we can generate type-specific versions of that function. The template version of compare looks like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A template definition starts with the keyword template followed by a template parameter list, which is a comma-separated list of one or more <strong>template parameters</strong> bracketed by the less-than (&lt;) and greater-than (&gt;) tokens. Template parameters represent types or values used in the definition of a class or function. When we use a template, we specify—either implicitly or explicitly <strong>template argument(s)</strong> to bind to the template parameter(s). Our compare function declares one type parameter named T.</p>
<p>When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template argument(s) for us. That is, when we call compare, the compiler uses the type of the arguments to determine what type to bind to the template parameter T.</p>
<p>The compiler uses the deduced template parameter(s) to instantiate a specific version of the function for us. When the compiler instantiates a template, it creates a new “instance” of the template using the actual template argument(s) in place of the corresponding template parameter(s).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;&amp;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">T</span> <span class="n">is</span> <span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Our compare function has one template <strong>type parameter</strong>. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// ok: same type used for the return type and parameter
</span></span><span class="line"><span class="cl">template &lt;typename T&gt; T foo(T* p)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    T tmp = *p; // tmp will have the type to which p points
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">    return tmp;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each type parameter must be preceded by the keyword <code>class</code> or <code>typename</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">must</span> <span class="n">precede</span> <span class="n">U</span> <span class="n">with</span> <span class="n">either</span> <span class="n">typename</span> <span class="ow">or</span> <span class="k">class</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>These keywords have the same meaning and can be used interchangeably inside a template parameter list. A template parameter list can use both keywords:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">no</span> <span class="n">distinction</span> <span class="n">between</span> <span class="n">typename</span> <span class="ow">and</span> <span class="k">class</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">list</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">class</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">calc</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="nontype-template-parameters">Nontype Template Parameters</h2>
<p>In addition to defining type parameters, we can define templates that take <strong>nontype parameters</strong>. A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the class or typename keyword. When the template is instantiated, nontype parameters are replaced with a value supplied by the user or deduced by the compiler. These values must be constant expressions.</p>
<p>As an example, we can write a version of compare that will handle string literals. Because we’d like to be able to compare literals of different lengths, we’ll give our template two nontype parameters. The first template parameter will represent the size of the first array, and the second parameter will represent the size of the second array:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">M</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we call this version of compare:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">compare(&#34;hi&#34;, &#34;mom&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>the compiler will use the size of the literals to instantiate a version of the template with the sizes substituted for N and M. Remembering that the compiler inserts a null terminator at the end of a string literal, the compiler will instantiate</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A nontype parameter may be an integral type, or a pointer or (lvalue) reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression.  Arguments bound to a pointer or reference nontype parameter must have static lifetime. We may not use an ordinary (nonstatic) local object or a dynamic object as a template argument for reference or pointer nontype template parameters. A pointer parameter can also be instantiated by nullptr or a zero-valued constant expression.</p>
<p>A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required, for example, to specify the size of an array.</p>
<h2 id="inline-and--constexpr-function-templates">inline and  constexpr Function Templates</h2>
<p>The inline or constexpr specifier follows the template parameter list and precedes the return type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">inline</span> <span class="n">specifier</span> <span class="n">follows</span> <span class="n">the</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">list</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">inline</span> <span class="n">T</span> <span class="nb">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">incorrect</span> <span class="n">placement</span> <span class="n">of</span> <span class="n">the</span> <span class="n">inline</span> <span class="n">specifier</span>
</span></span><span class="line"><span class="cl"><span class="n">inline</span> <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nb">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-independent-code">Type-Independent Code</h2>
<p>Simple though it is, our initial compare function illustrates two important principles for writing generic code:</p>
<ul>
<li>The function parameters in the template are references to const.</li>
<li>The tests in the body use only &lt; comparisons.</li>
</ul>
<p>By making the function parameters references to const, we ensure that our function can be used on types that cannot be copied. Most types—including the built-in types and, except for unique_ptr and the IO types, all the library types we’ve used do allow copying. By writing the code using only the &lt; operator, we reduce the requirements on types that can be used with our compare function. In fact, if we were truly concerned about type independence and portability, we probably should have defined our function using the less:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">version</span> <span class="n">of</span> <span class="n">compare</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">correct</span> <span class="n">even</span> <span class="k">if</span> <span class="n">used</span> <span class="n">on</span> <span class="n">pointers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The problem with our original version is that if a user calls it with two pointers and those pointers do not point to the same array, then our code is undefined.</p>
<h2 id="template-compilation">Template Compilation</h2>
<p>The fact that code is generated only when we use a template (and not when we define it) affects how we organize our source code and when errors are detected. Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarly, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class definitions and function declarations in header files and definitions of ordinary and class-member functions in source files.</p>
<p>Templates are different: To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. As a result, unlike nontemplate code, headers for templates typically include definitions as well as declarations. Definitions of function templates and member functions of class templates are ordinarily put into header files.</p>
<p>When we write a template, the code may not be overtly type specific, but template code usually makes some assumptions about the types that will be used. For example, the code inside our original compare function assumes that the argument type has a &lt; operator. If the arguments passed to compare have a &lt; operation, then the code is fine, but not otherwise. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Sales_data data1, data2;
</span></span><span class="line"><span class="cl">cout &lt;&lt; compare(data1, data2) &lt;&lt; endl; // error: no &lt; on Sales_data
</span></span></code></pre></td></tr></table>
</div>
</div><p>This instantiation generates a version of the function that will not compile. However, errors such as this one cannot be detected until the compiler instantiates the definition of compare on type Sales_data.</p>
<h2 id="class-templates">Class Templates</h2>
<p>As an example, we’ll implement a template version of StrBlob. We’ll name our template Blob to indicate that it is no longer specific to strings.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">Blob</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">typedef</span> <span class="n">typename</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">constructors</span>
</span></span><span class="line"><span class="cl">    <span class="n">Blob</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">Blob</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">add</span> <span class="ow">and</span> <span class="n">remove</span> <span class="n">elements</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">move</span> <span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">element</span> <span class="n">access</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">&amp;</span> <span class="n">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">throws</span> <span class="n">msg</span> <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">isn</span><span class="s1">&#39;t valid</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As we’ve seen many times, when we use a class template, we must supply extra information. We can now see that that extra information is a list of explicit template arguments that are bound to the template’s parameters. For example, to define a type from our Blob template, we must provide the element type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Blob&lt;int&gt; ia; // empty Blob&lt;int&gt;
</span></span><span class="line"><span class="cl">Blob&lt;int&gt; ia2 = {0,1,2,3,4}; // Blob&lt;int&gt; with five elements
</span></span></code></pre></td></tr></table>
</div>
</div><p>The compiler generates a different class for each element type we specify. Each instantiation of a class template constitutes an independent class. The type Blob<string> has no relationship to, or any special access to, the members of any other Blob type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// these definitions instantiate two distinct Blob types
</span></span><span class="line"><span class="cl">Blob&lt;string&gt; names; // Blob that holds strings
</span></span><span class="line"><span class="cl">Blob&lt;double&gt; prices;// different element type
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="member-functions-of-class-templates">Member Functions of Class Templates</h2>
<p>As with any class, we can define the member functions of a class template either inside or outside of the class body. As with any other class, members defined inside the class body are implicitly inline. As usual, when we define a member outside its class, we must say to which class the member belongs. We’ll start by defining the check member, which verifies a given index:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="n">throw</span> <span class="n">std</span><span class="p">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The subscript operator and back function use the template parameter to specify the return type but are otherwise unchanged:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">T&amp; Blob&lt;T&gt;::back()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    check(0, &#34;back on empty Blob&#34;);
</span></span><span class="line"><span class="cl">    return data-&gt;back();
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">T&amp; Blob&lt;T&gt;::operator[](size_type i)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // if i is too big, check will throw, preventing access to a nonexistent element
</span></span><span class="line"><span class="cl">    check(i, &#34;subscript out of range&#34;);
</span></span><span class="line"><span class="cl">    return (*data)[i];
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>In our original StrBlob class these operators returned string&amp;. The template versions will return a reference to whatever type is used to instantiate Blob.</p>
<p>As with any other member defined outside a class template, a constructor starts by declaring the template parameters for the class template of which it is a member:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">Blob&lt;T&gt;::Blob(): data(std::make_shared&lt;std::vector&lt;T&gt;&gt;()) { }
</span></span></code></pre></td></tr></table>
</div>
</div><p>Similarly, the constructor that takes an initializer_list uses its type parameter T as the element type for its initializer_list parameter:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">Blob&lt;T&gt;::Blob(std::initializer_list&lt;T&gt; il):
</span></span><span class="line"><span class="cl">    data(std::make_shared&lt;std::vector&lt;T&gt;&gt;(il)) { }
</span></span></code></pre></td></tr></table>
</div>
</div><p>To use this constructor, we must pass an initializer_list in which the elements are compatible with the element type of the Blob:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Blob&lt;string&gt; articles = {&#34;a&#34;, &#34;an&#34;, &#34;the&#34;};
</span></span></code></pre></td></tr></table>
</div>
</div><p>By default, a member of an instantiated class template is instantiated only if the member is used. For example, this code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">::</span><span class="n">size</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">squares</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">squares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="o">//</span> <span class="n">instantiates</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">::</span><span class="n">operator</span><span class="p">[](</span><span class="n">size_t</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There is one exception to the rule that we must supply template arguments when we use a class template type. Inside the scope of the class template itself, we may use the name of the template without arguments:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">BlobPtr</span> <span class="n">throws</span> <span class="n">an</span> <span class="n">exception</span> <span class="n">on</span> <span class="n">attempts</span> <span class="n">to</span> <span class="n">access</span> <span class="n">a</span> <span class="n">nonexistent</span> <span class="n">element</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">BlobPtr</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">BlobPtr</span><span class="p">():</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">BlobPtr</span><span class="p">(</span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s2">&#34;dereference past end&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span> <span class="o">//</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">is</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">to</span> <span class="n">which</span> <span class="n">this</span> <span class="n">object</span> <span class="n">points</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">increment</span> <span class="ow">and</span> <span class="n">decrement</span>
</span></span><span class="line"><span class="cl">    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">++</span><span class="p">();</span> <span class="o">//</span> <span class="n">prefix</span> <span class="n">operators</span>
</span></span><span class="line"><span class="cl">    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">--</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">check</span> <span class="n">returns</span> <span class="n">a</span> <span class="n">shared_ptr</span> <span class="n">to</span> <span class="n">the</span> <span class="n">vector</span> <span class="k">if</span> <span class="n">the</span> <span class="n">check</span> <span class="n">succeeds</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="n">check</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">store</span> <span class="n">a</span> <span class="n">weak_ptr</span><span class="p">,</span> <span class="n">which</span> <span class="n">means</span> <span class="n">the</span> <span class="n">underlying</span> <span class="n">vector</span> <span class="n">might</span> <span class="n">be</span> <span class="n">destroyed</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">curr</span><span class="p">;</span> <span class="o">//</span> <span class="n">current</span> <span class="n">position</span> <span class="n">within</span> <span class="n">the</span> <span class="n">array</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Careful readers will have noted that the prefix increment and decrement members of BlobPtr return BlobPtr&amp;, not BlobPtr<T>&amp;. When we are inside the scope of a class template, the compiler treats references to the template itself as if we had supplied template arguments matching the template’s own parameters. That is, it is as if we had written:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">BlobPtr&lt;T&gt;&amp; operator++();
</span></span><span class="line"><span class="cl">BlobPtr&lt;T&gt;&amp; operator--();
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// postfix: increment/decrement the object but return the unchanged value
</span></span><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::operator++(int)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // no check needed here; the call to prefix increment will do the check
</span></span><span class="line"><span class="cl">    BlobPtr ret = *this; // save the current value
</span></span><span class="line"><span class="cl">    ++*this; // advance one element; prefix ++ checks the increment
</span></span><span class="line"><span class="cl">    return ret; // return the saved state
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because the return type appears outside the scope of the class, we must specify that the return type returns a BlobPtr instantiated with the same type as the class. Inside the function body, we are in the scope of the class so do not need to repeat the template argument when we define ret. Hence, the definition of ret is as if we had written:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">BlobPtr&lt;T&gt; ret = *this;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Inside the scope of a class template, we may refer to the template without specifying template argument(s).</p>
<h2 id="class-templates-and-friends">Class Templates and Friends</h2>
<p>When a class contains a friend declaration, the class and the friend can independently be templates or not. A class template that has a nontemplate friend grants that friend access to all the instantiations of the template. When the friend is itself a template, the class granting friendship controls whether friendship includes all instantiations of the template or only specific instantiation(s).</p>
<p>In order to refer to a specific instantiation of a template (class or function) we must first declare the template itself.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">forward</span> <span class="n">declarations</span> <span class="n">needed</span> <span class="k">for</span> <span class="n">friend</span> <span class="n">declarations</span> <span class="ow">in</span> <span class="n">Blob</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">BlobPtr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">Blob</span><span class="p">;</span> <span class="o">//</span> <span class="n">needed</span> <span class="k">for</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">==</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="ne">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">Blob</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">each</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="n">Blob</span> <span class="n">grants</span> <span class="n">access</span> <span class="n">to</span> <span class="n">the</span> <span class="n">version</span> <span class="n">of</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">BlobPtr</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">equality</span> <span class="n">operator</span> <span class="n">instantiated</span> <span class="n">with</span> <span class="n">the</span> <span class="n">same</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl">    <span class="n">friend</span> <span class="k">class</span> <span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">friend</span> <span class="ne">bool</span> <span class="n">operator</span><span class="o">==&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A class can also make every instantiation of another template its friend, or it may limit friendship to a specific instantiation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// forward declaration necessary to befriend a specific instantiation of a template
</span></span><span class="line"><span class="cl">template &lt;typename T&gt; class Pal;
</span></span><span class="line"><span class="cl">class C 
</span></span><span class="line"><span class="cl">{ 
</span></span><span class="line"><span class="cl">    // C is an ordinary, nontemplate class
</span></span><span class="line"><span class="cl">    friend class Pal&lt;C&gt;; // Pal instantiated with class C is a friend to C
</span></span><span class="line"><span class="cl">    // all instances of Pal2 are friends to C;
</span></span><span class="line"><span class="cl">    // no forward declaration required when we befriend all instantiations
</span></span><span class="line"><span class="cl">    template &lt;typename T&gt; friend class Pal2;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">template &lt;typename T&gt; class C2 
</span></span><span class="line"><span class="cl">{ 
</span></span><span class="line"><span class="cl">    // C2 is itself a class template
</span></span><span class="line"><span class="cl">    // each instantiation of C2 has the same instance of Pal as a friend
</span></span><span class="line"><span class="cl">    friend class Pal&lt;T&gt;; // a template declaration for Pal must be in scope
</span></span><span class="line"><span class="cl">    // all instances of Pal2 are friends of each instance of C2, prior declaration needed
</span></span><span class="line"><span class="cl">    template &lt;typename X&gt; friend class Pal2;
</span></span><span class="line"><span class="cl">    // Pal3 is a nontemplate class that is a friend of every instance of C2
</span></span><span class="line"><span class="cl">    friend class Pal3; // prior declaration for Pal3 not needed
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>To allow all instantiations as friends, the friend declaration must use template parameter(s) that differ from those used by the class itself.</p>
<p>Under the new standard, we can make a template type parameter a friend:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename Type&gt; class Bar {
</span></span><span class="line"><span class="cl">friend Type; // grants access to the type used to instantiate Bar
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here we say that whatever type is used to instantiate Bar is a friend.</p>
<h2 id="template-type-aliases">Template Type Aliases</h2>
<p>we can define a typedef that refers to that instantiated class:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef Blob&lt;string&gt; StrBlob;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because a template is not a type, we cannot define a typedef that refers to a template. However, the new standard lets us define a type alias for a class template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;
</span></span><span class="line"><span class="cl">twin&lt;string&gt; authors; // authors is a pair&lt;string, string&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>A template type alias is a synonym for a family of classes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">twin&lt;int&gt; win_loss; // win_loss is a pair&lt;int, int&gt;
</span></span><span class="line"><span class="cl">twin&lt;double&gt; area; // area is a pair&lt;double, double&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="static-members-of-class-templates">static Members of Class Templates</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt; class Foo {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    static std::size_t count() { return ctr; }
</span></span><span class="line"><span class="cl">    // other interface members
</span></span><span class="line"><span class="cl">private:
</span></span><span class="line"><span class="cl">    static std::size_t ctr;
</span></span><span class="line"><span class="cl">    // other implementation members
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each instantiation of Foo has its own instance of the static members.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::count
</span></span><span class="line"><span class="cl">Foo&lt;string&gt; fs;
</span></span><span class="line"><span class="cl">// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count members
</span></span><span class="line"><span class="cl">Foo&lt;int&gt; fi, fi2, fi3;
</span></span></code></pre></td></tr></table>
</div>
</div><p>As with any other static data member, there must be exactly one definition of each static data member of a template class. We define a static data member as a template similarly to how we define the member functions of that template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">size_t Foo&lt;T&gt;::ctr = 0; // define and initialize ctr
</span></span></code></pre></td></tr></table>
</div>
</div><p>When Foo is instantiated for a particular template argument type, a separate ctr will be instantiated for that class type and initialized to 0.</p>
<p>As with static members of nontemplate classes, we can access a static member of a class template through an object of the class type or by using the scope operator to access the member directly. To use a static member through the class, we must refer to a specific instantiation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Foo&lt;int&gt; fi; // instantiates Foo&lt;int&gt; class
</span></span><span class="line"><span class="cl">// and the static data member ctr
</span></span><span class="line"><span class="cl">auto ct = Foo&lt;int&gt;::count(); // instantiates Foo&lt;int&gt;::count
</span></span><span class="line"><span class="cl">ct = fi.count(); // uses Foo&lt;int&gt;::count
</span></span><span class="line"><span class="cl">ct = Foo::count(); // error: which template instantiation?
</span></span></code></pre></td></tr></table>
</div>
</div><p>Like any other member function, a static member function is instantiated only if it is used in a program.</p>
<h2 id="template-parameters">Template Parameters</h2>
<p>Like the names of function parameters, a template parameter name has no intrinsic meaning. We ordinarily name type parameters T, but we can use any name:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="o">//</span> <span class="n">tmp</span> <span class="n">has</span> <span class="n">the</span> <span class="n">same</span> <span class="n">type</span> <span class="n">as</span> <span class="n">the</span> <span class="n">parameters</span> <span class="ow">and</span> <span class="k">return</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span> <span class="o">//</span> <span class="k">return</span> <span class="n">type</span> <span class="ow">and</span> <span class="n">parameters</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because a parameter name cannot be reused, the name of a template parameter can appear only once with in a given template parameter list:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// error: illegal reuse of template parameter name V
</span></span><span class="line"><span class="cl">template &lt;typename V, typename V&gt; // ...
</span></span></code></pre></td></tr></table>
</div>
</div><p>A template declaration must include the template parameters :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">declares</span> <span class="n">but</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">define</span> <span class="n">compare</span> <span class="ow">and</span> <span class="n">Blob</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">Blob</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The names of a template parameter need not be the same across the declaration(s) and the definition of the same template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zed" data-lang="zed"><span class="line"><span class="cl"><span class="c1">// all three uses of calc refer to the same function template
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">calc</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span><span class="w"> </span><span class="c1">// declaration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="n">U</span><span class="w"> </span><span class="n">calc</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">U</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">U</span><span class="o">&amp;</span><span class="p">);</span><span class="w"> </span><span class="c1">// declaration
</span></span></span><span class="line"><span class="cl"><span class="c1">// definition of the template
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">Type</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Type</span><span class="w"> </span><span class="n">calc</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">Type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* . . . */</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Declarations for all the templates needed by a given file usually should appear together at the beginning of a file before any code that uses those names.</p>
<h2 id="using-class-members-that-are-types">Using Class Members That Are Types</h2>
<p>Recall that we use the scope operator (::) to access both static members and type members. In ordinary code, the compiler knows whether a name accessed through the scope operator is a type or a static member. Assuming T is a template type parameter, When the compiler sees code such as T::mem it won’t know until instantiation time whether mem is a type or a static data member. However, in order to process the template, the compiler must know whether a name represents a type. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">T::size_type * p;
</span></span></code></pre></td></tr></table>
</div>
</div><p>it needs to know whether we’re defining a variable named p or are multiplying a static data member named size_type by a variable named p.</p>
<p>By default, the language assumes that a name accessed through the scope operator is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type. We do so by using the keyword <code>typename</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">typename</span> <span class="n">T</span><span class="p">::</span><span class="n">value_type</span> <span class="n">top</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">typename</span> <span class="n">T</span><span class="p">::</span><span class="n">value_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we want to inform the compiler that a name represents a type, we must use the keyword typename, not class.</p>
<h2 id="default-template-arguments">Default Template Arguments</h2>
<p>Under the new standard, we can supply default arguments for both function and class templates. Earlier versions of the language, allowed default arguments only with class templates.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">compare</span> <span class="n">has</span> <span class="n">a</span> <span class="n">default</span> <span class="n">template</span> <span class="n">argument</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">default</span> <span class="n">function</span> <span class="n">argument</span><span class="p">,</span> <span class="n">F</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">typename</span> <span class="n">F</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When users call this version of compare, they may supply their own comparison operation but are not required to do so:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">bool i = compare(0, 42); // uses less; i is -1
</span></span><span class="line"><span class="cl">// result depends on the isbns in item1 and item2
</span></span><span class="line"><span class="cl">Sales_data item1(cin), item2(cin);
</span></span><span class="line"><span class="cl">bool j = compare(item1, item2, compareIsbn);
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first call uses the default function argument, which is a default-initialized object of type less<int>. In the second call, we pass compareIsbn and two objects of type Sales_data. When compare is called with three arguments, the type of the third argument must be a callable object that returns a type that is convertible to bool and takes arguments of a type compatible with the types of the first two arguments.</p>
<p>As with function default arguments, a template parameter may have a default argument only if all of the parameters to its right also have default arguments.</p>
<p>Whenever we use a class template, we must always follow the template’s name with brackets. In particular, if a class template provides default arguments for all of its template parameters, and we want to use those defaults, we must put an empty bracket pair following the template’s name:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="n">T</span> <span class="o">=</span> <span class="ne">int</span><span class="o">&gt;</span> <span class="k">class</span> <span class="n">Numbers</span> <span class="p">{</span> <span class="o">//</span> <span class="n">by</span> <span class="n">default</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Numbers</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">various</span> <span class="n">operations</span> <span class="n">on</span> <span class="n">numbers</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Numbers</span><span class="o">&lt;</span><span class="n">long</span> <span class="n">double</span><span class="o">&gt;</span> <span class="n">lots_of_precision</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Numbers</span><span class="o">&lt;&gt;</span> <span class="n">average_precision</span><span class="p">;</span> <span class="o">//</span> <span class="n">empty</span> <span class="o">&lt;&gt;</span> <span class="n">says</span> <span class="n">we</span> <span class="n">want</span> <span class="n">the</span> <span class="n">default</span> <span class="n">type</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="member-templates">Member Templates</h2>
<p>A class—either an ordinary class or a class template—may have a member function that is itself a template. Such members are referred to as <strong>member templates</strong>. Member templates may not be virtual. As an example of an ordinary class that has a member template, we’ll define a class that is similar to the default deleter type used by unique_ptr. Like the default deleter, our class will have an overloaded function-call operator that will take a pointer and execute delete on the given pointer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">function</span><span class="o">-</span><span class="n">object</span> <span class="k">class</span> <span class="n">that</span> <span class="n">calls</span> <span class="n">delete</span> <span class="n">on</span> <span class="n">a</span> <span class="n">given</span> <span class="n">pointer</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="n">DebugDelete</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugDelete</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">cerr</span><span class="p">):</span> <span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">as</span> <span class="n">with</span> <span class="n">any</span> <span class="n">function</span> <span class="n">template</span><span class="p">,</span> <span class="n">the</span> <span class="n">type</span> <span class="n">of</span> <span class="n">T</span> <span class="n">is</span> <span class="n">deduced</span> <span class="n">by</span> <span class="n">the</span> <span class="n">compiler</span>
</span></span><span class="line"><span class="cl">    <span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;deleting unique_ptr&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span> <span class="n">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="p">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can use this class as a replacement for delete:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">double* p = new double;
</span></span><span class="line"><span class="cl">DebugDelete d; // an object that can act like a delete expression
</span></span><span class="line"><span class="cl">d(p); // calls DebugDelete::operator()(double*), which deletes p
</span></span><span class="line"><span class="cl">int* ip = new int;
</span></span><span class="line"><span class="cl">// calls operator()(int*) on a temporary DebugDelete object
</span></span><span class="line"><span class="cl">DebugDelete()(ip);
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because calling a DebugDelete object deletes its given pointer, we can also use DebugDelete as the deleter of a unique_ptr.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// destroying the the object to which p points
</span></span><span class="line"><span class="cl">// instantiates DebugDelete::operator()&lt;int&gt;(int *)
</span></span><span class="line"><span class="cl">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());
</span></span><span class="line"><span class="cl">// destroying the the object to which sp points
</span></span><span class="line"><span class="cl">// instantiates DebugDelete::operator()&lt;string&gt;(string*)
</span></span><span class="line"><span class="cl">unique_ptr&lt;string,  DebugDelete&gt;  sp(new  string, DebugDelete());
</span></span></code></pre></td></tr></table>
</div>
</div><p>The unique_ptr destructor calls the DebugDelete’s call operator. Thus, whenever unique_ptr’s destructor is instantiated, DebugDelete’s call operator will also be instantiated: Thus, the definitions above will instantiate:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">sample</span> <span class="n">instantiations</span> <span class="k">for</span> <span class="n">member</span> <span class="n">templates</span> <span class="n">of</span> <span class="n">DebugDelete</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">DebugDelete</span><span class="p">::</span><span class="n">operator</span><span class="p">()(</span><span class="ne">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">DebugDelete</span><span class="p">::</span><span class="n">operator</span><span class="p">()(</span><span class="n">string</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can also define a member template of a class template. In this case, both the class and the member have their own, independent, template parameters. As an example, we’ll give our Blob class a constructor that will take two iterators denoting a range of elements to copy.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt; class Blob {
</span></span><span class="line"><span class="cl">    template &lt;typename It&gt; Blob(It b, It e);
</span></span><span class="line"><span class="cl">// ...
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike ordinary function members of class templates, member templates are function templates. When we define a member template outside the body of a class template, we must provide the template parameter list for the class template and for the function template. The parameter list for the class template comes first, followed by the member’s own template parameter list:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">//</span> <span class="n">type</span> <span class="n">parameter</span> <span class="k">for</span> <span class="n">the</span> <span class="k">class</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">It</span><span class="o">&gt;</span> <span class="o">//</span> <span class="n">type</span> <span class="n">parameter</span> <span class="k">for</span> <span class="n">the</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl">    <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Blob</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>To instantiate a member template of a class template, we must supply arguments for the template parameters for both the class and the function templates.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">long</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">char</span><span class="o">*&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;now&#34;</span><span class="p">,</span> <span class="s2">&#34;is&#34;</span><span class="p">,</span> <span class="s2">&#34;the&#34;</span><span class="p">,</span> <span class="s2">&#34;time&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="n">the</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="k">class</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">constructor</span> <span class="n">that</span> <span class="n">has</span> <span class="n">two</span> <span class="ne">int</span><span class="o">*</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="n">the</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">constructor</span> <span class="n">that</span> <span class="n">has</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">two</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">long</span><span class="o">&gt;</span><span class="p">::</span><span class="n">iterator</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantiates</span> <span class="n">the</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">class</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">constructor</span> <span class="n">that</span> <span class="n">has</span> <span class="n">two</span> <span class="p">(</span><span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">char</span><span class="o">*&gt;</span><span class="p">::</span><span class="n">iterator</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">end</span><span class="p">());</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="controlling-instantiations">Controlling Instantiations</h2>
<p>The fact that instantiations are generated when a template is used means that the same instantiation may appear in multiple object files. In large systems, the overhead of instantiating the same template in multiple files can become significant. Under the new standard, we can avoid this overhead through an <strong>explicit instantiation</strong>. An explicit instantiation has the form</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extern template declaration; // instantiation declaration
</span></span><span class="line"><span class="cl">template declaration; // instantiation definition
</span></span></code></pre></td></tr></table>
</div>
</div><p>where  declaration is a class or function declaration in which all the template parameters are replaced by the template arguments. For example,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">instantion</span> <span class="n">declaration</span> <span class="ow">and</span> <span class="n">definition</span>
</span></span><span class="line"><span class="cl"><span class="n">extern</span> <span class="n">template</span> <span class="k">class</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="o">//</span> <span class="n">declaration</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">definition</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the compiler sees an extern template declaration, it will not generate code for that instantiation in that file. Declaring an instantiation as extern is a promise that there will be a nonextern use of that instantiation elsewhere in the program. There may be several extern declarations for a given instantiation but there must be exactly one definition for that instantiation.</p>
<p>Because the compiler automatically instantiates a template when we use it, the extern declaration must appear before any code that uses that instantiation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Application</span><span class="o">.</span><span class="n">cc</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">these</span> <span class="n">template</span> <span class="n">types</span> <span class="n">must</span> <span class="n">be</span> <span class="n">instantiated</span> <span class="n">elsewhere</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">program</span>
</span></span><span class="line"><span class="cl"><span class="n">extern</span> <span class="n">template</span> <span class="k">class</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">extern</span> <span class="n">template</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sa1</span><span class="p">,</span> <span class="n">sa2</span><span class="p">;</span> <span class="o">//</span> <span class="n">instantiation</span> <span class="n">will</span> <span class="n">appear</span> <span class="n">elsewhere</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="n">its</span> <span class="n">initializer_list</span> <span class="n">constructor</span> <span class="n">instantiated</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">file</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Blob</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">constructor</span> <span class="n">instantiated</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">file</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="o">//</span> <span class="n">instantiation</span> <span class="n">will</span> <span class="n">appear</span> <span class="n">elsewhere</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The file Application.o will contain instantiations for Blob<int>, along with the initializer_list and copy constructors for that class. The compare<int> function and Blob<string> class will not be instantiated in that file. There must be definitions of these templates in some other file in the program:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zed" data-lang="zed"><span class="line"><span class="cl"><span class="c1">// templateBuild.cc
</span></span></span><span class="line"><span class="cl"><span class="c1">// instantiation file must provide a (nonextern) definition for every
</span></span></span><span class="line"><span class="cl"><span class="c1">// type and function that other files declare as extern
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">template</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">compare</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">int</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">const</span><span class="w"> </span><span class="n">int</span><span class="o">&amp;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">template</span><span class="w"> </span><span class="n">class</span><span class="w"> </span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// instantiates all members of the class template
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>When the compiler sees an instantiation definition (as opposed to a declaration), it generates code. Thus, the file templateBuild.o will contain the definitions for compare instantiated with int and for the Blob<string> class. When we build the application, we must link templateBuild.o with the Application.o files.</p>
<p>There must be an explicit instantiation definition somewhere in the program for every instantiation declaration.</p>
<p>An instantiation definition for a class template instantiates all the members of that template including inline member functions. When the compiler sees an instantiation definition it cannot know which member functions the program uses. Hence, unlike the way it handles ordinary class template instantiations, the compiler instantiates  all the members of that class. Even if we do not use a member, that member will be instantiated. Consequently, we can use explicit instantiation only for types that can be used with all the members of that template.</p>
<h2 id="efficiency-and-flexibility">Efficiency and Flexibility</h2>
<p>The obvious difference between shared_ptr and unique_ptr is the strategy they use in managing the pointer they hold—one class gives us shared ownership; the other owns the pointer that it holds. This difference is essential to what these classes do. These classes also differ in how they let users override their default deleter.</p>
<p>We can easily override the deleter of a shared_ptr by passing a callable object when we create or reset the pointer. In contrast, the type of the deleter is part of the type of a unique_ptr object. Users must supply that type as an explicit template argument when they define a unique_ptr.</p>
<p>Although we don’t know how the library types are implemented, we can infer that shared_ptr must access its deleter indirectly. That is the deleter must be stored as a pointer or as a class that encapsulates a pointer. We can be certain that shared_ptr does not hold the deleter as a direct member, because the type of the deleter isn’t known until run time. Indeed, we can change the type of the deleter in a given shared_ptr during that shared_ptr’s lifetime. We can construct a shared_ptr using a deleter of one type, and subsequently use reset to give that same shared_ptr a different type of deleter.</p>
<p>Now, let’s think about how unique_ptr might work. In this class, the type of the deleter is part of the type of the unique_ptr. That is, unique_ptr has two template parameters, one that represents the pointer that the unique_ptr manages and the other that represents the type of the deleter. Because the type of the deleter is part of the type of a unique_ptr, the type of the deleter member is known at compile time. The deleter can be stored directly in each unique_ptr object.</p>
<p>By binding the deleter at compile time, unique_ptr avoids the run-time cost of an indirect call to its deleter. By binding the deleter at run time, shared_ptr makes it easier for users to override the deleter.</p>
<h2 id="conversions-and-template-type-parameters">Conversions and Template Type Parameters</h2>
<p>The process of determining the template arguments from the function arguments is known as <strong>template argument deduction</strong>. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call.</p>
<p>As with a nontemplate function, the arguments we pass in a call to a function template are used to initialize that function’s parameters. Only a very limited number of conversions are automatically applied to such arguments. Rather than converting the arguments, the compiler generates a new instantiation.</p>
<p>As usual, top-level consts in either the parameter or the argument are ignored. The only other conversions performed in a call to a function template are</p>
<ul>
<li>const conversions: A function parameter that is a reference (or pointer) to a const can be passed a reference (or pointer) to a nonconst object.</li>
<li>Array- or function-to-pointer conversions: If the function parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be converted to a pointer to its first element. Similarly, a function argument will be converted to a pointer to the function’s type.</li>
</ul>
<p>Other conversions, such as the arithmetic conversions, derived-to-base, and user-defined conversions, are not performed. As examples, consider calls to the functions fobj and fref. The fobj function copies its parameters, whereas fref’s parameters are references:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fobj</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span> <span class="o">//</span> <span class="n">arguments</span> <span class="n">are</span> <span class="n">copied</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">references</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s1</span><span class="p">(</span><span class="s2">&#34;a value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span> <span class="n">s2</span><span class="p">(</span><span class="s2">&#34;another value&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">fobj</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">fobj</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span> <span class="k">const</span> <span class="n">is</span> <span class="n">ignored</span>
</span></span><span class="line"><span class="cl"><span class="n">fref</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">uses</span> <span class="n">premissible</span> <span class="n">conversion</span> <span class="n">to</span> <span class="k">const</span> <span class="n">on</span> <span class="n">s1</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">fobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">f</span><span class="p">(</span><span class="ne">int</span><span class="o">*</span><span class="p">,</span> <span class="ne">int</span><span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">fref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">array</span> <span class="n">types</span> <span class="n">don</span><span class="s1">&#39;t match</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the first pair of calls, we pass a string and a const string. Even though these types do not match exactly, both calls are legal. In the call to fobj, the arguments are copied, so whether the original object is const doesn’t matter. In the call to fref, the parameter type is a reference to const. Conversion to const for a reference parameter is a permitted conversion, so this call is legal.</p>
<p>In the next pair of calls, we pass array arguments in which the arrays are different sizes and hence have different types. In the call to fobj, the fact that the array types differ doesn’t matter. Both arrays are converted to pointers. The template parameter type in fobj is int*. The call to fref, however, is illegal. When the parameter is a reference, the arrays are not converted to pointers. The types of a and b don’t match, so the call is in error.</p>
<p>const conversions and array or function to pointer are the only automatic conversions for arguments to parameters with template types.</p>
<h2 id="function-parameters-that-use-the-same-template-parameter-type">Function Parameters That Use the Same Template Parameter Type</h2>
<p>A template type parameter can be used as the type of more than one function parameter. Because there are limited conversions, the arguments to such parameters must have essentially the same type. If the deduced types do not match, then the call is an error. For example, our compare function takes two const T&amp; parameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">long lng;
</span></span><span class="line"><span class="cl">compare(lng, 1024); // error: cannot instantiate compare(long, int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>These types don’t match, so template argument deduction fails. If we want to allow normal conversions on the arguments, we can define the function with two type parameters:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">argument</span> <span class="n">types</span> <span class="n">can</span> <span class="n">differ</span> <span class="n">but</span> <span class="n">must</span> <span class="n">be</span> <span class="n">compatible</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">A</span><span class="p">,</span> <span class="n">typename</span> <span class="n">B</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">flexibleCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="normal-conversions-apply-for-ordinary-arguments">Normal Conversions Apply for Ordinary Arguments</h2>
<p>A function template can have parameters that are defined using ordinary types—that is, types that do not involve a template type parameter. Such arguments have no special processing; they are converted as usual to the corresponding type of the parameter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="nb">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because the type of os is fixed, normal conversions are applied to arguments passed to os when print is called:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print(cout, 42); // instantiates print(ostream&amp;, int)
</span></span><span class="line"><span class="cl">ofstream f(&#34;output&#34;);
</span></span><span class="line"><span class="cl">print(f, 10); // uses print(ostream&amp;, int); converts f to ostream&amp;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Normal conversions are applied to arguments whose type is not a template parameter.</p>
<h2 id="function-template-explicit-arguments">Function-Template Explicit Arguments</h2>
<p>We can let the user control the type of the return by defining a third template parameter to represent the return type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// T1 cannot be deduced: it doesn&#39;t appear in the function parameter list
</span></span><span class="line"><span class="cl">template &lt;typename T1, typename T2, typename T3&gt;
</span></span><span class="line"><span class="cl">T1 sum(T2, T3);
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this case, there is no argument whose type can be used to deduce the type of T1. The caller must provide an explicit template argument for this parameter on each call to sum. Explicit template arguments are specified inside angle brackets after the function name and before the argument list:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// T1 is explicitly specified; T2 and T3 are inferred from the argument types
</span></span><span class="line"><span class="cl">auto val3 = sum&lt;long long&gt;(i, lng); // long long sum(int, long)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter, the second argument to the second parameter, and so on. An explicit template argument may be omitted only for the trailing (right-most) parameters, and then only if these can be deduced from the function parameters. If our sum function had been written as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// poor design: users must explicitly specify all three template parameters
</span></span><span class="line"><span class="cl">template &lt;typename T1, typename T2, typename T3&gt;
</span></span><span class="line"><span class="cl">T3 alternative_sum(T2, T1);
</span></span></code></pre></td></tr></table>
</div>
</div><p>then we would always have to specify arguments for all three parameters:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// error: can&#39;t infer initial template parameters
</span></span><span class="line"><span class="cl">auto val3 = alternative_sum&lt;long long&gt;(i, lng);
</span></span><span class="line"><span class="cl">// ok: all three parameters are explicitly specified
</span></span><span class="line"><span class="cl">auto val2 = alternative_sum&lt;long long, int, long&gt;(i, lng);
</span></span></code></pre></td></tr></table>
</div>
</div><p>Normal conversions also apply for arguments whose template type parameter is explicitly specified:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">long lng;
</span></span><span class="line"><span class="cl">compare(lng, 1024); // error: template parameters don&#39;t match
</span></span><span class="line"><span class="cl">compare&lt;long&gt;(lng, 1024); // ok: instantiates compare(long, long)
</span></span><span class="line"><span class="cl">compare&lt;int&gt;(lng, 1024); // ok: instantiates compare(int, int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>As we’ve seen, the first call is in error because the arguments to compare must have the same type. If we explicitly specify the template parameter type, normal conversions apply.</p>
<h2 id="trailing-return-type">Trailing Return Type</h2>
<p>Using an explicit template argument to represent a template function’s return type works well when we want to let the user determine the return type. In other cases, requiring an explicit template argument imposes a burden on the user with no compensating advantage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename It&gt;
</span></span><span class="line"><span class="cl">??? &amp;fcn(It beg, It end)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // process the range
</span></span><span class="line"><span class="cl">    return *beg; // return a reference to an element from the range
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>We don’t know the exact type we want to return, but we do know that we want that type to be a reference to the element type of the sequence we’re processing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; vi = {1,2,3,4,5};
</span></span><span class="line"><span class="cl">Blob&lt;string&gt; ca = { &#34;hi&#34;, &#34;bye&#34; };
</span></span><span class="line"><span class="cl">auto &amp;i = fcn(vi.begin(), vi.end()); // fcn should return int&amp;
</span></span><span class="line"><span class="cl">auto &amp;s = fcn(ca.begin(), ca.end()); // fcn should return string&amp;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here, we know that our function will return *beg, and we know that we can use decltype(*beg) to obtain the type of that expression. However, beg doesn’t exist until the parameter list has been seen. To define this function, we must use a trailing return type. Because a trailing return appears after the parameter list, it can use the function’s parameters:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// a trailing return lets us declare the return type after the parameter list is seen
</span></span><span class="line"><span class="cl">template &lt;typename It&gt;
</span></span><span class="line"><span class="cl">auto fcn(It beg, It end) -&gt; decltype(*beg)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // process the range
</span></span><span class="line"><span class="cl">    return *beg; // return a reference to an element from the range
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="type-transformation">Type Transformation</h2>
<p>Sometimes we do not have direct access to the type that we need. For example, we might want to write a function similar to fcn that returns an element by value, rather than a reference to an element. The problem we face in writing this function is that we know almost nothing about the types we’re passed. In this function, the only operations we know we can use are iterator operations, and there are no iterator operations that yield elements.</p>
<p>To obtain the element type, we can use a library <strong>type transformation</strong> template. These templates are defined in the type_traits header. In general the classes in type_traits are used for so-called template metaprogramming, a topic that is beyond the scope of this Primer. However, the type transformation templates are useful in ordinary programming as well.</p>
<p>Standard Type Transformation Templates:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">For</span> <span class="n">Mod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span><span class="n">where</span> <span class="n">Mod</span> <span class="n">is</span>     <span class="n">If</span> <span class="n">T</span> <span class="n">is</span>                     <span class="n">Then</span> <span class="n">Mod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">::</span><span class="n">type</span> <span class="n">is</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">remove_reference</span>            <span class="n">X</span><span class="o">&amp;</span> <span class="ow">or</span> <span class="n">X</span><span class="o">&amp;&amp;</span>                   <span class="n">X</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add_const</span>                   <span class="n">X</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="p">,</span> <span class="ow">or</span> <span class="n">function</span>    <span class="n">T</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="k">const</span> <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add_lvalue_reference</span>        <span class="n">X</span><span class="o">&amp;</span>                          <span class="n">T</span>
</span></span><span class="line"><span class="cl">                            <span class="n">X</span><span class="o">&amp;&amp;</span>                         <span class="n">X</span><span class="o">&amp;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span><span class="o">&amp;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add_rvalue_reference</span>        <span class="n">X</span><span class="o">&amp;</span> <span class="ow">or</span> <span class="n">X</span><span class="o">&amp;&amp;</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span><span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">remove_pointer</span>              <span class="n">X</span><span class="o">*</span>                          <span class="n">X</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add_pointer</span>                 <span class="n">X</span><span class="o">&amp;</span> <span class="ow">or</span> <span class="n">X</span><span class="o">&amp;&amp;</span>                   <span class="n">X</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span><span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">make_signed</span>                 <span class="n">unsigned</span> <span class="n">X</span>                  <span class="n">X</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">make_unsigned</span>               <span class="n">signed</span> <span class="n">type</span>                 <span class="n">unsigned</span> <span class="n">T</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">remove_extent</span>               <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>                        <span class="n">X</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">remove_all_extents</span>          <span class="n">X</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span><span class="o">...</span>                <span class="n">X</span>
</span></span><span class="line"><span class="cl">                            <span class="n">otherwise</span>                   <span class="n">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The remove_reference template has one template type parameter and a (public) type member named type. If we instantiate remove_reference with a reference type, then type will be the referred-to type. For example, if we instantiate remove_reference&lt;int&amp;&gt;, the type member will be int.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">remove_reference&lt;decltype(*beg)&gt;::type
</span></span></code></pre></td></tr></table>
</div>
</div><p>will be the type of the element to which beg refers: decltype(*beg) returns the reference type of the element type. remove_reference::type strips off the reference, leaving the element type itself. Using remove_reference and a trailing return with decltype, we can write our function to return a copy of an element’s value:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// must use typename to use a type member of a template parameter;
</span></span><span class="line"><span class="cl">template &lt;typename It&gt;
</span></span><span class="line"><span class="cl">auto fcn2(It beg, It end) -&gt;
</span></span><span class="line"><span class="cl">    typename remove_reference&lt;decltype(*beg)&gt;::type
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    // process the range
</span></span><span class="line"><span class="cl">    return *beg; // return a copy of an element from the range
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that type is member of a class that depends on a template parameter. As a result, we must use typename in the declaration of the return type to tell the compiler that type represents a type.</p>
<p>If it is not possible (or not necessary) to transform the template’s parameter, the type member is the template parameter type itself. For example, if T is a pointer type, then remove_pointer<T>::type is the type to which T points. If T isn’t a pointer, then no transformation is needed. In this case, type is the same type as T.</p>
<h2 id="function-pointers-and-argument-deduction">Function Pointers and Argument Deduction</h2>
<p>When we initialize or assign a function pointer from a function template, the compiler uses the type of the pointer to deduce the template argument(s).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">pf1</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">instantiation</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf1</span><span class="p">)(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The type of the parameters in pf1 determines the type of the template argument for T. The template argument for T is int. It is an error if the template arguments cannot be determined from the function pointer type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">overloaded</span> <span class="n">versions</span> <span class="n">of</span> <span class="k">func</span><span class="p">;</span> <span class="n">each</span> <span class="n">takes</span> <span class="n">a</span> <span class="n">different</span> <span class="n">function</span> <span class="n">pointer</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="k">func</span><span class="p">(</span><span class="ne">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="k">func</span><span class="p">(</span><span class="ne">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">func</span><span class="p">(</span><span class="n">compare</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">which</span> <span class="n">instantiation</span> <span class="n">of</span> <span class="n">compare</span><span class="err">?</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can disambiguate the call to func by using explicit template arguments:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">explicitly</span> <span class="n">specify</span> <span class="n">which</span> <span class="n">version</span> <span class="n">of</span> <span class="n">compare</span> <span class="n">to</span> <span class="n">instantiate</span>
</span></span><span class="line"><span class="cl"><span class="k">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">);</span> <span class="o">//</span> <span class="n">passing</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="template-argument-deduction-and-references">Template Argument Deduction and References</h2>
<p>When a function parameter is an ordinary (lvalue) reference to a template type parameter (i.e., that has the form T&amp;), the binding rules say that we can pass only an lvalue (e.g., a variable or an expression that returns a reference type). That argument might or might not have a const type. If the argument is const, then T will be deduced as a const type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">argument</span> <span class="n">must</span> <span class="n">be</span> <span class="n">an</span> <span class="n">lvalue</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">calls</span> <span class="n">to</span> <span class="n">f1</span> <span class="n">use</span> <span class="n">the</span> <span class="n">referred</span><span class="o">-</span><span class="n">to</span> <span class="n">type</span> <span class="n">of</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">as</span> <span class="n">the</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">type</span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="o">//</span> <span class="n">i</span> <span class="n">is</span> <span class="n">an</span> <span class="ne">int</span><span class="p">;</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="o">//</span> <span class="n">ci</span> <span class="n">is</span> <span class="n">a</span> <span class="k">const</span> <span class="ne">int</span><span class="p">;</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">argument</span> <span class="n">to</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">parameter</span> <span class="n">must</span> <span class="n">be</span> <span class="n">an</span> <span class="n">lvalue</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If a function parameter has type const T&amp;, normal binding rules say that we can pass any kind of argument—an object (const or otherwise), a temporary, or a literal value. When the function parameter is itself const, the type deduced for T will not be a const type. The const is already part of the  function parameter type; therefore, it does not also become part of the  template parameter type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">can</span> <span class="n">take</span> <span class="n">an</span> <span class="n">rvalue</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">f2</span> <span class="n">is</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span> <span class="k">const</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">irrelevant</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="ow">in</span> <span class="n">each</span> <span class="n">of</span> <span class="n">these</span> <span class="n">three</span> <span class="n">calls</span><span class="p">,</span> <span class="n">f2</span><span class="s1">&#39;s function parameter is inferred as const int&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="o">//</span> <span class="n">i</span> <span class="n">is</span> <span class="n">an</span> <span class="ne">int</span><span class="p">;</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="o">//</span> <span class="n">ci</span> <span class="n">is</span> <span class="n">a</span> <span class="k">const</span> <span class="ne">int</span><span class="p">,</span> <span class="n">but</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">f2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="o">//</span> <span class="n">a</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">parameter</span> <span class="n">can</span> <span class="n">be</span> <span class="n">bound</span> <span class="n">to</span> <span class="n">an</span> <span class="n">rvalue</span><span class="p">;</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a function parameter is an rvalue reference (i.e., has the form T&amp;&amp;), normal binding rules say that we can pass an rvalue to this parameter. When we do so, type deduction behaves similarly to deduction for an ordinary lvalue reference function parameter. The deduced type for T is the type of the rvalue:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt; void f3(T&amp;&amp;);
</span></span><span class="line"><span class="cl">f3(42); // argument is an rvalue of type int; template parameter T is int
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="reference-collapsing-and-rvalue-reference-parameters">Reference Collapsing and Rvalue Reference Parameters</h2>
<p>Assuming i is an int object, we might think that a call such as f3(i) would be illegal. After all, i is an lvalue, and normally we cannot bind an rvalue reference to an lvalue. However, the language defines two exceptions to normal binding rules that allow this kind of usage. These exceptions are the foundation for how library facilities such as move operate.</p>
<p>The first exception affects how type deduction is done for rvalue reference parameters. When we pass an lvalue (e.g., i) to a function parameter that is an rvalue reference to a template type parameter (e.g, T&amp;&amp;), the compiler deduces the template type parameter as the argument’s lvalue reference type. So, when we call f3(i), the compiler deduces the type of T as int&amp;, not int. Deducing T as int&amp; would seem to mean that f3’s function parameter would be an rvalue reference to the type int&amp;. Ordinarily, we cannot (directly) define a reference to a reference. However, it is possible to do so indirectly through a type alias or through a template type parameter.</p>
<p>In such contexts, we see the second exception to the normal binding rules: If we indirectly create a reference to a reference, then those references “collapse.” In all but one case, the references collapse to form an ordinary lvalue reference type. The new standard, expanded the collapsing rules to include rvalue references. References collapse to form an rvalue reference only in the specific case of an rvalue reference to an rvalue reference. That is, for a given type X:</p>
<ul>
<li>X&amp; &amp;, X&amp; &amp;&amp;, and X&amp;&amp; &amp; all collapse to type X&amp;</li>
<li>The type X&amp;&amp; &amp;&amp; collapses to X&amp;&amp;</li>
</ul>
<p>Reference collapsing applies only when a reference to a reference is created indirectly, such as in a type alias or a template parameter.</p>
<p>The combination of the reference collapsing rule and the special rule for type deduction for rvalue reference parameters means that we can call f3 on an lvalue. When we pass an lvalue to f3’s (rvalue reference) function parameter, the compiler will deduce T as an lvalue reference type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">f3</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="o">//</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">an</span> <span class="n">lvalue</span><span class="p">;</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="ne">int</span><span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">f3</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="o">//</span> <span class="n">argument</span> <span class="n">is</span> <span class="n">an</span> <span class="n">lvalue</span><span class="p">;</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">T</span> <span class="n">is</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a  template parameter T is deduced as a reference type, the collapsing rule says that the  function parameter T&amp;&amp; collapses to an lvalue reference type. For example, the resulting instantiation for f3(i) would be something like</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// invalid code, for illustration purposes only
</span></span><span class="line"><span class="cl">void f3&lt;int&amp;&gt;(int&amp; &amp;&amp;); // when T is int&amp;, function parameter is int&amp; &amp;&amp;
</span></span></code></pre></td></tr></table>
</div>
</div><p>The function parameter in f3 is T&amp;&amp; and T is int&amp;, so T&amp;&amp; is int&amp; &amp;&amp;, which collapses to int&amp;. Thus, even though the form of the function parameter in f3 is an rvalue reference (i.e., T&amp;&amp;), this call instantiates f3 with an lvalue reference type (i.e., int&amp;):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void f3&lt;int&amp;&gt;(int&amp;); // when T is int&amp;, function parameter collapses to int&amp;
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are two important consequences from these rules:</p>
<ul>
<li>A function parameter that is an rvalue reference to a template type parameter (e.g., T&amp;&amp;) can be bound to an lvalue; and</li>
<li>If the argument is an lvalue, then the deduced template argument type will be an lvalue reference type and the function parameter will be instantiated as an (ordinary) lvalue reference parameter (T&amp;)</li>
</ul>
<p>It is also worth noting that by implication, we can pass any type of argument to a T&amp;&amp; function parameter. A parameter of such a type can (obviously) be used with rvalues, and as we’ve just seen, can be used by lvalues as well. An argument of any type can be passed to a function parameter that is an rvalue reference to a template parameter type (i.e., T&amp;&amp;). When an lvalue is passed to such a parameter, the function parameter is instantiated as an ordinary, lvalue reference (T&amp;).</p>
<p>The fact that the template parameter can be deduced to a reference type can have surprising impacts on the code inside the template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt; void f3(T&amp;&amp; val)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    T t = val; // copy or binding a reference?
</span></span><span class="line"><span class="cl">    t = fcn(t); // does the assignment change only t or val and t?
</span></span><span class="line"><span class="cl">    if (val == t) { /* ... */ } // always true if T is a reference type
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>In practice, rvalue reference parameters are used in one of two contexts: Either the template is forwarding its arguments, or the template is overloaded. For now, it’s worth noting that function templates that use rvalue references often use overloading in the same way as we saw in:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">binds</span> <span class="n">to</span> <span class="n">nonconst</span> <span class="n">rvalues</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">lvalues</span> <span class="ow">and</span> <span class="k">const</span> <span class="n">rvalues</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="understanding-stdmove">Understanding std::move</h2>
<p>Although we cannot directly bind an rvalue reference to an lvalue, we can use move to obtain an rvalue reference bound to an lvalue. Because move can take arguments of essentially any type, it should not be surprising that move is a function template. The standard defines move as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename T&gt;
</span></span><span class="line"><span class="cl">typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    return  static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>This code is short but subtle. First, move’s function parameter, T&amp;&amp;, is an rvalue reference to a template parameter type. Through reference collapsing, this parameter can match arguments of any type. In particular, we can pass either an lvalue or an rvalue to move:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string s1(&#34;hi!&#34;), s2;
</span></span><span class="line"><span class="cl">s2 = std::move(string(&#34;bye!&#34;)); // ok: moving from an rvalue
</span></span><span class="line"><span class="cl">s2 = std::move(s1); // ok: but after the assigment s1 has indeterminate value
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the first assignment, the argument to move is the rvalue result of the string constructor, string(&ldquo;bye&rdquo;). As we’ve seen, when we pass an rvalue to an rvalue reference function parameter, the type deduced from that argument is the referred-to type. Thus, in std::move(string(&ldquo;bye!&rdquo;)):</p>
<ul>
<li>The deduced type of T is string.</li>
<li>Therefore, remove_reference is instantiated with string.</li>
<li>The type member of remove_reference<string> is string.</li>
<li>The return type of move is string&amp;&amp;.</li>
<li>move’s function parameter, t, has type string&amp;&amp;.</li>
</ul>
<p>Accordingly, this call instantiates move<string>, which is the function</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string&amp;&amp; move(string &amp;&amp;t)
</span></span></code></pre></td></tr></table>
</div>
</div><p>The body of this function returns static_cast&lt;string&amp;&amp;&gt;(t). The type of t is already string&amp;&amp;, so the cast does nothing. Therefore, the result of this call is the rvalue reference it was given.</p>
<p>Now consider the second assignment, which calls std::move(s1). In this call, the argument to move is an lvalue. This time:</p>
<ul>
<li>The deduced type of T is string&amp; (reference to string, not plain string).</li>
<li>Therefore, remove_reference is instantiated with string&amp;.</li>
<li>The type member of remove_reference&lt;string&amp;&gt; is string.</li>
<li>The return type of move is still string&amp;&amp;.</li>
<li>move’s function parameter, t, instantiates as string&amp; &amp;&amp;, which collapses to string&amp;.</li>
</ul>
<p>Thus, this call instantiates move&lt;string&amp;&gt;, which is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string&amp;&amp; move(string &amp;t)
</span></span></code></pre></td></tr></table>
</div>
</div><p>The body of this instantiation returns <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>. In this case, the type of t is string&amp;, which the cast converts to string&amp;&amp;.</p>
<p>Ordinarily, a <code>static_cast</code> can perform only otherwise legitimate conversions. However, there is again a special dispensation for rvalue references: Even though we cannot implicitly convert an lvalue to an rvalue reference, we can explicitly cast an lvalue to an rvalue reference using <code>static_cast</code>.</p>
<p>clobber: (Programming) To make a change or a call in a program which unintentionally overwrites the current value of a variable.
RAII: Resource Acquisition Is Initialization, use destructor to free memory when there is an exception, so C++ do not need GC.</p>
<p>Binding an rvalue reference to an lvalue gives code that operates on the rvalue reference permission to clobber the lvalue. There are times, such as in our StrVec reallocate function, when we know it is safe to clobber an lvalue. By letting us do the cast, the language allows this usage. By  forcing us to use a cast, the language tries to prevent us from doing so accidentally. Finally, although we can write such casts directly, it is much easier to use the library move function. Moreover, using std::move consistently makes it easy to find the places in our code that might potentially clobber lvalues.</p>
<h2 id="forwarding">Forwarding</h2>
<p>Some functions need to forward one or more of their arguments with their types unchanged to another, forwarded-to, function. In such cases, we need to preserve everything about the forwarded arguments, including whether or not the argument type is const, and whether the argument is an lvalue or an rvalue. As an example, we’ll write a function that takes a callable expression and two additional arguments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">template</span> <span class="n">that</span> <span class="n">takes</span> <span class="n">a</span> <span class="n">callable</span> <span class="ow">and</span> <span class="n">two</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="ow">and</span> <span class="n">calls</span> <span class="n">the</span> <span class="n">given</span> <span class="n">callable</span> <span class="n">with</span> <span class="n">the</span> <span class="n">parameters</span> <span class="s1">&#39;&#39;</span><span class="n">flipped</span><span class="s1">&#39;&#39;</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">flip1</span> <span class="n">is</span> <span class="n">an</span> <span class="n">incomplete</span> <span class="n">implementation</span><span class="p">:</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="k">const</span> <span class="ow">and</span> <span class="n">references</span> <span class="n">are</span> <span class="n">lost</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">F</span><span class="p">,</span> <span class="n">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="n">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">flip1</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">f</span><span class="p">(</span><span class="ne">int</span> <span class="n">v1</span><span class="p">,</span> <span class="ne">int</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="o">//</span> <span class="n">note</span> <span class="n">v2</span> <span class="n">is</span> <span class="n">a</span> <span class="n">reference</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="o">//</span> <span class="n">f</span> <span class="n">changes</span> <span class="n">its</span> <span class="n">argument</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl"><span class="n">flip1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="o">//</span> <span class="n">f</span> <span class="n">called</span> <span class="n">through</span> <span class="n">flip1</span> <span class="n">leaves</span> <span class="n">j</span> <span class="n">unchanged</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The problem is that j is passed to the t1 parameter in flip1. That parameter has is a plain, nonreference type, int, not an int&amp;.</p>
<p>To pass a reference through our flip function, we need to rewrite our function so that its parameters preserve the “lvalueness” of its given arguments. Thinking ahead a bit, we can imagine that we’d also like to preserve the constness of the arguments as well. We can preserve all the type information in an argument by defining its corresponding function parameter as an rvalue reference to a template type parameter. Using a reference parameter (either lvalue or rvalue) lets us preserve constness, because the const in a reference type is low-level. Through reference collapsing, if we define the function parameters as T1&amp;&amp; and T2&amp;&amp;, we can preserve the lvalue/rvalue property of flip’s arguments:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename F, typename T1, typename T2&gt;
</span></span><span class="line"><span class="cl">void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    f(t2, t1);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>This version of flip2 solves one half of our problem. Our flip2 function works fine for functions that take lvalue references but cannot be used to call a function that has an rvalue reference parameter. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void g(int &amp;&amp;i, int&amp; j)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    cout &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; j &lt;&lt; endl;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">flip2(g, i, 42); // error: can&#39;t initialize int&amp;&amp; from an lvalue
</span></span></code></pre></td></tr></table>
</div>
</div><p>what is passed to g will be the parameter named t2 inside flip2. A function parameter, like any other variable, is an lvalue expression. As a result, the call to g in flip2 passes an lvalue to g’s rvalue reference parameter.</p>
<p>We can use a new library facility named <code>forward</code> to pass flip2’s parameters in a way that preserves the types of the original arguments. Like move, forward is defined in the utility header. Unlike move, forward must be called with an explicit template argument. forward returns an rvalue reference to that explicit argument type. That is, the return type of forward<T> is T&amp;&amp;.</p>
<p>Ordinarily, we use forward to pass a function parameter that is defined as an rvalue reference to a template type parameter. Through reference collapsing on its return type, forward preserves the lvalue/rvalue nature of its given argument:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename Type&gt; intermediary(Type &amp;&amp;arg)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    finalFcn(std::forward&lt;Type&gt;(arg));
</span></span><span class="line"><span class="cl">    // ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>If that argument was an rvalue, then Type is an ordinary (nonreference) type and forward<Type> will return Type&amp;&amp;. If the argument was an lvalue, then—through reference collapsing—Type itself is an lvalue reference type. In this case, the return type is an rvalue reference to an lvalue reference type. Again through reference collapsing—this time on the return type—forward<Type> will return an lvalue reference type. Using forward, we’ll rewrite our flip function once more:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;typename F, typename T1, typename T2&gt;
</span></span><span class="line"><span class="cl">void flip(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    f(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>If we call flip(g, i, 42), i will be passed to g as an int&amp; and 42 will be passed as an int&amp;&amp;.</p>
<h2 id="overloading-and-templates">Overloading and Templates</h2>
<p>Function templates can be overloaded by other templates or by ordinary, nontemplate functions. As usual, functions with the same name must differ either as to the number or the type(s) of their parameters.</p>
<ul>
<li>
<p>The candidate functions for a call include any function-template instantiation for which template argument deduction succeeds.</p>
</li>
<li>
<p>The candidate function templates are always viable, because template argument deduction will have eliminated any templates that are not viable.</p>
</li>
<li>
<p>As usual, the viable functions (template and nontemplate) are ranked by the conversions, if any, needed to make the call. Of course, the conversions used to call a function template are quite limited.</p>
</li>
<li>
<p>Also as usual, if exactly one function provides a better match than any of the others, that function is selected. However, if there are several functions that provide an equally good match, then:</p>
</li>
<li>
<p>If there is only one nontemplate function in the set of equally good matches, the nontemplate function is called.</p>
</li>
<li>
<p>If there are no nontemplate functions in the set, but there are multiple function templates, and one of these templates is more specialized than any of the others, the more specialized function template is called.</p>
</li>
<li>
<p>Otherwise, the call is ambiguous.</p>
</li>
</ul>
<h2 id="writing-overloaded-templates">Writing Overloaded Templates</h2>
<p>As an example, we’ll build a set of functions that might be useful during debugging.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="nb">print</span> <span class="n">any</span> <span class="n">type</span> <span class="n">we</span> <span class="n">don</span><span class="s1">&#39;t otherwise handle</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ostringstream</span> <span class="n">ret</span><span class="p">;</span> <span class="o">//</span> <span class="n">see</span> <span class="err">§</span> <span class="mf">8.3</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span> <span class="mi">321</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">T</span><span class="s1">&#39;s output operator to print a representation of t</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">str</span><span class="p">();</span> <span class="o">//</span> <span class="k">return</span> <span class="n">a</span> <span class="n">copy</span> <span class="n">of</span> <span class="n">the</span> <span class="n">string</span> <span class="n">to</span> <span class="n">which</span> <span class="n">ret</span> <span class="n">is</span> <span class="n">bound</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This function can be used to generate a string corresponding to an object of any type that has an output operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// print pointers as their pointer value, followed by the object to which the pointer points
</span></span><span class="line"><span class="cl">// NB: this function will not work properly with char*;
</span></span><span class="line"><span class="cl">template &lt;typename T&gt; string debug_rep(T *p)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    ostringstream ret;
</span></span><span class="line"><span class="cl">    ret &lt;&lt; &#34;pointer: &#34; &lt;&lt; p; // print the pointer&#39;s own value
</span></span><span class="line"><span class="cl">    if (p)
</span></span><span class="line"><span class="cl">        ret &lt;&lt; &#34; &#34; &lt;&lt; debug_rep(*p); // print the value to which p points
</span></span><span class="line"><span class="cl">    else
</span></span><span class="line"><span class="cl">        ret &lt;&lt; &#34; null pointer&#34;; // or indicate that the p is null
</span></span><span class="line"><span class="cl">    return ret.str(); // return a copy of the string to which ret is bound
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>This version generates a string that contains the pointer’s own value and calls debug_rep to print the object to which that pointer points. Note that this function can’t be used to print character pointers, because the IO library defines a version of the &laquo; for char* values. That version of &laquo; assumes the pointer denotes a null-terminated character array, and prints the contents of the array, not its address.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string s(&#34;hi&#34;);
</span></span><span class="line"><span class="cl">cout &lt;&lt; debug_rep(s) &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><p>For this call, only the first version of debug_rep is viable. The second version of debug_rep requires a pointer parameter, and in this call we passed a nonpointer object. If we call debug_rep with a pointer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><p>both functions generate viable instantiations:</p>
<ul>
<li>debug_rep(const string* &amp;), which is the instantiation of the first version of debug_rep with T bound to string*</li>
<li>debug_rep(string*), which is the instantiation of the second version of debug_rep with T bound to string</li>
</ul>
<p>The instantiation of the second version of debug_rep is an exact match for this call. The instantiation of the first version requires a conversion of the plain pointer to a pointer to const. Normal function matching says we should prefer the second template, and indeed that is the one that is run.</p>
<h2 id="multiple-viable-templates">Multiple Viable Templates</h2>
<p>As another example, consider the following call:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here both templates are viable and both provide an exact match:</p>
<ul>
<li>debug_rep(const string* &amp;), the instantiation of the first version of the template with T bound to const string*</li>
<li>debug_rep(const string*), the instantiation of the second version of the template with T bound to const string</li>
</ul>
<p>In this case, normal function matching can’t distinguish between these two calls. We might expect this call to be ambiguous. However, due to the special rule for overloaded function templates, this call resolves to debug_rep(T*), which is the more specialized template.</p>
<p>The reason for this rule is that without it, there would be no way to call the pointer version of debug_rep on a pointer to const. The problem is that the template debug_rep(const T&amp;) can be called on essentially any type, including pointer types. That template is more general than debug_rep(T*), which can be called only on pointer types. Without this rule, calls that passed pointers to const would always be ambiguous. When there are several overloaded templates that provide an equally good match for a call, the most specialized version is preferred.</p>
<h2 id="nontemplate-and-template-overloads">Nontemplate and Template Overloads</h2>
<p>For our next example, we’ll define an ordinary nontemplate version of debug_rep to print strings inside double quotes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="nb">print</span> <span class="n">strings</span> <span class="n">inside</span> <span class="n">double</span> <span class="n">quotes</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s1">&#39;&#34;&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;&#34;&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Now, when we call debug_rep on a string,</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string s(&#34;hi&#34;);
</span></span><span class="line"><span class="cl">cout &lt;&lt; debug_rep(s) &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><p>there are two equally good viable functions:</p>
<ul>
<li>debug_rep<string>(const string&amp;), the first template with T bound to string</li>
<li>debug_rep(const string&amp;), the ordinary, nontemplate function</li>
</ul>
<p>In this case, both functions have the same parameter list, so obviously, each function provides an equally good match for this call. However, the nontemplate version is selected. For the same reasons that the most specialized of equally good function templates is preferred, a nontemplate function is preferred over equally good match(es) to a function template.</p>
<h2 id="overloaded-templates-and-conversions">Overloaded Templates and Conversions</h2>
<p>There’s one case we haven’t covered so far: pointers to C-style character strings and string literals. Now that we have a version of debug_rep that takes a string, we might expect that a call that passes character strings would match that version. However, consider this call:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cout &lt;&lt; debug_rep(&#34;hi world!&#34;) &lt;&lt; endl; // calls debug_rep(T*)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here all three of the debug_rep functions are viable:</p>
<ul>
<li>debug_rep(const T&amp;), with T bound to char[10]</li>
<li>debug_rep(T*), with T bound to const char</li>
<li>debug_rep(const string&amp;), which requires a conversion from const char* to string</li>
</ul>
<p>Both templates provide an exact match to the argument—the second template requires a (permissible) conversion from array to pointer, and that conversion is considered as an exact match for function-matching purposes. As before, the T* version is more specialized and is the one that will be selected.</p>
<p>If we want to handle character pointers as strings, we can define two more nontemplate overloads:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="nb">convert</span> <span class="n">the</span> <span class="n">character</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">string</span> <span class="ow">and</span> <span class="n">call</span> <span class="n">the</span> <span class="n">string</span> <span class="n">version</span> <span class="n">of</span> <span class="n">debug_rep</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="missing-declarations-can-cause-the-program-to-misbehave">Missing Declarations Can Cause the Program to Misbehave</h2>
<p>It is worth noting that for the char* versions of debug_rep to work correctly, a declaration for debug_rep(const string&amp;) must be in scope when these functions are defined. If not, the wrong version of debug_rep will be called:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-zed" data-lang="zed"><span class="line"><span class="cl"><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">debug_rep</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">typename</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">debug_rep</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// the following declaration must be in scope
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// for the definition of debug_rep(char*) to do the right thing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">string</span><span class="w"> </span><span class="n">debug_rep</span><span class="p">(</span><span class="n">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">string</span><span class="w"> </span><span class="n">debug_rep</span><span class="p">(</span><span class="n">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// if the declaration for the version that takes a const string&amp; is not in scope
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// the return will call debug_rep(const T&amp;) with T instantiated to string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Ordinarily, if we use a function that we forgot to declare, our code won’t compile. Not so with functions that overload a template function. If the compiler can instantiate the call from the template, then the missing declaration won’t matter. In this example, if we forget to declare the version of debug_rep that takes a string, the compiler will silently instantiate the template version that takes a const T&amp;.</p>
<p>Declare every function in an overload set before you define any of the functions. That way you don’t have to worry whether the compiler will instantiate a call before it sees the function you intended to call.</p>
<h2 id="variadic-templates">Variadic Templates</h2>
<p>A <strong>variadic template</strong> is a template function or class that can take a varying number of parameters. The varying parameters are known as a <strong>parameter pack</strong>. There are two kinds of parameter packs: A template parameter pack represents zero or more template parameters, and a function parameter pack represents zero or more function parameters.</p>
<p>We use an ellipsis to indicate that a template or function parameter represents a pack. In a template parameter list, class&hellip; or typename&hellip; indicates that the following parameter represents a list of zero or more types; the name of a type followed by an ellipsis represents a list of zero or more nontype parameters of the given type. In the function parameter list, a parameter whose type is a template parameter pack is a function parameter pack. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Args</span> <span class="n">is</span> <span class="n">a</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">pack</span><span class="p">;</span> <span class="n">rest</span> <span class="n">is</span> <span class="n">a</span> <span class="n">function</span> <span class="n">parameter</span> <span class="n">pack</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">Args</span> <span class="n">represents</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">template</span> <span class="n">type</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">rest</span> <span class="n">represents</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">function</span> <span class="n">parameters</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">typename</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="o">...</span> <span class="n">rest</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>declares that foo is a variadic function that has one type parameter named T and a template parameter pack named Args. As usual, the compiler deduces the template parameter types from the function’s arguments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 0; double d = 3.14; string s = &#34;how now brown cow&#34;;
</span></span><span class="line"><span class="cl">foo(i, s, 42, d); // three parameters in the pack
</span></span><span class="line"><span class="cl">foo(s, 42, &#34;hi&#34;); // two parameters in the pack
</span></span><span class="line"><span class="cl">foo(d, s); // one parameter in the pack
</span></span><span class="line"><span class="cl">foo(&#34;hi&#34;); // empty pack
</span></span></code></pre></td></tr></table>
</div>
</div><p>the compiler will instantiate four different instances of foo:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">double</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">double</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we need to know how many elements there are in a pack, we can use the sizeof&hellip; operator. Like sizeof, sizeof&hellip; returns a constant expression and does not evaluate its argument:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template&lt;typename ... Args&gt; void g(Args ... args) {
</span></span><span class="line"><span class="cl">    cout &lt;&lt; sizeof...(Args) &lt;&lt; endl; // number of type parameters
</span></span><span class="line"><span class="cl">    cout &lt;&lt; sizeof...(args) &lt;&lt; endl; // number of function parameters
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can use an initializer_list to define a function that can take a varying number of arguments. However, the arguments must have the same type (or types that are convertible to a common type). Variadic functions are used when we know neither the number nor the types of the arguments we want to process. As an example, we’ll define a function like our earlier error_msg function, only this time we’ll allow the argument types to vary as well.</p>
<p>Variadic functions are often recursive. The first call processes the first argument in the pack and calls itself on the remaining arguments. Our print function will execute this way—each call will print its second argument on the stream denoted by its first argument.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">function</span> <span class="n">to</span> <span class="n">end</span> <span class="n">the</span> <span class="n">recursion</span> <span class="ow">and</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">this</span> <span class="n">function</span> <span class="n">must</span> <span class="n">be</span> <span class="n">declared</span> <span class="n">before</span> <span class="n">the</span> <span class="n">variadic</span> <span class="n">version</span> <span class="n">of</span> <span class="nb">print</span> <span class="n">is</span> <span class="n">defined</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="nb">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="o">//</span> <span class="n">no</span> <span class="n">separator</span> <span class="n">after</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">pack</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">this</span> <span class="n">version</span> <span class="n">of</span> <span class="nb">print</span> <span class="n">will</span> <span class="n">be</span> <span class="n">called</span> <span class="k">for</span> <span class="n">all</span> <span class="n">but</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">pack</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">typename</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="nb">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;, &#34;</span><span class="p">;</span> <span class="o">//</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">first</span> <span class="n">argument</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="o">...</span><span class="p">);</span> <span class="o">//</span> <span class="n">recursive</span> <span class="n">call</span><span class="p">;</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">other</span> <span class="n">arguments</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>For the last call of print in the recursion, the variadic version is also viable. Unlike an ordinary argument, a parameter pack can be empty. However, a nonvariadic template is more specialized than a variadic template, so the nonvariadic version is chosen for this call.</p>
<h2 id="pack-expansion">Pack Expansion</h2>
<p>When we expand a pack, we also provide a pattern to be used on each expanded element. Expanding a pack separates the pack into its constituent elements, applying the pattern to each element as it does so. We trigger an expansion by putting an ellipsis (. . . ) to the right of the pattern.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">typename</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;...</span> <span class="n">rest</span><span class="p">)</span><span class="o">//</span> <span class="n">expand</span> <span class="n">Args</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;, &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="o">...</span><span class="p">);</span> <span class="o">//</span> <span class="n">expand</span> <span class="n">rest</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first expansion expands the template parameter pack and generates the function parameter list for print. The second expansion appears in the call to print. That pattern generates the argument list for the call to print.</p>
<p>The expansion of the function parameter pack in print just expanded the pack into its constituent parts. More complicated patterns are also possible when we expand a function parameter pack. For example, we might write a second variadic function that calls debug_rep on each of its arguments and then calls print to print the resulting strings:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">call</span> <span class="n">debug_rep</span> <span class="n">on</span> <span class="n">each</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">call</span> <span class="n">to</span> <span class="nb">print</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">errorMsg</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">a2</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">an</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span><span class="o">...</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The call to print uses the pattern debug_rep(rest). That pattern says that we want to call debug_rep on each element in the function parameter pack rest. The resulting expanded pack will be a comma-separated list of calls to debug_rep. That is, a call such as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">errorMsg(cerr,  fcnName,  code.num(),  otherData,  &#34;other&#34;, item);
</span></span></code></pre></td></tr></table>
</div>
</div><p>will execute as if we had written</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print(cerr, debug_rep(fcnName), debug_rep(code.num()),
</span></span><span class="line"><span class="cl">    debug_rep(otherData), debug_rep(&#34;otherData&#34;), debug_rep(item));
</span></span></code></pre></td></tr></table>
</div>
</div><p>In contrast, the following pattern would fail to compile:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))
</span></span><span class="line"><span class="cl">print(os, debug_rep(rest...)); // error: no matching function to call
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="forwarding-parameter-packs">Forwarding Parameter Packs</h2>
<p>Under the new standard, we can use variadic templates together with forward to write functions that pass their arguments unchanged to some other function. To illustrate such functions, we’ll add an emplace_back member to our StrVec class. The emplace_back member of the library containers is a variadic member template that uses its arguments to construct an element directly in space managed by the container.</p>
<p>Our version of emplace_back for StrVec will also have to be variadic, because string has a number of constructors that differ in terms of their parameters. Because we’d like to be able to use the string move constructor, we’ll also need to preserve all the type information about the arguments passed to emplace_back.</p>
<p>As we’ve seen, preserving type information is a two-step process. First, to preserve type information in the arguments, we must define emplace_back’s function parameters as rvalue references to a template type parameter:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class StrVec {
</span></span><span class="line"><span class="cl">public:
</span></span><span class="line"><span class="cl">    template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;...);
</span></span><span class="line"><span class="cl">    // remaining members as in § 13.5 (p. 526)
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>The pattern in the expansion of the template parameter pack, &amp;&amp;, means that each function parameter will be an rvalue reference to its corresponding argument.</p>
<p>Second, we must use forward to preserve the arguments’ original types when emplace_back passes those arguments to construct:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">inline</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">StrVec</span><span class="p">::</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;...</span> <span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">chk_n_alloc</span><span class="p">();</span> <span class="o">//</span> <span class="n">reallocates</span> <span class="n">the</span> <span class="n">StrVec</span> <span class="k">if</span> <span class="n">necessary</span>
</span></span><span class="line"><span class="cl">    <span class="n">alloc</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">...</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By using forward in this call, we guarantee that if emplace_back is called with an rvalue, then construct will also get an rvalue. For example, in this call:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">svec</span><span class="o">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">);</span> <span class="o">//</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">move</span> <span class="n">constructor</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>the argument to emplace_back is an rvalue, which is passed to construct as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">std::forward&lt;string&gt;(string(&#34;the end&#34;))
</span></span></code></pre></td></tr></table>
</div>
</div><p>The result type from forward<string> is string&amp;&amp;, so construct will be called with an rvalue reference.</p>
<h2 id="template-specializations">Template Specializations</h2>
<p>In some cases, the general template definition is simply wrong for a type: The general definition might not compile or might do the wrong thing. When we can’t (or don’t want to) use the template version, we can define a specialized version of the class or function template.</p>
<p>Our compare function is a good example of a function template for which the general definition is not appropriate for a particular type, namely, character pointers. We’d like <code>compare</code> to compare character pointers by calling strcmp rather than by comparing the pointer values.  Indeed, we have already overloaded the compare function to handle character string literals:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">first</span> <span class="n">version</span><span class="p">;</span> <span class="n">can</span> <span class="n">compare</span> <span class="n">any</span> <span class="n">two</span> <span class="n">types</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">second</span> <span class="n">version</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">string</span> <span class="n">literals</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">M</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="n">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">M</span><span class="p">]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>However, the version of compare that has two nontype template parameters will be called only when we pass a string literal or an array. If we call compare with character pointers, the first version of the template will be called:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="s2">&#34;mom&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">compare</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">the</span> <span class="n">first</span> <span class="n">template</span>
</span></span><span class="line"><span class="cl"><span class="n">compare</span><span class="p">(</span><span class="s2">&#34;hi&#34;</span><span class="p">,</span> <span class="s2">&#34;mom&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="n">calls</span> <span class="n">the</span> <span class="n">template</span> <span class="n">with</span> <span class="n">two</span> <span class="n">nontype</span> <span class="n">parameters</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There is no way to convert a pointer to a reference to an array, so the second version of compare is not viable when we pass p1 and p2 as arguments. To handle character pointers (as opposed to arrays), we can define a <strong>template
specialization</strong> of the first version of compare. A specialization is a separate definition of the template in which one or more template parameters are specified to have particular types.</p>
<p>When we specialize a function template, we must supply arguments for every template parameter in the original template. To indicate that we are specializing a template, we use the keyword template followed by an empty pair of angle brackets (&lt; &gt;). The empty brackets indicate that arguments will be supplied for all the template parameters of the original template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">special</span> <span class="n">version</span> <span class="n">of</span> <span class="n">compare</span> <span class="n">to</span> <span class="n">handle</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">character</span> <span class="n">arrays</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;&gt;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we define a specialization, the function parameter type(s) must match the corresponding types in a previously declared template. Here we are specializing:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="ne">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>in which the function parameters are references to a const type. As with type aliases, the interaction between template parameter types, pointers, and const can be surprising. We want to define a specialization of this function with T as const char*. Our function requires a reference to the const version of this type. The const version of a pointer type is a constant pointer as distinct from a pointer to const. The type we need to use in our specialization is const char* const &amp;, which is a reference to a const pointer to const char.</p>
<h2 id="function-overloading-versus-template-specializations">Function Overloading versus Template Specializations</h2>
<p>When we define a function template specialization, we are essentially taking over the job of the compiler. That is, we are supplying the definition to use for a specific instantiation of the original template. It is important to realize that a specialization is an instantiation; it is not an overloaded instance of the function name. Specializations instantiate a template; they do not overload it. As a result, specializations do not affect function matching. Whether we define a particular function as a specialization or as an independent, nontemplate function can impact function matching. For example, we have defined two versions of our compare function template, one that takes references to array parameters and the other that takes const T&amp;. The fact that we also have a specialization for character pointers has no impact on function matching.</p>
<p>In order to specialize a template, a declaration for the original template must be in scope. Moreover, a declaration for a specialization must be in scope before any code uses that instantiation of the template. With ordinary classes and functions, missing declarations are (usually) easy to find—the compiler won’t be able to process our code. However, if a specialization declaration is missing, the compiler will usually generate code using the original template.</p>
<p>It is an error for a program to use a specialization and an instantiation of the original template with the same set of template arguments. However, it is an error that the compiler is unlikely to detect.</p>
<p>Templates and their specializations should be declared in the same header file. Declarations for all the templates with a given name should appear first, followed by any specializations of those templates.</p>
<h2 id="class-template-specializations">Class Template Specializations</h2>
<p>In addition to specializing function templates, we can also specialize class templates. As an example, we’ll define a specialization of the library hash template that we can use to store Sales_data objects in an unordered container. By default, the unordered containers use hash&lt;key_type&gt; to organize their elements. To use this default with our own data type, we must define a specialization of the hash template. A specialized hash class must define</p>
<ul>
<li>An overloaded call operator that returns a size_t and takes an object of the container’s key type</li>
<li>Two type members, result_type and argument_type, which are the return and argument types, respectively, of the call operator</li>
<li>The default constructor and a copy-assignment operator (which can be implicitly defined)</li>
</ul>
<p>The only complication in defining this hash specialization is that when we specialize a template, we must do so in the same namespace in which the original template is defined. For now, what we need to know is that we can add members to a namespace. To do so, we must first open the namespace:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// open the std namespace so we can specialize std::hash
</span></span><span class="line"><span class="cl">namespace std {
</span></span><span class="line"><span class="cl">} // close the std namespace; note: no semicolon after the close curly
</span></span></code></pre></td></tr></table>
</div>
</div><p>Any definitions that appear between the open and close curlies will be part of the std namespace. The following defines a specialization of hash for Sales_data:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">open</span> <span class="n">the</span> <span class="n">std</span> <span class="n">namespace</span> <span class="n">so</span> <span class="n">we</span> <span class="n">can</span> <span class="n">specialize</span> <span class="n">std</span><span class="p">::</span><span class="nb">hash</span>
</span></span><span class="line"><span class="cl"><span class="n">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;&gt;</span> <span class="o">//</span> <span class="n">we</span><span class="s1">&#39;re defining a specialization with</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="nb">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span> <span class="o">//</span> <span class="n">the</span> <span class="n">template</span> <span class="n">parameter</span> <span class="n">of</span> <span class="n">Sales_data</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">the</span> <span class="n">type</span> <span class="n">used</span> <span class="n">to</span> <span class="nb">hash</span> <span class="n">an</span> <span class="n">unordered</span> <span class="n">container</span> <span class="n">must</span> <span class="n">define</span> <span class="n">these</span> <span class="n">types</span>
</span></span><span class="line"><span class="cl">    <span class="n">typedef</span> <span class="n">size_t</span> <span class="n">result_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">typedef</span> <span class="n">Sales_data</span> <span class="n">argument_type</span><span class="p">;</span> <span class="o">//</span> <span class="n">by</span> <span class="n">default</span><span class="p">,</span> <span class="n">this</span> <span class="n">type</span> <span class="n">needs</span> <span class="o">==</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">our</span> <span class="k">class</span> <span class="n">uses</span> <span class="n">synthesized</span> <span class="n">copy</span> <span class="n">control</span> <span class="ow">and</span> <span class="n">default</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nb">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span><span class="p">::</span><span class="n">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="o">.</span><span class="n">bookNo</span><span class="p">)</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">    <span class="nb">hash</span><span class="o">&lt;</span><span class="n">unsigned</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="o">.</span><span class="n">units_sold</span><span class="p">)</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">    <span class="nb">hash</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="o">.</span><span class="n">revenue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">//</span> <span class="n">close</span> <span class="n">the</span> <span class="n">std</span> <span class="n">namespace</span><span class="p">;</span> <span class="n">note</span><span class="p">:</span> <span class="n">no</span> <span class="n">semicolon</span> <span class="n">after</span> <span class="n">the</span> <span class="n">close</span> <span class="n">curly</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Assuming our specialization is in scope, it will be used automatically when we use Sales_data as a key to one of these containers:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// uses hash&lt;Sales_data&gt; and Sales_data operator==
</span></span><span class="line"><span class="cl">unordered_multiset&lt;Sales_data&gt; SDset;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Because hash&lt;Sales_data&gt; uses the private members of Sales_data, we must make this class a friend of Sales_data:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">template &lt;class T&gt; class std::hash; // needed for the friend declaration
</span></span><span class="line"><span class="cl">class Sales_data {
</span></span><span class="line"><span class="cl">friend class std::hash&lt;Sales_data&gt;;
</span></span><span class="line"><span class="cl">    // other members as before
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>To enable users of Sales_data to use the specialization of hash, we should define this specialization in the Sales_data header.</p>
<h2 id="class-template-partial-specializations">Class-Template Partial Specializations</h2>
<p>Differently from function templates, a class template specialization does not have to supply an argument for every template parameter. We can specify some, but not all, of the template parameters or some, but not all, aspects of the parameters. A class template <strong>partial specialization</strong> is itself a template. Users must supply arguments for those template parameters that are not fixed by the specialization. We can partially specialize only a class template. We cannot partially specialize a function template.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// original, most general template
</span></span><span class="line"><span class="cl">template &lt;class T&gt; struct remove_reference 
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    typedef T type;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">// partial specializations that will be used for lvalue and rvalue references
</span></span><span class="line"><span class="cl">template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; // lvalue references
</span></span><span class="line"><span class="cl">{ 
</span></span><span class="line"><span class="cl">    typedef T type;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; // rvalue references
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">    typedef T type;
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>The template parameter list of a partial specialization is a subset of, or a specialization of, the parameter list of the original template.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i;
</span></span><span class="line"><span class="cl">// decltype(42) is int, uses the original template
</span></span><span class="line"><span class="cl">remove_reference&lt;decltype(42)&gt;::type a;
</span></span><span class="line"><span class="cl">// decltype(i) is int&amp;, uses first (T&amp;) partial specialization
</span></span><span class="line"><span class="cl">remove_reference&lt;decltype(i)&gt;::type b;
</span></span><span class="line"><span class="cl">// decltype(std::move(i)) is int&amp;&amp;, uses second (i.e., T&amp;&amp;) partial specialization
</span></span><span class="line"><span class="cl">remove_reference&lt;decltype(std::move(i))&gt;::type c;
</span></span></code></pre></td></tr></table>
</div>
</div><p>All three variables, a, b, and c, have type int.</p>
<h2 id="specializing-members-but-not-the-class">Specializing Members but Not the Class</h2>
<p>Rather than specializing the whole template, we can specialize just specific member function(s). For example, if Foo is a template class with a member Bar, we can specialize just that member:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">struct</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">()):</span> <span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">void</span> <span class="n">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="n">other</span> <span class="n">members</span> <span class="n">of</span> <span class="n">Foo</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;&gt;</span> <span class="o">//</span> <span class="n">we</span><span class="s1">&#39;re specializing a template</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Bar</span><span class="p">()</span> <span class="o">//</span> <span class="n">we</span><span class="s1">&#39;re specializing the Bar member of Foo&lt;int&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">//</span> <span class="k">do</span> <span class="n">whatever</span> <span class="n">specialized</span> <span class="n">processing</span> <span class="n">that</span> <span class="n">applies</span> <span class="n">to</span> <span class="n">ints</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here we are specializing just one member of the Foo<int> class. The other members of Foo<int> will be supplied by the Foo template:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Foo&lt;string&gt; fs; // instantiates Foo&lt;string&gt;::Foo()
</span></span><span class="line"><span class="cl">fs.Bar(); // instantiates Foo&lt;string&gt;::Bar()
</span></span><span class="line"><span class="cl">Foo&lt;int&gt; fi; // instantiates Foo&lt;int&gt;::Foo()
</span></span><span class="line"><span class="cl">fi.Bar(); // uses our specialization of Foo&lt;int&gt;::Bar()
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">huijian142857</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2015-10-08
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cpp/">cpp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/other_hexo/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">使用Hexo来构建静态博客</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/cpp_primer_part_1_2/">
            <span class="next-text nav-default">C&#43;&#43; Primer 第五版 学习笔记 Part I and II</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://gitee.com/huijian142857" class="iconfont icon-github" title="github"></a>
  <a href="https://huijian142857.gitee.io/post/cpp_primer_part_3/" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>huijian142857</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
