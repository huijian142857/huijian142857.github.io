<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Primer 第五版 学习笔记 Part I and II - 挥剑对风尘</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="huijian142857" /><meta name="description" content="基础部分 A stream is a sequence of characters read from or written to an IO device. To handle input, we use an object of type istream named cin; for output, ostream named cout. Also, cerr, clog. All the names defined by standard library are in the std namespace. The value returned from main is a status indicator. A nonzero has a meaning defined by system. The &amp;laquo;" /><meta name="keywords" content="Hugo, even" />






<meta name="generator" content="Hugo 0.128.2 with theme even" />


<link rel="canonical" href="https://huijian142857.gitee.io/post/cpp_primer_part_1_2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:url" content="https://huijian142857.gitee.io/post/cpp_primer_part_1_2/">
  <meta property="og:site_name" content="挥剑对风尘">
  <meta property="og:title" content="C&#43;&#43; Primer 第五版 学习笔记 Part I and II">
  <meta property="og:description" content="基础部分 A stream is a sequence of characters read from or written to an IO device. To handle input, we use an object of type istream named cin; for output, ostream named cout. Also, cerr, clog. All the names defined by standard library are in the std namespace. The value returned from main is a status indicator. A nonzero has a meaning defined by system. The «">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2015-09-28T18:38:00+00:00">
    <meta property="article:modified_time" content="2015-09-28T18:38:00+00:00">
    <meta property="article:tag" content="Cpp">

  <meta itemprop="name" content="C&#43;&#43; Primer 第五版 学习笔记 Part I and II">
  <meta itemprop="description" content="基础部分 A stream is a sequence of characters read from or written to an IO device. To handle input, we use an object of type istream named cin; for output, ostream named cout. Also, cerr, clog. All the names defined by standard library are in the std namespace. The value returned from main is a status indicator. A nonzero has a meaning defined by system. The «">
  <meta itemprop="datePublished" content="2015-09-28T18:38:00+00:00">
  <meta itemprop="dateModified" content="2015-09-28T18:38:00+00:00">
  <meta itemprop="wordCount" content="29661">
  <meta itemprop="keywords" content="Cpp">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="C&#43;&#43; Primer 第五版 学习笔记 Part I and II">
  <meta name="twitter:description" content="基础部分 A stream is a sequence of characters read from or written to an IO device. To handle input, we use an object of type istream named cin; for output, ostream named cout. Also, cerr, clog. All the names defined by standard library are in the std namespace. The value returned from main is a status indicator. A nonzero has a meaning defined by system. The «">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">挥剑对风尘</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">挥剑对风尘</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Primer 第五版 学习笔记 Part I and II</h1>

      <div class="post-meta">
        <span class="post-time"> 2015-09-28 </span>
        <div class="post-category">
            <a href="/categories/cpp/"> cpp </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基础部分">基础部分</a></li>
        <li><a href="#变量和类型">变量和类型</a></li>
        <li><a href="#strings-vectors-arrays">Strings, Vectors, Arrays</a></li>
        <li><a href="#表达式">表达式</a></li>
        <li><a href="#函数">函数</a></li>
        <li><a href="#classes">Classes</a></li>
        <li><a href="#the-io-library">The IO Library</a></li>
        <li><a href="#sequential-containers">Sequential Containers</a></li>
        <li><a href="#generic-algorithms">Generic Algorithms</a></li>
        <li><a href="#associative-containers">Associative Containers</a></li>
        <li><a href="#dynamic-memory">Dynamic Memory</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="基础部分">基础部分</h2>
<ol>
<li>A stream is a sequence of characters read from or written to an IO device.</li>
<li>To handle input, we use an object  of type istream named cin; for output, ostream named cout. Also, cerr, clog.</li>
<li>All the names defined by standard library are in the std namespace.</li>
<li>The value returned from main is a status indicator. A nonzero has a meaning defined by system.</li>
<li>The &laquo; operator takes 2 operands: left-hand is an ostream object, the other is a value, it returns its left-hand operand, so we can use &laquo; twice.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;Enter two numbers:&#34; &lt;&lt; endl;
</span></span><span class="line"><span class="cl">   int v1  = 0, v2 = 0;
</span></span><span class="line"><span class="cl">   cin &gt;&gt; v1 &gt;&gt; v2;
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;The sum of  &#34; &lt;&lt; v1 &lt;&lt; &#34; and &#34; &lt;&lt; v2&lt;&lt; &#34; is &#34; &lt;&lt; v1 + v2 &lt;&lt; endl;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   return 0;
</span></span><span class="line"><span class="cl">} 
</span></span></code></pre></td></tr></table>
</div>
</div><!-- more --> 
<ol start="6">
<li>End-of-File from keyboard, control-z on windows, control-d on linux.</li>
<li>while(cin &raquo; value) , it tests if istream is valid. It returns false when we hit end-of-file or invalid input.</li>
<li>&ldquo;iostream.h&rdquo;, this is old C head file, not  belong to namespace std. The new declaration is #include <iostream>.</li>
</ol>
<h2 id="变量和类型">变量和类型</h2>
<ol>
<li>The type of an object determines what operations can be performed on it.</li>
<li>C++ is a statically typed language, type checking is done at compile time.</li>
<li>The types int, short, long, long long are all signed. Especially, char and signed char are not the same. char is signed on some machines and unsigned on others, so explicitly specify it.</li>
<li>In an unsigned type, all bits represent the value. An 8-bit unsigned char can hold values from 0 to 255.</li>
<li>Signed values are automatically converted to unsigned. So don&rsquo;t mix signed and unsigned types.</li>
<li>If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold.</li>
<li>we can write 20 in three ways:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">20      /* decimal */
</span></span><span class="line"><span class="cl">024     /* octal */
</span></span><span class="line"><span class="cl">0x14    /* hexadecimal */
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>The compiler appends a null character(&rsquo;\0&rsquo;) to every string literal. Literal &lsquo;A&rsquo; : single character.  String literal &ldquo;A&rdquo; : an array of two characters, letter A and &lsquo;\0&rsquo;.</li>
<li>Escape Sequences:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\n         newline                
</span></span><span class="line"><span class="cl">\t         horizontal tab
</span></span><span class="line"><span class="cl">\v         vertical tab
</span></span><span class="line"><span class="cl">\a         alert
</span></span><span class="line"><span class="cl">\b         backspace
</span></span><span class="line"><span class="cl">\&#34;         double quote
</span></span><span class="line"><span class="cl">\&#39;         single quote
</span></span><span class="line"><span class="cl">\\         backslash
</span></span><span class="line"><span class="cl">\?         question mark
</span></span><span class="line"><span class="cl">\r         carriage return
</span></span><span class="line"><span class="cl">\f         formfeed
</span></span></code></pre></td></tr></table>
</div>
</div><p>we can also use a generalized escape sequence:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\7        bell
</span></span><span class="line"><span class="cl">\12       newline
</span></span><span class="line"><span class="cl">\40       blank
</span></span><span class="line"><span class="cl">\0        null
</span></span><span class="line"><span class="cl">\115      &#39;M&#39;
</span></span><span class="line"><span class="cl">\x4d      &#39;M&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>if a &ldquo;&quot; is followed by more than 3 octal digits, only the first 3 are associated with the &ldquo;&quot;.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">\1234        two characters, octal value 123 and character 4
</span></span><span class="line"><span class="cl">\x1234       single, 16-bit character, four hexadecimal digits
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="11">
<li>specify the type of a literal, override default type:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">L &#39;a&#39;        wide character literal, type is wchar_t
</span></span><span class="line"><span class="cl">42ULL        unsigned integer literal, unsigned long long
</span></span><span class="line"><span class="cl">1E-3F        single-precision floating-point literal, type is float
</span></span><span class="line"><span class="cl">3.14159L     extended-precision floating-point literal, type is long double
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="12">
<li>A variable provides us with named storage that our programs can manipulate.</li>
<li>Most generally, an object is a region of memory that can contain data and has a type.</li>
<li>Initialization and assignment are different operations in C++.</li>
<li>Initialization forms:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int sold = 0; 
</span></span><span class="line"><span class="cl">int sold = {0}; 
</span></span><span class="line"><span class="cl">int sold{0}; 
</span></span><span class="line"><span class="cl">int sold(0);
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="16">
<li>C++ 11 Initialization:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">long double ld = 3.1415926536;
</span></span><span class="line"><span class="cl">int a{ld}, b = {ld};   // error, narrowing conversion required
</span></span><span class="line"><span class="cl">int c(ld), d = ld;     // ok, but value will be truncated
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="17">
<li>
<p>Variables defined outside any function body are initialized to zero. Variables of built-in type defined inside a function are uninitialized, the value of it is undefined. Objects of class type that we do not explicitly initialize have a value that is defined by the class.</p>
</li>
<li>
<p>A declaration makes a name known to the program.  A definition creates the associated entity. To obtain a declaration that is not a definition, we add the &ldquo;extern&rdquo; keyword and may not provide an explicit initializer. An extern that has an initializer is a definition. And, it is an error to provide an initializer on an extern inside a function.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">extern double pi = 3.1416; // definition
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="19">
<li>A reference defines an alternative name for an object. A reference type &ldquo;refers to&rdquo; another type. When we define a reference, we bind the reference to its initializer. There is no way to rebind a reference to a different object, so references must be initialized, a reference is not an object.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 1024, i2 = 2048;
</span></span><span class="line"><span class="cl">int &amp;r = i,  r2 = i2;  // r is a reference bound to i, r2 is an int
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="20">
<li>
<p>C++ 11, a new kind of reference: an &ldquo;rvalue reference“，it uses &amp;&amp; to define, directly use temporary objects.</p>
</li>
<li>
<p>A pointer holds the address of another object. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ival = 42;
</span></span><span class="line"><span class="cl">int *p = &amp;ival; // p holds the address of ival, p is a pointer to ival
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="22">
<li>
<p>Because references are not objects, they don&rsquo;t have address. Hence, we may not define a pointer to a reference.</p>
</li>
<li>
<p>The value stored in a pointer can be in one of four states：
(1) It can point to an object
(2) It can point to the location just immediately past the end of an object
(3)It can be a null pointer, indicating that it is not bound to any object
(4)It can be invalid; values other than the preceding three are invalid.
It is an error to copy or try to access the value of an invalid pointer. The result of it is undefined.</p>
</li>
<li>
<p>Some symbols have multiple meanings. Such as &amp; and *, are used as both an operator in an expression and as part of a declaration. This is determined by the context.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 42;
</span></span><span class="line"><span class="cl">int &amp;r = i;  // &amp; is part of a declaration
</span></span><span class="line"><span class="cl">int *p;      // * is part of a declaration
</span></span><span class="line"><span class="cl">p = &amp;i;     //  &amp; as the address-of operator
</span></span><span class="line"><span class="cl">*p = i;     //  * as the deference operator
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="25">
<li>C++ 11, nullptr is a literal that has a special type that can be converted to any other pointer type. Old programs use a preprocessor variable named NULL. The preprocessor is a program runs before compiler. Morden C++ programs should avoid using NULL and use nullptr instead.</li>
<li>The type void* is a special pointer type that can hold the address of any object.</li>
<li>It is common misconception to think that the type modifier (* or &amp;) applies to all variables in a statement.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int* p1, p2;  // legal but might be misleading
</span></span><span class="line"><span class="cl">int *p1, *p2; // both p1 and p2 are pointers to int
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="28">
<li>We can store the address of a pointer in another pointer. A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer. The easiest way to understand the type of r is read the definition from right to left.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 42;
</span></span><span class="line"><span class="cl">int *p;
</span></span><span class="line"><span class="cl">int *&amp;r = p; // r is a reference to the pointer p
</span></span><span class="line"><span class="cl">r = &amp;i;
</span></span><span class="line"><span class="cl">*r = 0;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="29">
<li>Const objects are local to a file. To share a const object among multiple files, define variable as extern.</li>
<li>A reference to const May refer to an object that is not const.</li>
<li>A const pointer must be initialized, and once initialized, its value may not be changed.</li>
<li>P is a const pointer to const, neither the value of the object addressed by p nor the address stored in p can be changed.</li>
<li>We use the term top-level const to indicate that the pointer iteself is a const, can appear in any object type. When a pointer can point to a const object, we refer to that const as a low-level const.</li>
<li>A constant expression is an expression whose value cannot change and that can be evaluated at compile time.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">max_files</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="o">//</span> <span class="n">max_files</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">max_files</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="n">limit</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">staff_size</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>  <span class="o">//</span> <span class="n">staff_size</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">();</span> <span class="o">//</span> <span class="n">sz</span> <span class="n">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="35">
<li>C++ 11, to verify that a variable is a constant expression by declaring the variable in a constexpr declaration. Variables declared as constexpr are implicitly const and must be initialized by constant expressions.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="n">mf</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="o">//</span> <span class="mi">20</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">mf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="n">mf</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>  <span class="o">//</span> <span class="n">ok</span> <span class="n">only</span> <span class="k">if</span> <span class="n">size</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constexpr</span> <span class="n">function</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="36">
<li>C++ 11, we can use constexpr functions in the initializer of a constexpr variable. When we define a pointer in a constexpr declaration, the constexpr applies to the pointer.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>  <span class="o">//</span> <span class="n">p</span> <span class="n">is</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="o">//</span> <span class="n">q</span> <span class="n">is</span> <span class="n">a</span> <span class="k">const</span> <span class="n">pointer</span> <span class="n">to</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="o">//</span> <span class="n">type</span> <span class="n">of</span> <span class="n">i</span> <span class="n">is</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="k">const</span> <span class="ne">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="o">//</span> <span class="n">p</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="k">const</span> <span class="ne">int</span> <span class="n">i</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="37">
<li>A type alias is a name that is a synonym for another type. We often use &ldquo;typedef&rdquo; to define. C++ 11, an alias declaration starts with the keyword using followed by alias name.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef double wages;  // wages is a synonym for double
</span></span><span class="line"><span class="cl">typedef wages base, *p; // base is a synonym for double, p for double*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">using SI = Sales_item;  // SI is a synonym for Sales_item
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">wages hourly, weekly;  // same as double hourly, weekly;
</span></span><span class="line"><span class="cl">SI item;  // same as Sales_item item
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="38">
<li>C++ 11, we can use &ldquo;auto&rdquo; to let the compiler to deduce the type from the initializer. When we define multiple variables, they must have consistent types.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">auto i = 0, *p = &amp;i;  // ok: i is int and p is a pointer to int
</span></span><span class="line"><span class="cl">auto sz = 0, pi = 3.14;  // error: inconsistent types for sz and pi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int i = 0, &amp;r = i;
</span></span><span class="line"><span class="cl">auto a = r;  // a is an int (r is an alias for i, which has type int)
</span></span></code></pre></td></tr></table>
</div>
</div><p>auto ordinarily ignores top-level consts.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="o">//</span> <span class="n">b</span> <span class="n">is</span> <span class="n">an</span> <span class="ne">int</span> <span class="p">(</span><span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="k">const</span> <span class="ow">in</span> <span class="n">ci</span> <span class="n">is</span> <span class="n">dropped</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>  <span class="o">//</span> <span class="n">c</span> <span class="n">is</span> <span class="n">an</span> <span class="ne">int</span> <span class="p">(</span><span class="n">cr</span> <span class="n">is</span> <span class="n">an</span> <span class="n">alias</span> <span class="k">for</span> <span class="n">ci</span> <span class="n">whose</span> <span class="k">const</span> <span class="n">is</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>  <span class="o">//</span> <span class="n">d</span> <span class="n">is</span> <span class="n">an</span> <span class="ne">int</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">of</span> <span class="n">an</span> <span class="ne">int</span> <span class="n">object</span> <span class="n">is</span> <span class="ne">int</span><span class="o">*</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="o">//</span> <span class="n">e</span> <span class="n">is</span> <span class="k">const</span> <span class="ne">int</span><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span> <span class="n">of</span> <span class="n">a</span> <span class="k">const</span> <span class="n">object</span> <span class="n">is</span> <span class="n">low</span><span class="o">-</span><span class="n">level</span> <span class="k">const</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If we want the deduced type to have a top-level const, say explicityly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="o">//</span> <span class="n">deduced</span> <span class="n">type</span> <span class="n">of</span> <span class="n">ci</span> <span class="n">is</span> <span class="ne">int</span><span class="p">;</span> <span class="n">f</span> <span class="n">has</span> <span class="n">type</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="o">&amp;</span><span class="n">g</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="o">//</span> <span class="n">g</span> <span class="n">is</span> <span class="n">a</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span> <span class="n">that</span> <span class="n">is</span> <span class="n">bound</span> <span class="n">to</span> <span class="n">ci</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As usual, the initializers must provide consistent auto-deduced types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">k</span> <span class="n">is</span> <span class="ne">int</span><span class="p">;</span> <span class="n">l</span> <span class="n">is</span> <span class="ne">int</span><span class="o">&amp;</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">m</span> <span class="n">is</span> <span class="n">a</span> <span class="k">const</span> <span class="ne">int</span><span class="o">&amp;</span><span class="p">;</span><span class="n">p</span> <span class="n">is</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="o">&amp;</span><span class="n">m</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">type</span> <span class="n">deduced</span> <span class="n">from</span> <span class="n">i</span> <span class="n">is</span> <span class="ne">int</span><span class="p">;</span> <span class="n">type</span> <span class="n">deduced</span> <span class="n">from</span> <span class="o">&amp;</span><span class="n">ci</span> <span class="n">is</span> <span class="k">const</span> <span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="n">auto</span> <span class="o">&amp;</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="39">
<li>C++ 11, we can get the type of variable or expression by using &ldquo;decltype&rdquo; specifier.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">decltype(f())  sum = x; // sum has whatever type f returns
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here, the compiler does not call f, but uses the type it returns.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 42, *p = &amp;i, &amp;r = i; // decltype of an expression can be a reference type
</span></span><span class="line"><span class="cl">decltype(r + 0) b;  // ok: addition yields an int; b is an (uninitialized) int
</span></span><span class="line"><span class="cl">decltype(*p) c;  // error: c is int&amp; and must be initialized
</span></span></code></pre></td></tr></table>
</div>
</div><p>The deference operator is an example of an expression for which decltype returns a reference. The deduction done by decltype depends on the form of its given expression, that is, enclosing the name of a variable in parentheses affects the type returned by decltype.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="o">//</span> <span class="n">decltype</span> <span class="n">of</span> <span class="n">a</span> <span class="n">parenthesized</span> <span class="n">variable</span> <span class="n">is</span> <span class="n">always</span> <span class="n">a</span> <span class="n">reference</span>
</span></span><span class="line"><span class="cl"><span class="n">decltype</span><span class="p">((</span><span class="n">i</span><span class="p">))</span> <span class="n">d</span><span class="p">;</span>  <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">d</span> <span class="n">is</span> <span class="ne">int</span><span class="o">&amp;</span> <span class="ow">and</span> <span class="n">must</span> <span class="n">be</span> <span class="n">initialized</span>
</span></span><span class="line"><span class="cl"><span class="n">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>  <span class="o">//</span> <span class="n">ok</span><span class="p">:</span> <span class="n">e</span> <span class="n">is</span> <span class="n">an</span> <span class="p">(</span><span class="n">uninitialized</span><span class="p">)</span> <span class="ne">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="40">
<li>
<p>C++ 11, we can supply an in-class initializer for a data member. In-class initializers must either be enclosed inside curly braces or follow an = sign.</p>
</li>
<li>
<p>The most common technique for making it safe to include a header multiple times relies on the preprocessor. It is a program that runs before the compiler and changes the source text of our programs.</p>
</li>
</ol>
<h2 id="strings-vectors-arrays">Strings, Vectors, Arrays</h2>
<ol>
<li>
<p>A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type. Like other built-in types, arrays represent facilities of the hardware, so arrays are less convenient.</p>
</li>
<li>
<p>A using declaration lets us use a name from a namespace without qualifying the name with namespace name. Once the using declaration has been made, we can access name directly. We can also use separate declaration. Headers should not include using Declarations.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// using declarations for names from the standard library
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span> <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter two numbers:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v1</span> <span class="o">&gt;&gt;</span> <span class="n">v2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The sum of &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; and &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;&lt;</span> <span class="s">&#34; is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Here, this is an example of namespace.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">namespace CompanyName
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   namespace Engine
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">       class Node;
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   namespace MyGame
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">       class Tutorial;
</span></span><span class="line"><span class="cl">       class TutorialManager
</span></span><span class="line"><span class="cl">       {
</span></span><span class="line"><span class="cl">       public:
</span></span><span class="line"><span class="cl">           TutorialManager();
</span></span><span class="line"><span class="cl">           ~TutorialManager();
</span></span><span class="line"><span class="cl">       private:
</span></span><span class="line"><span class="cl">           static void RemoveNode(Engine::Node* node);
</span></span><span class="line"><span class="cl">           Tutorial* m_currentTut;
</span></span><span class="line"><span class="cl">       }
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>A string is a variable-length sequence of characters. It is defined in the std namespace.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s1</span><span class="p">;</span>  <span class="c1">// default initialization; s1 is the empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>  <span class="c1">// s2 is a copy of s1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s3</span> <span class="o">=</span> <span class="s">&#34;hiya&#34;</span><span class="p">;</span>  <span class="c1">// s3 is a copy of the string literal
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s4</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>  <span class="c1">// s4 is cccccccccc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s8</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span> <span class="c1">// copy initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>
<p>The size() function returns a string::size_type value. The string class and other library types defines several companion types, such as size_type. Although we don&rsquo;t know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string.</p>
</li>
<li>
<p>The string class comparing strategy:
(1) If two strings have different lengths and if every character in the shorter string is equal to the corresponding character of the longer string, then the shorter string is less than the longer one.
(2) If any characters at corresponding positions in the two strings differ, then the result of the string comparing the first character at which the strings differ.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string str1;
</span></span><span class="line"><span class="cl">getline(cin, str1); // read a line
</span></span><span class="line"><span class="cl">cout &lt;&lt; str1.size() &lt;&lt; endl; // &lt;&lt;, &gt;&gt; operator
</span></span><span class="line"><span class="cl">string str2(5, &#39;c&#39;);
</span></span><span class="line"><span class="cl">string str3 = str1 + &#34;,&#34; + str2; // =, + operator
</span></span><span class="line"><span class="cl">bool result = str1 &lt; str2; // &lt;, &gt; compare operator
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>C++ 11, we can use a Range for to change characters in a string.
Caution: Subscripts are Unchecked. We need to check that our subscript is less than size().</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string cc(&#34;Some String&#34;);
</span></span><span class="line"><span class="cl">for (auto &amp;c:cc)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   c = tolower(c); // c is a reference, so the assignment changes the char
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">if (!cc.empty())
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   cc[0] = toupper(cc[0]); // use subscript operator []
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">cout &lt;&lt; cc &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>A vector is a collection of objects, all of which have the same type. A vector is often referred to as a container because it &ldquo;contains&rdquo; other objects. A vector is a class template. C++ has both class and function templates. When we use a template, we specify what kind of class or function we want the compiler to instantiate.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">;</span>  <span class="c1">// ivec holds objects of type int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span>  <span class="c1">// vector whose elements are vectors
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>If we use braces and there is no way to use the initializers to initialize the object, then those values will be used to construct the objects.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; v1; // initial empty
</span></span><span class="line"><span class="cl">vector&lt;int&gt; v2(v1); // copy elements of v1 into v2
</span></span><span class="line"><span class="cl">vector&lt;int&gt; v3(3, 0); // v3 has 3 elements with value 0
</span></span><span class="line"><span class="cl">vector&lt;int&gt; v4(3); // v4 has 3 elements, each initialized to 0
</span></span><span class="line"><span class="cl">vector&lt;int&gt; v5{1,2,3}; // C++ 11, initialize from a list of elements
</span></span><span class="line"><span class="cl">vector&lt;string&gt; articles = {&#34;a&#34;, &#34;an&#34;, &#34;the&#34;};
</span></span><span class="line"><span class="cl">vector&lt;string&gt; svec(5, &#34;hello&#34;);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">vector&lt;string&gt; v7{10}; // v7 has 10 default-initialized elements
</span></span><span class="line"><span class="cl">vector&lt;string&gt; v8{10, &#34;hi&#34;}; // v8 has 10 elements with value &#34;hi&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>The body of a range for must not change the size of the sequence over which it is iterating. The subscript operator [] on vector (and string) fetches an existing element; it does not add an element. If the container is empty, the iterators returned by begin and end are equal, they are both off-the-end iterators. In general, we do not know the precise type that an iterator has. As with pointers, we can dereference an iterator to obtain the element denoted by an iterator. Like a const pointer, a const_iterator may read but not write the element it denotes.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; nums = {1,2,3,4,5,6,7,8};
</span></span><span class="line"><span class="cl">nums.push_back(9);
</span></span><span class="line"><span class="cl">for (auto &amp;i : nums)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   i *= i;
</span></span><span class="line"><span class="cl">   cout &lt;&lt; i &lt;&lt; &#34;\t&#34;;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">vector&lt;int&gt;::size_type length = nums.size();
</span></span><span class="line"><span class="cl">cout &lt;&lt; endl &lt;&lt; length &lt;&lt; endl;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">vector&lt;int&gt;::iterator it;
</span></span><span class="line"><span class="cl">for (it = nums.begin(); it != nums.end(); it++)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   *it *= 10;
</span></span><span class="line"><span class="cl">   cout &lt;&lt; *it &lt;&lt; &#34;\t&#34;;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>It is important to realize that loops that use iterators should not add elements to the container.</p>
<ol start="11">
<li>An array is a data structure that is similar to the library vector type. Unlike a vector, arrays have fixed size; we cannot  add elements to an array. A default-initialized array of built-in type that is defined inside a function will have undefined values. We cannot initialize an array as a copy of another array.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">unsigned</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">ia1</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>  <span class="o">//</span> <span class="n">array</span> <span class="n">of</span> <span class="n">three</span> <span class="n">ints</span> <span class="n">with</span> <span class="n">values</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>  <span class="o">//</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">dimension</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>  <span class="o">//</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="n">a3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">a4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;hi&#34;</span><span class="p">,</span> <span class="s2">&#34;bye&#34;</span><span class="p">};</span> <span class="o">//</span> <span class="n">same</span> <span class="n">as</span> <span class="n">a4</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;hi&#34;</span><span class="p">,</span> <span class="s2">&#34;bye&#34;</span><span class="p">,</span> <span class="s2">&#34;&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">x1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">};</span>  <span class="o">//</span> <span class="n">list</span> <span class="n">initialization</span><span class="p">,</span> <span class="n">no</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">x2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">};</span> <span class="o">//</span> <span class="n">list</span> <span class="n">initialization</span><span class="p">,</span> <span class="n">explicit</span> <span class="n">null</span>
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">x3</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&#34;C++&#34;</span><span class="p">;</span>   <span class="o">//</span> <span class="n">null</span> <span class="n">terminator</span> <span class="n">added</span> <span class="n">automatically</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="12">
<li>When we use a variable to subscript an array, we normally define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object. As with string and vector, it is up to the programmer to ensure that the subscript value is in range. When we use an array, the compiler ordinarily converts the array to a pointer.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string nums[] = {&#34;one&#34;, &#34;two&#34;, &#34;three&#34;};  // array of strings
</span></span><span class="line"><span class="cl">string *p2 = nums;  // equivalent to p2 = &amp;nums[0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
</span></span><span class="line"><span class="cl">auto ia2(&amp;ia[0]);  // now it&#39;s clear that ia2 has type int*
</span></span><span class="line"><span class="cl">decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};// ia3 is an array of ten ints
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int arr[] = {0,1,2,3,4,5,6,7,8,9};
</span></span><span class="line"><span class="cl">int *p = arr; // p points to the first element in arr
</span></span><span class="line"><span class="cl">++p;  // p points to arr[1]
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="13">
<li>C++ 11, the new function begin returns a pointer to the first, and end returns a pointer one past the last element.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span> <span class="c1">// ia is an array of ten ints
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span> <span class="c1">// pointer to the first element in ia
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">);</span>  <span class="c1">// pointer one past the last element in ia
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">ptrdiff_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">beg</span><span class="p">;</span> <span class="c1">// the result of subtracting two pointers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="14">
<li>Unlike subscripts for vector and string, the index of the built-in subscript operator is not an unsigned type.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ia[] = {0,2,4,6,8};  // array with 5 elements of type int
</span></span><span class="line"><span class="cl">int *p = &amp;ia[2];  // p points to the element indexed by 2
</span></span><span class="line"><span class="cl">int k = p[-2];  // p[-2] is the same element as ia[0]
</span></span><span class="line"><span class="cl">cout &lt;&lt; *p &lt;&lt; &#34;\t&#34; &lt;&lt; k &lt;&lt; endl; // 4   0
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="15">
<li>C-style character strings are not a type, they are stored in character arrays and are null terminated. By null-terminated we mean that the last character in the string is followed by a null character &lsquo;\0&rsquo;. The standard C library provides a set of functions operated on C-style strings. However, to use these functions, we can easily miscalculate the size needed for the parameters. In addition to being safer, it is more efficient to use library string rather than C-style strings.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">char</span> <span class="n">ca</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">};</span> <span class="o">//</span> <span class="ow">not</span> <span class="n">null</span> <span class="n">terminated</span>
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">ca2</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&#34;c++&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">ca3</span> <span class="o">=</span> <span class="s2">&#34;c++&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;</span><span class="se">\t</span><span class="s2">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ca2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;</span><span class="se">\t</span><span class="s2">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ca3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">ca3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;equal&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="n">compare</span> <span class="n">c</span><span class="o">-</span><span class="n">style</span> <span class="n">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">char</span> <span class="n">cp1</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&#34;c&#34;</span><span class="p">;</span> <span class="o">//</span> <span class="k">if</span> <span class="n">cp1</span><span class="p">[]</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">strcpy</span> <span class="ow">and</span> <span class="n">strcat</span> <span class="n">will</span> <span class="n">be</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl"><span class="n">strcpy</span><span class="p">(</span><span class="n">cp1</span><span class="p">,</span> <span class="n">ca3</span><span class="p">);</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">ca3</span> <span class="n">into</span> <span class="n">cp1</span><span class="p">,</span> <span class="n">size</span> <span class="n">of</span> <span class="n">cp1</span> <span class="n">should</span> <span class="n">be</span> <span class="n">big</span> <span class="n">enough</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">ca3</span>
</span></span><span class="line"><span class="cl"><span class="n">strcat</span><span class="p">(</span><span class="n">cp1</span><span class="p">,</span> <span class="n">ca2</span><span class="p">);</span> <span class="o">//</span> <span class="n">concatenate</span> <span class="n">ca2</span> <span class="n">onto</span> <span class="n">cp1</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cp1</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;</span><span class="se">\t</span><span class="s2">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cp1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span><span class="o">*</span> <span class="n">src</span> <span class="o">=</span> <span class="s2">&#34;hi&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">char</span><span class="o">*</span> <span class="n">dest</span> <span class="o">=</span> <span class="n">new</span> <span class="n">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">));</span><span class="o">//</span> <span class="n">safer</span> <span class="n">such</span> <span class="n">as</span> <span class="n">strcpy_s</span><span class="p">,</span> <span class="n">but</span> <span class="ow">not</span> <span class="n">enough</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;</span><span class="se">\t</span><span class="s2">&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dest</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="16">
<li>C++ may have to interface to code that uses arrays and C-style strings. C++ library offers some facilities to make it easier.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="n">initialize</span> <span class="n">a</span> <span class="n">string</span> <span class="n">from</span> <span class="n">a</span> <span class="n">string</span> <span class="n">literal</span>
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">str</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">c_str</span><span class="p">();</span> <span class="o">//</span> <span class="n">the</span> <span class="n">value</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">c_str</span> <span class="n">may</span> <span class="n">be</span> <span class="n">invalid</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span> <span class="o">//</span> <span class="n">copy</span> <span class="n">array</span> <span class="n">to</span> <span class="n">vector</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="17">
<li>Strictly speaking, there are no multidimensional arrays in C++，they are actually arrays of arrays.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ia[3][4]; // array of size 3; each element is an array of ints of size 4
</span></span><span class="line"><span class="cl">int arr[10][20][30] = {0}; // initialize all elements to 0
</span></span><span class="line"><span class="cl">int ax[3][4] = { // three elements; each element is an array of size 4
</span></span><span class="line"><span class="cl">   {0, 1, 2, 3},
</span></span><span class="line"><span class="cl">   {4, 5, 6, 7},
</span></span><span class="line"><span class="cl">   {8, 9, 7, 8}
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">int axy[3][4] = {0,1,2,3,4,5,6,7,8,9,7,8}; // the nested braces are optional
</span></span><span class="line"><span class="cl">int ix[3][4] = {{ 0 }, { 4 }, { 8 }};
</span></span><span class="line"><span class="cl">int ixy[3][4] = {0,3,6,9}; // initialize row 0, the remaining elements are 0
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="18">
<li>C++ 11, we can use a range for with Multidimensional Arrays. Remember that a multidimensional array is really an array of arrays.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int ia[2][3] = {0,1,2,3,4,5};
</span></span><span class="line"><span class="cl">// the innermost array must be references, we can only iterator on arrays, not pointers
</span></span><span class="line"><span class="cl">for (auto &amp;row : ia)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   for (auto &amp;col : row) // you can remove &#39;&amp;&#39; here
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">       cout &lt;&lt; col &lt;&lt; &#34;\t&#34; ;
</span></span><span class="line"><span class="cl">       col += 10;
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">cout &lt;&lt; endl;
</span></span><span class="line"><span class="cl">for (int i = 0; i &lt; 6; i++)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   cout &lt;&lt; *(*ia + i) &lt;&lt; &#34;\t&#34;;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">cout &lt;&lt; endl;
</span></span><span class="line"><span class="cl">// we should avoid to write the type of a pointer into an array by using auto or decltype
</span></span><span class="line"><span class="cl">for (auto p = begin(ia); p != end(ia); ++p)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   for (auto q = begin(*p); q != end(*p); ++q)
</span></span><span class="line"><span class="cl">       cout &lt;&lt; *q &lt;&lt; &#34;\t&#34;;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int *ip[4];  // array of pointers to int
</span></span><span class="line"><span class="cl">int (*ipx)[4];  // pointer to an array of four ints
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="表达式">表达式</h2>
<ol>
<li>
<p>Every expression in C++ is either an rvalue or an lvalue. When we use an object as rvalue, we use the object&rsquo;s value. When we use an object as an lvalue, we use the object&rsquo;s identity(its location in memory).</p>
</li>
<li>
<p>Precendence specifies how the operands are grouped. It says nothing about the order. In the following expression <code>int i = f1() * f2();</code> We have no way of knowing whether f1 will be called before f2 or vice versa. For operators that do not specify evaluation order, it is an error for an expression to refer to and change the same object. For example, the &laquo; operator makes no guarantees about when or how its operands are evaluated.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 0;
</span></span><span class="line"><span class="cl">cout &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; ++i &lt;&lt; endl; // undefined
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are 4 operators that do guarantee the order in which operands are evaluated. The logical AND (&amp;&amp;) operator guarantees its left-hand operand is evaluated first and its right-hand operator is evaluated only if the left-hand operand is true; logical OR(||) operator ; conditional (? :) operator; comma (,) operator.</p>
<ol start="3">
<li>
<p>Order of operand evaluation is independent of precedence and associativity. In an expression such as: <code>f() + g() * h() + j()</code> There are no guarantees as to the order in which these functions are called.
(1) when in doubt, parenthesize expressions to force the grouping
(2) if you change the value of an operand, don&rsquo;t use that operand elsewhere in the same expression
an important exception to the second rule occurs when the subexpression that changes the operand is itself. For example, in *++iter, the value of iter is the operand to the dereference operator, order is not an issue.</p>
</li>
<li>
<p>C++ 11, the modulus operator is defined so that if m and n are integers and n is nonzero, then (m/n)*n + m%n is equal to m. By implication, if m%n is nonzero, it has the same sign as m.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int i = 1024;
</span></span><span class="line"><span class="cl">int k = -i; // k is -1024
</span></span><span class="line"><span class="cl">bool b = true;
</span></span><span class="line"><span class="cl">bool b2 = -b; // b2 is 1
</span></span><span class="line"><span class="cl">short short_value = 32767; // max value if shorts are 16 bits
</span></span><span class="line"><span class="cl">short_value += 1; // this calculation overflows
</span></span><span class="line"><span class="cl">cout &lt;&lt; short_value &lt;&lt; endl; // -32768
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// if m%n is nonzero, it has same sign as m
</span></span><span class="line"><span class="cl">cout &lt;&lt; -21 % -8 &lt;&lt; &#39;\t&#39; &lt;&lt; 21 % -5 &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>Arithmetic and pointer operand with a value of zero are false, all other values are true. The logical AND and OR (&amp;&amp; ||) operators always evaluate their left operand before the right. The right operand is evaluated if and only if the left operand does not determine the result, this strategy is known as short-circuit evaluation. This can be used for checking index of array:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;Don&#39;t start to wonder why.&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;You know I love you&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;when I lie to you&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">auto</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">:</span><span class="n">text</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">s</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>C++ 11, we can use a braced initializer list on the right-hand side. Assignment has lower precedence.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int k = { 3 }; // no narrowing conversion
</span></span><span class="line"><span class="cl">vector&lt;int&gt; vi; // initial empty
</span></span><span class="line"><span class="cl">vi = {0, 1, 2}; // use vector operator
</span></span><span class="line"><span class="cl">int v = k = 0; // assignment is right associative
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int i;
</span></span><span class="line"><span class="cl">if((i = k) != 3) i++; // assignment has lower precedence, so need parentheses
</span></span><span class="line"><span class="cl">cout &lt;&lt; i &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>The increment(++) and decrement(&ndash;) provide two forms of operators: prefix and postfix.
The prefix form increments its operand and yields the changed object as its result.
The postfix operator increments the operand but yields a copy of the original value as its result.
Use postfix operator only when necessary.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; v = { 2, 1, 0, -1, -2 };
</span></span><span class="line"><span class="cl">auto pbeg = v.begin();
</span></span><span class="line"><span class="cl">// print elements up to the first negative value
</span></span><span class="line"><span class="cl">while (pbeg != v.end() &amp;&amp; *pbeg &gt;= 0)
</span></span><span class="line"><span class="cl">   cout &lt;&lt; *pbeg++ &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>The dot and arrow operators provide for member access.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">string s = &#34;a str&#34;, *p = &amp;s;
</span></span><span class="line"><span class="cl">cout &lt;&lt; s.size() &lt;&lt; &#39; &#39; &lt;&lt; (*p).size() &lt;&lt; &#39; &#39; &lt;&lt; p-&gt;size();
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>The conditional operator lets use embed simple if-else logic inside an expression. It has the following form: <code>condition ? expr1 : expr2;</code> Nested conditionals quickly become unreadable. Do not nest more than two or three. The conditional operator has fairly low precedence. When we embed a conditional expression in a large expression, we usually must parenthesize the conditional sub expression.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int score = 68;
</span></span><span class="line"><span class="cl">string grade = (score &gt; 90) ? &#34;high pass&#34;
</span></span><span class="line"><span class="cl">                           : (score &lt; 60) ? &#34;fail&#34; : &#34;pass&#34;;
</span></span><span class="line"><span class="cl">cout &lt;&lt; ((score &lt; 60) ? &#34;fail&#34; : &#34;pass&#34;) &lt;&lt; endl; // print pass
</span></span><span class="line"><span class="cl">cout &lt;&lt; (score &lt; 60) ? &#34;fail&#34; : &#34;pass&#34;; // print 0, cout &lt;&lt; (score &lt; 60)
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>There are no guarantees for how the sign bit is handled, we should use unsigned types with bitwise operators. Bits that are shifted off the end are discarded. The left-shift operator (&laquo;) inserts 0-valued bits on the right. The behavior of the right-shift operator (&raquo;) depends on the type of the left-hand operand: if that operand is unsigned, the operator inserts 0-valued bits on the left. if it is signed, the result is implementation defined, either copies of the sign bit or 0-valued bits are inserted on the left.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">unsigned i = 35;
</span></span><span class="line"><span class="cl">cout &lt;&lt; (1 &lt;&lt; i) &lt;&lt; endl; // 35 &amp; 31 = 3; 1 &lt;&lt; 3, depend on CPU, this is undefined
</span></span><span class="line"><span class="cl">cout &lt;&lt; (1 &lt;&lt; 35) &lt;&lt; endl; // directly compute
</span></span></code></pre></td></tr></table>
</div>
</div><p>The result of above code is strange, because the right operand is too large. Also, there are other bitwise operators: <code>~ (NOT), &amp; (AND), ^ (XOR), | (OR)</code></p>
<ol start="11">
<li>To handle bit operation, we can also use bitset library.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">bitset</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">bs</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bs</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 00000110
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bs</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 2, the size of bit &#39;1&#39;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">bitset</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">tt</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">tt</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// set the bit to 1, from right to left
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">tt</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// set the bit to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 00000011
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;test if the bit is 1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="p">.</span><span class="n">any</span><span class="p">())</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;there is at least one &#39;1&#39; bit&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">tt</span><span class="p">.</span><span class="n">none</span><span class="p">())</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;all bits are 0&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">bitset</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">(</span><span class="s">&#34;011&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vs</span><span class="p">.</span><span class="n">to_ulong</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// get bit value, 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">bitset</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">vec</span><span class="p">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// reverse the bit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">flip</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 1111111111111100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="12">
<li>The sizeof operator returns the size, in bytes, of an expression or a type name.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int a = 1, *p = &amp;a;
</span></span><span class="line"><span class="cl">size_t value = sizeof a; // return type is size_t
</span></span><span class="line"><span class="cl">cout &lt;&lt; value &lt;&lt; endl; // size of int
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof p &lt;&lt; endl; // size of pointer, the value depend on system
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof *p &lt;&lt; endl; // size of type to which p points
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">struct User
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   int id;
</span></span><span class="line"><span class="cl">   string name;
</span></span><span class="line"><span class="cl">   bool hasExpired;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof(int) &lt;&lt; &#34;\t&#34; &lt;&lt; sizeof(string) &lt;&lt; &#34;\t&#34; 
</span></span><span class="line"><span class="cl">   &lt;&lt; sizeof(bool) &lt;&lt; &#34;\t&#34; &lt;&lt; sizeof(User) &lt;&lt; endl;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">char array[10];
</span></span><span class="line"><span class="cl">char ax[] = &#34;abcd&#34;;
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof(array) &lt;&lt; endl;
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof(ax) &lt;&lt; endl; // sizeof will include &#39;/0&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">vector&lt;char&gt; vec = {&#39;a&#39;, &#39;b&#39;};
</span></span><span class="line"><span class="cl">cout &lt;&lt; sizeof(vec); // size of the fixed part of this vector
</span></span></code></pre></td></tr></table>
</div>
</div><p>sizeof char or an expression of type char is guaranteed to be 1.
sizeof a reference type returns the size of an object of the referenced type.
sizeof a pointer returns the size needed hold a pointer.
sizeof a dereferenced pointer returns the size of an object of the type to which the pointer points.
sizeof an array is the size of the entire array. Note that sizeof does not convert the array to a pointer.
sizeof a string or a vector returns only the size of the fixed part of these types.</p>
<ol start="13">
<li>The comma operator takes two operands, which it evaluates from left to right.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; ivec = {5, 6, 7};
</span></span><span class="line"><span class="cl">vector&lt;int&gt;::size_type cnt = ivec.size();
</span></span><span class="line"><span class="cl">// both ix and cnt are changed through the loop
</span></span><span class="line"><span class="cl">for (vector&lt;int&gt;::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   ivec[ix] = cnt;
</span></span><span class="line"><span class="cl">   cout &lt;&lt; ivec[ix] &lt;&lt; &#34;\t&#34;;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int x = 0, y = 0;
</span></span><span class="line"><span class="cl">x == 0 ? ++x, ++y : --x, --y;
</span></span><span class="line"><span class="cl">cout &lt;&lt; endl &lt;&lt; x &lt;&lt; &#34;\t&#34; &lt;&lt; y &lt;&lt; endl; // 1    0
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="14">
<li>
<p>The arithmetic conversions, convert one arithmetic type to another. If both operands have the same signedness, then the operand with the smaller type is converted to the larger type. When the signedness differs and the type of the unsigned operand is the same as or larger than that of the signed operand, the signed operand is converted to unsigned. The remaining case is when the signed operand has a larger type than the unsigned operand, the result is machine dependent. If all values in the unsigned type fit in the larger type, then the unsigned type is converted to signed type. If the values don&rsquo;t fit, then the signed operand is converted to unsigned type. For example, if the operands are long and unsigned int, and int and long have the same size, the long will be converted to unsigned int. If the long type has more bits, then the unsigned int will be converted to long.</p>
</li>
<li>
<p>In addition to the arithmetic conversions, there are several additional kinds of implicit conversions.
(1) Array to Pointer Conversions: when we use an array, the array is automatically converted to a pointer to the first element in that array. This conversion is not performed when an array is used with decltype or as the operand of the address-of(&amp;), sizeof, or typeid operators. The conversion is also omitted when we initialize a reference to an array.
(2) Pointer Conversions: a constant integral value of 0 and the literal nullptr can be converted to any pointer; a pointer to any nonconst type can be converted to void*, and a pointer to any type can be converted to a const void*.
(3) Conversions to bool: If the pointer or arithmetic value is zero, the conversion yields false, any other yields true.
(4) Conversion to const: we can convert a pointer to a nonconst type or a pointer to the corresponding const type. If T is a type, we can convert a pointer or a reference to T into a pointer or reference to const T.
(5) Conversions Defined by Class Types: the compiler will apply automatically. This can be done by define constructor, but not recommend to define this conversion.</p>
</li>
<li>
<p>Sometimes we want to explicitly force an object to be converted to a different type. To do so, we use a cast to do an explicit conversion. A named cast has the following form: <code>cast-name&lt;type&gt; (expression);</code> The type is the target type, and expression is the value to be cast. If type is a reference, the result is an lvalue.
(1) static_cast, any well-defined type conversion, other than those involving low-level const, can be requested using a static_cast. It is also useful to perform a conversion that the compiler will not generate automatically.
(2) const_cast, change a low-level const in its operand, or say that convert a const object to nonconst type. Once we have cast away the const of an object, the compiler will no longer prevent us from writing to that object.
(3) reinterpret_cast, generally performs a low-level reinterpretation of the bit pattern of its operands. A reinterpret_cast is inherently machine dependent. So avoid casts.
(4) dynamic_cast, used in combination with inheritance and run-time type identification.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">double</span> <span class="n">slope</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">slope</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">double</span> <span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">double</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="ne">int</span> <span class="n">constant</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="ne">int</span><span class="o">*</span> <span class="n">modifier</span> <span class="o">=</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="ne">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">constant</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">*</span><span class="n">modifier</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="o">//</span> <span class="n">constant</span> <span class="n">can</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">really</span> <span class="n">modified</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">constant</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="o">//</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="17">
<li>Statement and Exception</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyException</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">MyException</span><span class="p">(</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="n">err_msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">ShowErrorMsg</span><span class="p">()</span> <span class="p">{</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">err_msg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">err_msg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">TestException</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="k">throw</span> <span class="n">MyException</span><span class="p">(</span><span class="s">&#34;MyException!&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">TestStdException</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="k">throw</span> <span class="n">invalid_argument</span><span class="p">(</span><span class="s">&#34;exception: argument too large&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// if else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">grade</span> <span class="o">=</span> <span class="mi">75</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">grade</span> <span class="o">&gt;=</span> <span class="mi">60</span> <span class="o">&amp;&amp;</span> <span class="n">grade</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// switch, break
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">switch</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Grade : Fail&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Grade : Pass&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Grade : Excellent&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Unknown level value&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// while statement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">99</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">97</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">begin</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">beg</span> <span class="o">!=</span> <span class="n">end</span><span class="p">(</span><span class="n">array</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">beg</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// do while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">do</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="o">--</span><span class="n">beg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">beg</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">beg</span> <span class="o">!=</span> <span class="n">begin</span><span class="p">(</span><span class="n">array</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// range for, continue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">r</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="n">r</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// for statement
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// exception
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">TestException</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="n">MyException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="n">e</span><span class="p">.</span><span class="n">ShowErrorMsg</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">try</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">TestStdException</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="n">invalid_argument</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="函数">函数</h2>
<ol>
<li>
<p>Arguments are the initializers for a function’s parameters. The first argument initializes the first parameter, the second argument initializes the second parameter, and so on. Although we know which argument initializes which parameter, we have no guarantees about the order in which arguments are evaluated. Parameter names are optional. However, there is no way to use an unnamed parameter. Therefore, parameters ordinarily have names.</p>
</li>
<li>
<p>Objects defined outside any function exist throughout the program’s execution. Such objects are created when the program starts and are not destroyed until the program ends. The lifetime of a local variable depends on how it is defined. Each local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates. If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">count_calls</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="n">size_t</span> <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// value will persist across calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="o">++</span><span class="n">ctr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count_calls</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>
<p>When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference.” Reference parameters let us effectively return multiple results. When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value.” When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, We can change the value of that object by assigning through the pointer.</p>
</li>
<li>
<p>When we copy an argument to initialize a parameter, top-level consts are ignored. Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is usually converted to a pointer.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">//parameter is a reference to an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">arr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//the size of an array is part of its type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// arguments begin in argv[1], argv[0] contains program name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">argc</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">error_msg</span><span class="p">(</span><span class="kt">int</span> <span class="n">errCode</span><span class="p">,</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ErrorCode:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">errCode</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">elem</span> <span class="p">:</span> <span class="n">il</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">errCode</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">desc</span><span class="p">,</span> <span class="p">...)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">desc</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">errCode</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">char</span><span class="o">*</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">va_list</span> <span class="n">arg_ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// va_start must appear in front of va_arg, desc is the last parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">va_start</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span><span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">va_end</span><span class="p">(</span><span class="n">arg_ptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">error_msg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s">&#34;are&#34;</span><span class="p">,</span> <span class="s">&#34;you&#34;</span><span class="p">,</span> <span class="s">&#34;ok&#34;</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;Error&#34;</span><span class="p">,</span> <span class="s">&#34;No,&#34;</span><span class="p">,</span> <span class="s">&#34;thank&#34;</span><span class="p">,</span> <span class="s">&#34;you&#34;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>Never Return a Reference or Pointer to a Local Object. When a function completes, its storage is freed. C++ 11, functions can return a braced list of values. We cannot return an array, but a function can return a pointer or a reference to an array. C++ 11, to simplify the declaration of a pointer to an array, we can use a trailing return type. Trailing returns can be defined for any function, but are most userful for functions with complicated return types.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// C++ 11, list initializing the return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">{</span><span class="s">&#34;functionX&#34;</span><span class="p">,</span> <span class="s">&#34;okay&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">testFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// a function that returns a pointer to an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">testPFunc1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">))[</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// a trailing return type
</span></span></span><span class="line"><span class="cl"><span class="c1">// a function takes an int argument and returns a pointer to an array of ten ints
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="nf">testPFunc2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">odd</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">even</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">decltype</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span> <span class="o">*</span><span class="n">arrPtrFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="nl">odd</span> <span class="p">:</span> <span class="o">&amp;</span><span class="n">even</span><span class="p">;</span> <span class="c1">// returns a pointer to the array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">s</span><span class="p">:</span><span class="n">process</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">typedef</span> <span class="kt">int</span> <span class="n">INT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">arrTS</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">   <span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// arrT is a synonym for the type array of 10 ints
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arrP</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// a pointer to an array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arrFunc</span><span class="p">)(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// a pointer named arrFunc to a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">typedef</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cpstr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">arrT</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">arrP</span> <span class="n">ap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">INT</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">)[</span><span class="mi">9</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">arrFunc</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">testFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">funcArr</span><span class="p">[</span><span class="mi">10</span><span class="p">])(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">funcArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">testFunc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">funcArr</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mi">100</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">arrP</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">testPFunc1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">arrP</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">testPFunc2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">)[</span><span class="mi">9</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">cpstr</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// this returned value from main is a status indicator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>If we declare a name in an inner scope, that name hides uses of that name declared in an outer scope. Names do not overload across scopes. In C++, name lookup happens before type checking.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// new scope: hides previous instance of print
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">print</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>
<p>A function specified as inline (usually) is expanded &ldquo;in line&rdquo; at each call. The inline is only a request to the compiler. The compiler may choose to ignore this request. This mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function. A 75-line function will not be expanded inline.</p>
</li>
<li>
<p>A constexpr function is a function that can be used in a constant expression. The return type and the type of each parameter in an expression must be a literal type, and the function body must contain exactly one return statement. In order to be able to expand the function immediately, constexpr functions are implicitly inline.</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="ne">int</span> <span class="n">new_sz</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="n">scale</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span> <span class="k">if</span> <span class="n">arg</span> <span class="n">is</span> <span class="n">a</span> <span class="n">constant</span> <span class="n">expression</span>
</span></span><span class="line"><span class="cl"><span class="n">constexpr</span> <span class="n">size_t</span> <span class="n">scale</span><span class="p">(</span><span class="n">size_t</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">new_sz</span><span class="p">()</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A constexpr function is not required to return a constant expression. Unlike other functions, inline and constexpr functions may be defined multiple times. As a result, inline and constexpr functions normally are defined in headers.</p>
<ol start="10">
<li>To conditionally execute debugging code, there are two preprocessor facilities: assert and NDEBUG. assert is a preprocessor macro, that preprocessor variable acts like an inline function. Preprocessor names are managed by preprocessor, not the compiler. As a result, we use preprocessor names directly and not provide a using declaration for assert. The behavior assert depends on the status of a preprocessor variable named NDEBUG. If NDEBUG is defined, assert does nothing. We can &ldquo;turn off&rdquo; debugging by providing a #define to define NDEBUG.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// __func__, the C++ compiler defines
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// __FILE__ ... the preprocessor defines in debugging
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#ifndef NDEBUG
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__FILE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// name of the file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__LINE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// current line number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__TIME__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// the time the file was compiled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__DATE__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// the date the file was compiled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">__func__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// name of the function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">assert</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="11">
<li>The first step of function matching identifies the candidate functions. A candidate function is a function with the same name as the called function. The second step selects the viable functions from candidate functions. To be viable, a function must have the same number of parameters, and the type of each argument must match or can be converted. The third step determines which viable function provides the best match for the call. An exact match is better than a match that requires a conversion.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">f(double, double); 
</span></span><span class="line"><span class="cl">f(int, int);
</span></span></code></pre></td></tr></table>
</div>
</div><p>For call f(5.6, 3.14), f(double, double) is a better match.
For call f(42, 2.56), the compiler will reject this call because it is ambiguous.
Also, for func(long) and func(float), call func(3.14) is ambiguous.</p>
<ol start="12">
<li>A function&rsquo;s type is determined by its return type and parameters type, not the function&rsquo;s name. When we use the name of a function as a value, the function is automatically converted to a pointer.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">compareLength</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// equivalent declare, function will automatically be converted to pointer as argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">printBigger1</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">printBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="n">pf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">pf</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">bool</span> <span class="nf">Func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// function type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">compareLength</span><span class="p">)</span> <span class="n">Func2</span><span class="p">;</span> <span class="c1">// equivalent type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">printBigger2</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Func</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// decltype returns a function type, if we want a pointer, we must add * ourselves.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncP</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// pointer type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">compareLength</span><span class="p">)</span> <span class="o">*</span><span class="n">FuncP2</span><span class="p">;</span> <span class="c1">// equivalent type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">printBigger3</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">FuncP2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// pf points to a function returning bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// declares a function named pf that returns a bool*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span>  <span class="o">*</span><span class="nf">bf</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">F</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// F is a function type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">using</span> <span class="n">PF</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// PF is a pointer type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// from the inside out, f1 has a parameter list, so f1 is a function
</span></span></span><span class="line"><span class="cl"><span class="c1">// f1 is preceded by a * so f1 returns a pointer
</span></span></span><span class="line"><span class="cl"><span class="c1">// the type of that pointer itself has a parameter list
</span></span></span><span class="line"><span class="cl"><span class="c1">// so the pointer points to a function, the function returns an int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">))(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// use a trailing return
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// equivalent assignment and call
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">pf</span> <span class="o">=</span> <span class="n">compareLength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pf</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="s">&#34;12&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">compareLength</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pf</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="s">&#34;12&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="s">&#34;12&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">printBigger</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="s">&#34;12&#34;</span><span class="p">,</span> <span class="n">compareLength</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// just call the declared function, so the parentheses is important
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">bf</span><span class="p">(</span><span class="s">&#34;12&#34;</span><span class="p">,</span> <span class="s">&#34;123&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span><span class="o">*</span> <span class="nf">bf</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="classes">Classes</h2>
<ol>
<li>
<p>In C++ we use classes to define our own data types. The fundamental ideas behind classes are data abstraction and encapsulation. Data abstraction is a programming technique that relies on the separation of interface and implementation. The interface of a class consists of the operations that users of the class can execute. The implementation includes the class data members, the bodies of functions that constitute the interface. Encapsulation enforces the separation of a class interface and implementation. A class that is encapsulated hides its implementation, users can use the interface but have no access to the implementation. A class that uses data abstraction and encapsulation defines an abstract data type.</p>
</li>
<li>
<p>Member functions must be declared inside the class, and may be defined inside or outside  the class body. Functions defined in the class are implicitly inline. Member functions access the object on which they were called through an extra implicit parameter named this. When we call a member function, &ldquo;this&rdquo; is initialized with the address of the object on which the function was invoked. Any direct use of a member of the class is assumed to be an implicit reference through &ldquo;this&rdquo;. Because &ldquo;this&rdquo; is intended to always refer to &ldquo;this&rdquo; object, &ldquo;this&rdquo; is a const pointer, we cannot change the address that &ldquo;this&rdquo; holds. By default, the type of &ldquo;this&rdquo; is a const pointer to the nonconst version of the class type. So we cannot bind &ldquo;this&rdquo; to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object. A const following the parameter list indicates that this is a pointer to const, member functions that use const in this way are const member functions. It means that const member functions cannot change the object on which they are called. Objects that are const, and references or pointers to const objects, may call only const member functions.</p>
</li>
<li>
<p>The job of a constructor is to initialize the data members of a class object. A constructor is run whenever an object of a class type is created. Constructors have the same name as the class, no return type. Classes control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments. If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor:
(1) If there is an in-class initializer, use it to initialize the member
(2) Otherwise, default-initialize the member.
The compiler generates a default constructor automatically only if a class declares no constructors. Classes that have members of built-in or compound type usually rely on the synthesized default constructor only if all such members have in-class initializers. If a class has a member that has a class type, and that class doesn&rsquo;t have a default constructor, then the compiler can&rsquo;t initialize that member. For such cases, we must define our own constructor. Constructors should not override in-class initializers except to use a different initial value.</p>
</li>
</ol>
<p>A class can allow another class or function to access its nonpublic members by making that class or function a friend. Friend declarations may appear anywhere in the class.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// The only difference between struct and class is the default access level
</span></span></span><span class="line"><span class="cl"><span class="c1">// by default, members are public in struct, private in class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Sales_data</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">friend</span> <span class="n">istream</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// C++ 11, the default constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">       <span class="n">units_sold</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">revenue</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="nf">isbn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">bookNo</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">combine</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">avg_price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">units_sold</span> <span class="o">?</span> <span class="n">revenue</span><span class="o">/</span><span class="nl">units_sold</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span> <span class="c1">// default initializes bookNo to empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">unsigned</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// in-class initializer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the scope operator :: means that this function is declared in Sales_data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="o">::</span><span class="n">combine</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">units_sold</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">revenue</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="c1">// return the object on which the function was called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">sum</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
</span></span><span class="line"><span class="cl">   <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">avg_price</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">istream</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">bookNo</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&gt;&gt;</span> <span class="n">price</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">price</span> <span class="o">*</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="o">::</span><span class="n">Sales_data</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">read</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Please input data: bookNo, units_sold, price&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span> <span class="n">item1</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">item1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>A mutable data member is never const, even when it is a member of a const object.</li>
</ol>
<p>When we provide an in-class initializer, we must do so following an = sign or inside braces.</p>
<p>It is important to understand that friendship is not transitive.</p>
<p>Member function definitions are processed after the compiler processes all of the declarations in the class. If function definitions were processed at the same time as the member declarations, then we would have to order the member functions so that they referred only to names already seen.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Screen</span><span class="p">;</span> <span class="c1">// forward declaration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Link_screen</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// to use the incomplete class Screen, first we need forward declaration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// then we can only define pointers or references to that class
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Screen</span><span class="o">*</span> <span class="n">window</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Link_screen</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Link_screen</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Screen</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// friendship is not transitive, so if class Window_mgr has its own friends,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// those friends have no special access to Screen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">friend</span> <span class="k">class</span> <span class="nc">Window_mgr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">typedef</span> <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// needed because Screen has another constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Screen</span><span class="p">(</span><span class="n">pos</span> <span class="n">ht</span><span class="p">,</span> <span class="n">pos</span> <span class="n">wd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">height</span><span class="p">(</span><span class="n">ht</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">wd</span><span class="p">),</span> <span class="n">contents</span><span class="p">(</span><span class="n">ht</span> <span class="o">*</span> <span class="n">wd</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">set</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">char</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">contents</span><span class="p">[</span><span class="n">cursor</span><span class="p">];</span> <span class="p">}</span> <span class="c1">// get the character at the cursor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">get</span><span class="p">(</span><span class="n">pos</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">pos</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">some_member</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">display</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="p">{</span> <span class="n">do_display</span><span class="p">(</span><span class="n">os</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">display</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">do_display</span><span class="p">(</span><span class="n">os</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="n">do_display</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">contents</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">pos</span> <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">pos</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// the row number and column number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">contents</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">mutable</span> <span class="n">size_t</span> <span class="n">access_ctr</span><span class="p">;</span> <span class="c1">// may change even in a const object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// the returned reference is lvalue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">inline</span> <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">Screen</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">contents</span><span class="p">[</span><span class="n">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">Screen</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="n">pos</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="n">col</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">contents</span><span class="p">[</span><span class="n">r</span><span class="o">*</span><span class="n">width</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">Screen</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="n">c</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">pos</span> <span class="n">row</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">contents</span><span class="p">[</span><span class="n">row</span> <span class="o">+</span> <span class="n">c</span><span class="p">];</span> <span class="c1">// return character at the given column
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// specify inline on the definition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">inline</span> <span class="n">Screen</span><span class="o">&amp;</span> <span class="n">Screen</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pos</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">pos</span> <span class="n">row</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cursor</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// move cursor to the column within that row
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Screen</span><span class="o">::</span><span class="n">some_member</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="o">++</span><span class="n">access_ctr</span><span class="p">;</span> <span class="c1">// keep a count of the calls to any member function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Window_mgr</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">ScreenIndex</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Screen</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">clear</span><span class="p">(</span><span class="n">ScreenIndex</span><span class="p">);</span> <span class="c1">// reset the Screen at the given position to all blanks
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">ScreenIndex</span> <span class="nf">addScreen</span><span class="p">(</span><span class="k">const</span> <span class="n">Screen</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">Screen</span><span class="o">&gt;</span> <span class="n">screens</span> <span class="p">{</span> <span class="n">Screen</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">};</span> <span class="c1">// use = sign or inside braces
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Window_mgr</span><span class="o">::</span><span class="n">clear</span><span class="p">(</span><span class="n">ScreenIndex</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">screens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">   <span class="n">s</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">s</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// :: is needed before ScreenIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Window_mgr</span><span class="o">::</span><span class="n">ScreenIndex</span> <span class="n">Window_mgr</span><span class="o">::</span><span class="n">addScreen</span><span class="p">(</span><span class="k">const</span> <span class="n">Screen</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">screens</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">screens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">class</span> <span class="nc">Screen</span> <span class="n">myScreen</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span> <span class="c1">// this &#34;class&#34; word is useless
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">const</span> <span class="n">Screen</span> <span class="n">blank</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="sc">&#39;X&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">myScreen</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">).</span><span class="n">display</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">blank</span><span class="p">.</span><span class="n">display</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">Screen</span><span class="o">::</span><span class="n">pos</span> <span class="n">ht</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">wd</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// use the scope operator &#34;::&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Screen</span> <span class="n">scr</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">wd</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">scr</span><span class="p">.</span><span class="n">display</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The parameter name will hide the class member name which has the same name with it. So don&rsquo;t use a member name for a parameter or other local variable. If the compiler doesn’t find the name in function or class scope, it looks for the name in the surrounding scope.</p>
<ol start="5">
<li>We can often, but not always, ignore the distinction between whether a member is initialized or assigned. We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">ConstRef</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">ConstRef</span><span class="p">(</span><span class="ne">int</span> <span class="n">ii</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="ne">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="ne">int</span> <span class="n">ci</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="ne">int</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>For example, we write below code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ConstRef::ConstRef(int ii) { i = ii; ci = ii; ri = i; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>This will be wrong, the right way is using the constructor initializer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }
</span></span></code></pre></td></tr></table>
</div>
</div><p>The constructor initializer list sepcifies only the values, not the order in which those initializations are performed. Members are initialized in the order in which they appear in the class definition: the first member is initialized first, then next. It is a good idea to write constructor initializers in the same order as the members are declarde. Moreover, when possible, avoid using members to initialize other members.</p>
<ol start="6">
<li>C++ 11, the use of constructor initializers let us define the delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Sales_data</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">unsigned</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">double</span> <span class="n">price</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">           <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">cnt</span><span class="p">),</span> <span class="n">revenue</span><span class="p">(</span><span class="n">cnt</span><span class="o">*</span><span class="n">price</span><span class="p">){</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">//</span> <span class="n">delegating</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">():</span><span class="n">Sales_data</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">):</span><span class="n">Sales_data</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">unsigned</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>The default constructor is used automatically whenever an object is default or value initialized. It happens
（1）When we define nonstatic variables or arrays at block scope without initializers
（2）When a class that has members of class type uses the synthesized default constructor
（3）When members of class type are not explicitly initialized in a constructor initializer list
（4）During array initialization when we provide fewer initializers than the size of the array
（5）When we define a local static object without an initializer
（6）When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type uses an argument  of this kind to value initialize its element initializer.
Classes must have a default constructor in order to be used in these contexts. What may be less obvious is the impact on classes that have data members that do not have default constructor.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">NoDefault</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">NoDefault</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> <span class="o">//</span> <span class="n">this</span> <span class="k">class</span> <span class="n">has</span> <span class="n">no</span> <span class="n">default</span> <span class="n">constructor</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">A</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">NoDefault</span> <span class="n">my_mem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">A</span> <span class="n">a</span><span class="p">;</span>        <span class="o">//</span> <span class="n">error</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">synthesize</span> <span class="n">a</span> <span class="n">constructor</span> <span class="k">for</span> <span class="n">A</span>
</span></span><span class="line"><span class="cl"><span class="n">struct</span> <span class="n">B</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">B</span><span class="p">(){</span> <span class="p">}</span> <span class="o">//</span>  <span class="n">error</span><span class="p">:</span> <span class="n">no</span> <span class="n">initializer</span> <span class="k">for</span> <span class="n">b_member</span>
</span></span><span class="line"><span class="cl">   <span class="n">NoDefault</span> <span class="n">b_member</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The following declaration of obj is wrong. We should remove the empty parentheses.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Sales_data {
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Sales_data obj(); // ok, but defines a function, not an object
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>For automatically classs type conversion, only one class-type conversion is allowed. We can prevent use of a constructor in a context that requires an implict conversion by declaring constructor as explicit. The explicit keyword is meaningful only on constructors that can be called with a single argument. The explicit keyword is used only on the constructor declaration inside the class. When a constructor is declarde explicit, it can be used only with the direct form of initialization.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Sales_data</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">revenue</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">){</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// this constructor can not be used to implicitly create a Sales_data object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">explicit</span> <span class="nf">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">Sales_data</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">combine</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">unsigned</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="o">::</span><span class="n">combine</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">units_sold</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">revenue</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span> <span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// first, only one class-type conversion is allowed, so &#34;string&#34; can not be removed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// second, the explicit Sales_data constructor will prevent implicit conversion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//item.combine(string(&#34;&#34;));
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">item</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">Sales_data</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">));</span> <span class="c1">// force conversion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// explicit constructors can be used only for direct initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Sales_data item2 = string(&#34;&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>An aggregate class gives users direct access to its members and has special initialization syntax. It requires
（1）All of its data members are public
（2）It does not define any constructors
（3）It has no in-class initializers
（4）It has no base classes or virtual functions
We can initialize the data members of an aggregate class by providing a braced list of member initializers. If the list of initializers has fewer elements than the class has members, the trailing members are value initialized.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct Data{
</span></span><span class="line"><span class="cl">   int ival;
</span></span><span class="line"><span class="cl">   string s;
</span></span><span class="line"><span class="cl">};
</span></span><span class="line"><span class="cl">Data val = {0, &#34;Anna&#34;};
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>An aggregate class whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class:
（1）The data members all must have literal type
（2）The class must have at least one constexpr constructor
（3）If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression, or if the member has class type, the initializer must use the member&rsquo;s own constexpr constructor
（4）The class must use default definition for its destructor, which is the member that destroys objects of the class type.</li>
</ol>
<p>A constexpr constructor can be declared as = default. Otherwise, a constexpr constructor must meet the requirements of a constructor—meaning the only excutable statement it can have is a return statement. As a result, the body of a constexpr constructor is typically empty with the keyowd constexpr.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">class</span> <span class="n">Debug</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="o">//</span> <span class="n">a</span> <span class="n">constexpr</span> <span class="n">constructor</span> <span class="n">must</span> <span class="n">initialize</span> <span class="n">every</span> <span class="n">data</span> <span class="n">member</span>
</span></span><span class="line"><span class="cl">   <span class="n">constexpr</span> <span class="n">Debug</span><span class="p">(</span><span class="ne">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">true</span><span class="p">):</span> <span class="n">hw</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">io</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">other</span><span class="p">(</span><span class="n">b</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">   <span class="n">constexpr</span> <span class="n">Debug</span><span class="p">(</span><span class="ne">bool</span> <span class="n">h</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">i</span><span class="p">,</span> <span class="ne">bool</span> <span class="n">o</span><span class="p">):</span> <span class="n">hw</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">io</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">other</span><span class="p">(</span><span class="mi">0</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="n">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="ne">bool</span> <span class="n">hw</span><span class="p">;</span>    <span class="o">//</span> <span class="n">hardware</span> <span class="n">errors</span> <span class="n">other</span> <span class="n">than</span> <span class="n">IO</span> <span class="n">errors</span>
</span></span><span class="line"><span class="cl">   <span class="ne">bool</span> <span class="n">io</span><span class="p">;</span>    <span class="o">//</span> <span class="n">IO</span> <span class="n">errors</span>
</span></span><span class="line"><span class="cl">   <span class="ne">bool</span> <span class="n">other</span><span class="p">;</span> <span class="o">//</span> <span class="n">other</span> <span class="n">errors</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="11">
<li>Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. We say a member is associated with the class by adding the keyword static to its declaration. Static member functions are not bound to any object; they do not have a this pointer. As a result, static member functions may not be declared as const, and we may not refer to this in the body of a static member. Even though static members are not part of an object, we can use an object, reference or pointer to access static member.</li>
</ol>
<p>Because static data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class constructors. In general, we may not initialize a static member inside the class. Instead, we must define and initialize each static data member outside the class body. The best way to ensure that the object is defined once is to put the definition of static data members in the same file.</p>
<p>We can provide in-class initializers for static members that have const integral type and must do so for static members that are constexprs of literal type. The initializers must be constant expressions. If the member is used only in contexts where the compiler can substitute the member&rsquo;s value, then an initialized const or constexpr static need not be separately defined. Even if a const static data member is initialized in the class body, that member ordinarily should be defined outside the class definition.</p>
<p>A static data member can have incomplete type. In particular, a static data member can have the same type as the class type of which it is a member. A nonstatic data member is restricted to being declared as a pointer or a reference. Another difference between static and ordinary member is that we can use a static member as a default argument.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// we can use a static member as a default argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Account</span><span class="p">(</span><span class="kt">double</span> <span class="n">newAmount</span><span class="p">,</span> <span class="kt">double</span> <span class="n">newPeriod</span> <span class="o">=</span> <span class="n">period</span><span class="p">)</span><span class="o">:</span><span class="n">amount</span><span class="p">(</span><span class="n">newAmount</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">getAmount</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">amount</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">calculateAmount</span><span class="p">()</span> <span class="p">{</span> <span class="n">amount</span> <span class="o">+=</span> <span class="n">amount</span> <span class="o">*</span> <span class="n">interestRate</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="kt">double</span> <span class="nf">getRate</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">interestRate</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="kt">void</span> <span class="nf">setRate</span><span class="p">(</span><span class="kt">double</span> <span class="n">newRate</span><span class="p">)</span> <span class="p">{</span> <span class="n">interestRate</span> <span class="o">=</span> <span class="n">newRate</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">amount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="kt">double</span> <span class="n">interestRate</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="c1">// If it can be substituted, it need not be separated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">static</span> <span class="n">Account</span> <span class="n">account1</span><span class="p">;</span> <span class="c1">// ok, static member can have incomplete type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Account</span><span class="o">*</span> <span class="n">account2</span><span class="p">;</span> <span class="c1">// ok, pointer member can have incomplete type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// defined outside the class definition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="n">Account</span><span class="o">::</span><span class="n">interestRate</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">Account</span> <span class="n">account</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">Account</span><span class="o">::</span><span class="n">setRate</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">account</span><span class="p">.</span><span class="n">calculateAmount</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">account</span><span class="p">.</span><span class="n">getAmount</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="the-io-library">The IO Library</h2>
<ol>
<li>To support different kinds of IO processing, the library defines a collection of IO types:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">iostream    istream, wistream reads from a stream
</span></span><span class="line"><span class="cl">   　　    ostream, wostream writes to a stream
</span></span><span class="line"><span class="cl">   　　    iostream, wiostream reads and writes a stream
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fstream     ifstream, wifstream reads from a file
</span></span><span class="line"><span class="cl">           ofstream, wofstream writes to a file
</span></span><span class="line"><span class="cl">           fstream, wfstream reads and writes to a file
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sstream     istringstream, wistringstream reads from a string
</span></span><span class="line"><span class="cl">   　　    ostringstream wostringstream writes to a string
</span></span><span class="line"><span class="cl">   　　    stringstream, wstringstream reads and writes a string
</span></span></code></pre></td></tr></table>
</div>
</div><p>The library lets us ignore differences among these kinds of streams by using inheritance. The types ifstream and istringstream inherit from istream. Thus, we can use objects of type ifstream or istringstream as if they were istream objects. For example, we can call getline on an ifstream or istringstream object, and we can use &raquo; to read data from an ifstream or istringstream.</p>
<p>Because we can&rsquo;t copy the IO types, we cannot have a parameter or return type that is one of the stream types. Functions that do IO typically pass and return the stream through references. Reading or writing an IO object change its state, so the reference must not be const. The library can let us manipulate the condition state of a stream:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">strm::iostate       strm is one of the IO types. iostate is a machine-dependent
</span></span><span class="line"><span class="cl">                   integral type that represents the condition state of a stream
</span></span><span class="line"><span class="cl">strm::badbit        iostate value used to indicate that a stream is corrupted
</span></span><span class="line"><span class="cl">strm::failbit       iostate value used to indicate that an IO operation failed
</span></span><span class="line"><span class="cl">strm::eofbit        iostate value used to indicate that a stream hit end-of-file
</span></span><span class="line"><span class="cl">strm::goodbit       iostate value used to indicate that a stream is not in an error state,
</span></span><span class="line"><span class="cl">                   it is 0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">s.eof()             true if eofbit in the stream s is set
</span></span><span class="line"><span class="cl">s.fail()            true if failbit or badbit in the stream s is set
</span></span><span class="line"><span class="cl">s.bad()             true if badbit in the stream s is set
</span></span><span class="line"><span class="cl">s.good()            true if the stream s is in a valid state
</span></span><span class="line"><span class="cl">s.clear()           reset all condition values in the stream s to valid state, return void
</span></span><span class="line"><span class="cl">s.clear(flags)      reset the condition of s to flags.Type of flags is iostate,return void
</span></span><span class="line"><span class="cl">s.setstate(flags)   add specified condition to s. Types of flags is iostate, return void
</span></span><span class="line"><span class="cl">s.rdstate()         return current condition of s as a iostate value
</span></span></code></pre></td></tr></table>
</div>
</div><p>Once an error has occurred, subsequent IO operations will fail. The easiest way to determine the state of a stream:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">while (cin &gt;&gt; word)  // ok: read operation successful...
</span></span></code></pre></td></tr></table>
</div>
</div><p>The while condition checks the state of the stream returned from the &raquo; expression.  This only tells us whether the stream is valid. If we want to know why the stream is valid, we can convey information with the iostate. To turn off a single condition, we use the rdstate member and the bitwise operators to produce the desired new state.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// turns off failbit and badbit but all other bits unchanged
</span></span><span class="line"><span class="cl">cin.clear(cin.rdstate() &amp; ~cin.failbit &amp; ~cin.badbit);
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each output stream manages a buffer, which it uses to hold the data that the program reads and writes. Using a buffer allows the OS to combine several output operations into a single system-level write. There are several conditions that cause the buffer to be flushed, such as the program completes normally, the buffer become full, we use a flush operation such as endl. Or an output stream might be tied to another stream. In this case, the buffer of the tied stream is flushed whenever the tied stream is read or written. By default, cin and cerr are both tied to cout. Hence, reading cin or writing to cerr flushes the buffer in cout. If we want to flush after every output, we can use the unitbuf manipulator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cout &lt;&lt; unitbuf; // all writes will be flushed immediately
</span></span><span class="line"><span class="cl">   cout &lt;&lt; nounitbuf; // returns to normal buffering
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;hello&#34; &lt;&lt; endl; // writes data and a newline, then flushes the buffer
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;year&#34; &lt;&lt; ends; // writes data and a null, then flushes the buffer
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;world&#34; &lt;&lt; flush; // writes data, then flushes the buffer
</span></span><span class="line"><span class="cl">   cout &lt;&lt; &#34;123&#34; &lt;&lt; endl;
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are two versions of tie: one version takes no argument and returns a pointer to the output stream, if any, to which this object is currently tied. The function returns the null pointer if the stream is not tied. The second version of tie takes a pointer to an ostream and ties itself to that ostream. That is, x.tie(&amp;o) ties the stream x to the output stream o. We can tie either an istream or an ostream object to another ostream:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cin.tie(&amp;cout); // the library has tied cin and cout for us
</span></span><span class="line"><span class="cl">ostream *old_tie = cin.tie(nullptr); // cin is no longer tied
</span></span><span class="line"><span class="cl">cin.tie(&amp;cerr); // reading cin flushes cerr, not cout
</span></span><span class="line"><span class="cl">cin.tie(old_tie); // reestablish normal tie
</span></span></code></pre></td></tr></table>
</div>
</div><p>To tie a  given stream to a new output stream, we pass tie a pointer to the new stream. To untie the stream completely, we pass a null pointer. Each stream can be tied to at most one stream at a time. However, multiple streams can tie themselves to the same ostream.</p>
<ol start="2">
<li>In addition to the behavior that they inherit from iostream types, the types defined in fstream has more operations.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fstream fstrm;              create an unbound file stream.
</span></span><span class="line"><span class="cl">fstream fstrm(s);           create an fstream and open the file named s.
</span></span><span class="line"><span class="cl">fstream fstrm(s, mode)      like above, but open s in the given mode.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">fstrm.open(s)               open the file and bind the file to fstrm
</span></span><span class="line"><span class="cl">fstrm.open(s, mode)         like above
</span></span><span class="line"><span class="cl">fstrm.close()               close the file to which fstream is bound
</span></span><span class="line"><span class="cl">fstrm.is_open()             return a bool indicating whether the file associated with fstrm
</span></span><span class="line"><span class="cl">                           was successfully opened and has not been closed.
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we want to read or write a file, we define a file stream object and associate that object with the file. Each file stream class defines a member function named open that does whatever system-specific operations are required to locate the given file and open it for reading or writing as appropriate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">fileName</span> <span class="o">=</span> <span class="s">&#34;d://a.txt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ifstream</span> <span class="n">input</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span> <span class="c1">// construct an ifstream and open the given file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;open fail:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">good</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">output</span><span class="p">;</span> <span class="c1">// output file stream that is not associated with any file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">output</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s">&#34;.copy&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="c1">// if open fail, failbit is set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;open success:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">output</span><span class="p">.</span><span class="n">good</span><span class="p">()</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Once a file stream has been opened, it remains associated with the specified file. Indeed, calling open on a file stream that is already open will fail and set failbit. Subsequent attempts to use that file stream will fail. To associate a file stream with a different file, we must first close the existing file.</p>
<p>Each stream has an associated file mode that represents how the file may be used. The following are some file modes:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">in      open for input
</span></span><span class="line"><span class="cl">out     open for output
</span></span><span class="line"><span class="cl">app     seek to the end before every write
</span></span><span class="line"><span class="cl">ate     seek to the end immediately after the open
</span></span><span class="line"><span class="cl">trunc   truncate the file
</span></span><span class="line"><span class="cl">binary  do IO operations in binary mode
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can supply a file mode whenever we open a file. The modes that we can specify have the following restrictions:
（1）out may be set only for an ofstream or fstream object
（2）in may be set only for an ifstream or fstream object
（3）trunc may be set only when out is also specified.
（4）app mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode.
（5）by default, a file opened in out mode is truncated even if we do not specify trunc. To preserve the contents of a file opened with out, either we specify app, or we must also specify in and the file is open for both input and output.
（6）the ate and binary mode may be specified on any file stream object type and in combination with any other file modes.
Each file stream type defines a default file mode that is used whenever we do not otherwise specify a mode. Files associated with an ifstream are opened in in mode; files associated with an ofstream are opened in out mode; and files associated with an fstream are opened with both in and out modes. By default, when we open an ofstream, the contents of the file are discarded. We can use app mode to prevent this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">fileName</span> <span class="o">=</span> <span class="s">&#34;d://a.txt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">out1</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span> <span class="c1">// out and trunc are implicit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">out1</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">out2</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">trunc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">out2</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">app1</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">app</span><span class="p">);</span> <span class="c1">// out is implicit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">app1</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">app2</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">app</span> <span class="o">|</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">app2</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">out</span><span class="p">;</span> <span class="c1">// no file mode is set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">out</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">out</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> <span class="c1">// close out so we can use it for a different file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">out</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s">&#34;.copy&#34;</span><span class="p">,</span> <span class="n">ofstream</span><span class="o">::</span><span class="n">app</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">out</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The file mode of a given stream may change each time a file is opened.</p>
<ol start="3">
<li>The istringstream type reads a string, ostringstream writes a string, and stringstream reads and writes the string. In addition to the operations they inherit from iostream, there are some new members:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">sstream strm;       strm is an unbound stringstream. sstream is one of the types.
</span></span><span class="line"><span class="cl">sstream strm(s);    strm is an sstream that holds a copy of the string s.
</span></span><span class="line"><span class="cl">strm.str()          returns a copy of the string that strm holds
</span></span><span class="line"><span class="cl">strm.str(s)         copies the string s into strm. returns void.
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that fstream and sstream share the interface to iostream, but they have no other interrelationship. In particular, we cannot use open and close on a stringstream, nor can we use str on an fstream. An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line.  An ostringstream is useful when we need to build up our output a little at a time but do not want to print output until later.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">PersonInfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">phones</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">line</span><span class="p">,</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">PersonInfo</span><span class="o">&gt;</span> <span class="n">people</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// example: lee 15288488907 6235106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">line</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">PersonInfo</span> <span class="n">info</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">istringstream</span> <span class="n">record</span><span class="p">(</span><span class="n">line</span><span class="p">);</span> <span class="c1">// bind record to the line we read
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">record</span> <span class="o">&gt;&gt;</span> <span class="n">info</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">while</span> <span class="p">(</span><span class="n">record</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">           <span class="n">info</span><span class="p">.</span><span class="n">phones</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="n">people</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ostringstream</span> <span class="n">formatted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">entry</span><span class="p">:</span> <span class="n">people</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="n">formatted</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">p</span><span class="p">:</span> <span class="n">entry</span><span class="p">.</span><span class="n">phones</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">           <span class="n">formatted</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="n">formatted</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">fileName</span> <span class="o">=</span> <span class="s">&#34;d://a.txt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">formatted</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="sequential-containers">Sequential Containers</h2>
<ol>
<li>A container holds a collection of objects of a specified type. The sequential containers let the programmer control the order in which the elements are stored and accessed. The order corresponds to the position at which elements are put into container.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector          flexible-size array. supports fast random access.
</span></span><span class="line"><span class="cl">           　　inserting or deleting elements other than at the back may be slow.
</span></span><span class="line"><span class="cl">deque           double-ended queue. supports fast random access.
</span></span><span class="line"><span class="cl">           　　fast insert/delete at front or back.
</span></span><span class="line"><span class="cl">list            doubly linked list, supports only bidirectional sequential access.
</span></span><span class="line"><span class="cl">           　　fast insert/delete at any point in the list.
</span></span><span class="line"><span class="cl">forward_list    singly linked list. supports only sequential access in one direction.
</span></span><span class="line"><span class="cl">           　　fast insert/delete at any point in the list.
</span></span><span class="line"><span class="cl">array           fixed-size array. support fast random access.
</span></span><span class="line"><span class="cl">           　　cannot add or remove elements.
</span></span><span class="line"><span class="cl">string          a specialized container, similar to vector, that contains characters.
</span></span><span class="line"><span class="cl">           　　fast random access. fast insert/delete at the back.
</span></span></code></pre></td></tr></table>
</div>
</div><p>The sequential containers, which are listed above, all provide fast sequential access to their elements. However, these containers offer different performance trade-offs relative to:</p>
<p>（1）The costs to add or delete elements to the container
（2）The costs to perform nonsequential access to elements of the container</p>
<p>With the exception of array, which is a fixed-size container, the containers provide efficient, flexible memory management. We can add and remove elements, growing and shrinking the size of the container.</p>
<ol start="2">
<li>
<p>For example, string and vector hold their elements in contiguous memory. Because elements are contiguous, it is fast to compute the address of an element from its index. However, adding or removing elements in the middle of one of these containers takes time: All the elements after the one inserted or removed have to be moved to maintain contiguity. Moreover, adding an element can sometimes require that additional storage be allocated. In that case, every element must be moved into the new storage.</p>
</li>
<li>
<p>The list and forward_list containers are designed to make it fast to add or remove an element anywhere in the container. In exchange, these types do not support random access to elements: we can access an element only by iterating through the container. Moreover, the memory overhead for these containers is often substantial, when compared to vector, deque and array.</p>
</li>
<li>
<p>A deque is a more complicated data structure. Like string and vector, deque supports fast random access. As with string and vector, adding or removing elements in the middle of a deque is a expensive operation. However, adding or removing elements at either end of the deque is a fast operation, comparable to adding an element to a list or forward_list.</p>
</li>
<li>
<p>C++ 11, the forward_list and array types were added by the new standard. An array is a safer, easier-to-use alternative to built-in arrays. Like built-in arrays, library array have fixed size. As a result, array does not support operations to add and remove elements or to resize the container. A forward_list is intended to be comparable to the best handwritten, singly linked list. Consequently, forward_list does not have the size operation because storing or computing its size would entail overhead compared to a handwritten list.</p>
</li>
<li>
<p>A few rules of thumb that apply to selecting which container to use:
（1）Unless you have a reason to use another container, use a vector
（2）If your program has lots of small elements and space overhead matters, don&rsquo;t use list or forward_list
（3）If the program requires random access to elements, use a vector or a deque
（4）If the program needs to insert or delete elements in the middle of the container, use a list or forward_list
（5）If the program needs to insert or delete elements at the front and the back, but not in the middle, use a deque
（6）If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements: First, decide whether you actually need to add elements in the middle of a container. It is often easier to append to a vector and then call the library sort function to reorder the container when you&rsquo;re done with input. If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.</p>
</li>
</ol>
<p>What if the program needs random access and needs to insert and delete elements in the middle of the container ? This decision will depend on the relative cost of accessing the elements in a list or forward_list versus the cost of inserting or deleting elements in a vector.</p>
<ol start="7">
<li>All the iterators on the standard container types let us access an element by providing the dereference operator. Similarly, the iterators for the library containers all define the increment operator to move from one element to the next. The exception is that the forward_list iterators do not support the decrement(&ndash;) operator. An iterator range is denoted by a pair of iterators each of which refers to an element, or to one past the last element, in the same container. These two iterators, often refered to as begin and end. This element range is called a left-inclusive interval. The standard notation is: [begin, end).
（1）If begin equals end, the range is empty
（2）If begin is not equal to end, there is at least one element in the range
（3）We can increment begin some number of times until begin == end
There are several version of begin and end: The versions with an r return reverse iterators, with a c return the const version of the related iterator. The functions that do not begin with a c are overloaded. That is, there are actually two members named begin. One is a const member that returns the container&rsquo;s const_iterator type. The other is nonconst and returns the container&rsquo;s iterator type. Similarly for rbegin, end and rend.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">list</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Milton&#34;</span><span class="p">,</span> <span class="s">&#34;Shakespeare&#34;</span><span class="p">,</span> <span class="s">&#34;Austen&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="c1">// list&lt;string&gt;::iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="c1">// list&lt;string&gt;::reverse_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it3</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="c1">// list&lt;string&gt;::const_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it4</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">crbegin</span><span class="p">();</span> <span class="c1">// list&lt;string&gt;::const_reverse_iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it1</span> <span class="o">&lt;&lt;</span> <span class="n">ends</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it2</span> <span class="o">&lt;&lt;</span> <span class="n">ends</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it3</span> <span class="o">&lt;&lt;</span> <span class="n">ends</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The c versions were introduced by new standard to support using auto with begin and end functions.
Note: when write access is not needed, use cbegin and cend.</p>
<ol start="8">
<li>We can create a new container by directly copying the container, or copying a range of elements denoted by a pair of iterators, but the container and element types must match. We can use the constructor that takes a size argument if the element type is a built-in type or a class type that has a default constructor. If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size. The constructors that take a size are valid only for sequential containers. Although we cannot copy or assign objects of built-in array types, there is no such restriction on array.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;forward_list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// list initialize a container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Milton&#34;</span><span class="p">,</span> <span class="s">&#34;Shakespeare&#34;</span><span class="p">,</span> <span class="s">&#34;Austen&#34;</span><span class="p">};</span> 
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">articles</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;an&#34;</span><span class="p">,</span> <span class="s">&#34;the&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list1</span><span class="p">(</span><span class="n">authors</span><span class="p">);</span> <span class="c1">// copy container with constructor, type must match
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">forward_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">(</span><span class="n">articles</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">articles</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// convert to string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 10 elements, each initialized to -1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">);</span> <span class="c1">// 10 strings, each element is &#34;hi&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 10 elements, each initialized to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">deque</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 10 elements, each initialized to an empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">arr1</span><span class="p">;</span> <span class="c1">// array holds 10 ints, all elements are 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">array</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">arr2</span><span class="p">;</span> <span class="c1">// array holds 10 strings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">arr3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// remaining elements are 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">digits</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span> <span class="c1">// can not be copied
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">arr1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">arr4</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">;</span> <span class="c1">// array container can be copied
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------assign--------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// because the existing elements are replaced, the iterators passed to assign must not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// refer to the container on which assign is called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">forward_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">myWords</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">myWords</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">articles</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">articles</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// use assign to replace elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">slist1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// one element, which is the empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">slist1</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#34;xy&#34;</span><span class="p">);</span> <span class="c1">// 10 elements, each one is &#34;xy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">slist1</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">slist1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">slist1</span><span class="p">.</span><span class="n">max_size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------swap----------------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// The swap operation exchanges the contents of two containers of the same type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// excepting array, swap does not copy, delete, or insert any elements, so it is fast
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// It is best to use the nonmember version of swap rather than member version of swap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sv1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sv2</span><span class="p">(</span><span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">swap</span><span class="p">(</span><span class="n">sv1</span><span class="p">,</span> <span class="n">sv2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sv2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>Comparing two containers performs a pairwise comparison of the elements.
（1）If both containers are the same size and all the elements are equal,  then they are equal; otherwise not equal.
（2）If the containers have different size but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.
（3）If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">vector&lt;int&gt; v1 = {1, 3, 5, 7, 9, 12};
</span></span><span class="line"><span class="cl">   vector&lt;int&gt; v2 = {1, 3, 9};
</span></span><span class="line"><span class="cl">   vector&lt;int&gt; v3 = {1, 3, 5, 7};
</span></span><span class="line"><span class="cl">   vector&lt;int&gt; v4 = {1, 3, 5, 7, 9, 12};
</span></span><span class="line"><span class="cl">   cout &lt;&lt; (v1 &lt; v2) &lt;&lt; endl; // true
</span></span><span class="line"><span class="cl">   cout &lt;&lt; (v1 &lt; v3) &lt;&lt; endl; // false
</span></span><span class="line"><span class="cl">   cout &lt;&lt; (v1 == v4) &lt;&lt; endl; // true
</span></span><span class="line"><span class="cl">   cout &lt;&lt; (v1 == v2) &lt;&lt; endl; // false
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>The previous section covered operations common to all containers. We&rsquo;ll cover operations to sequential containers. Excepting array, all of the library containers provide flexible memory management. The following is the operator to access elements in a sequential container.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">c.back()    Returns a reference to the last element in c. 
</span></span><span class="line"><span class="cl">           Undefined if c is empty.
</span></span><span class="line"><span class="cl">c.front()   Returns a reference to the first element in c. 
</span></span><span class="line"><span class="cl">           Undefined if c is empty.
</span></span><span class="line"><span class="cl">c[n]        Returns a reference to the element indexed by unsigned n. 
</span></span><span class="line"><span class="cl">           Undefined if n &gt;= c.size().
</span></span><span class="line"><span class="cl">c.at[n]     Returns a reference to the element indexed by n. 
</span></span><span class="line"><span class="cl">           If the index is out of range, throws out_of_range exception.
</span></span></code></pre></td></tr></table>
</div>
</div><p>Container operations may invalidate iterators. An invalidated pointer, reference, or iterator is one that no longer  denotes an element, using it is a serious programming error as using an uninitialized pointer. After adding elements to a container</p>
<p>（1）iterator, pointer, and reference to a vector or string are invalid if the container was reallocated. If no reallocation happens, indirect references to elements before insertion remain valid; those to elements after insertion are invalid.
（2）iterator, pointer, and reference to a deque are invalid if we add elements anywhere but at the front or back. If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not
（3）iterator, pointer, and reference to a list or forward_list remain valid When we add or remove elements in a vector or string, or add elements or remove any but the first element in a deque, the iterator returned by end() is always invalidated. Thus, loops that add or remove elements should always call end() rather than use a stored copy.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;forward_list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;deque&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">T</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Item</span><span class="p">(</span><span class="kt">int</span> <span class="n">_id</span><span class="p">,</span> <span class="n">string</span> <span class="n">_name</span><span class="p">)</span><span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="n">_id</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">_name</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------push_back----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">numStr</span> <span class="o">=</span> <span class="s">&#34;45&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">numStr</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;6&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">numStr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------push_front---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// list, forward_list, deque
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">list1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">list1</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">list1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------insert--------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;world&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">svec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">svec1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="s">&#34;hello&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">svec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">svec1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#34;-&#34;</span><span class="p">);</span> <span class="c1">// insert three elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec2</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;how&#34;</span><span class="p">,</span> <span class="s">&#34;are&#34;</span><span class="p">,</span> <span class="s">&#34;you&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// must not refer to the same container as the one we are changing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// C++ 11, insert that take a count or a range return an iterator to the first element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// that was inserted. If no elements are inserted, return its first parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">svec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">svec1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">svec2</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">svec2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">svec1</span><span class="p">);</span> <span class="c1">// hello world - - - how are you
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">svec1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="s">&#34;ok&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">svec1</span><span class="p">);</span> <span class="c1">// hello world - - - ok how are you
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------emplace_front, emplace, emplace_back------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// when we call push or insert, we pass objects and those objects are copied into 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// container. C++ 11, emplace members use arguments to construct an element 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// directly in space managed by container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">nums</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">nums</span><span class="p">.</span><span class="n">emplace_front</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">nums</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span> <span class="c1">// use the Item default constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">items</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;Tom&#34;</span><span class="p">);</span> <span class="c1">// convert to Item type implicitly
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">items</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34;Newbie&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">items</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Item</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&#34;Jenny&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">item_size</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;item size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item_size</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----Access Elements Operator: back(), front(), [n], at(n)-----
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">items</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">Item</span> <span class="n">first</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">Item</span> <span class="n">last</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;first id:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">first</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; name:&#34;</span> <span class="o">+</span> <span class="n">items</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;last id:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">last</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; name:&#34;</span> <span class="o">+</span> <span class="n">items</span><span class="p">[</span><span class="n">item_size</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------pop_front, pop_back-----------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// pop_front and pop_back functions remove the first and last element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// forward_list has only push_front, so it also has only pop_front, no size operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// There is no push_front for vector and string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">rlist</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">rlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------erase, clear--------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// erase member remove element at a specified point in the container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// return an iterator referring to the location after the removed element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">elist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">elist</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span><span class="p">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">elist</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="n">it</span> <span class="o">=</span> <span class="n">elist</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="c1">// if *it is odd, remove it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">else</span>
</span></span><span class="line"><span class="cl">           <span class="o">++</span><span class="n">it</span><span class="p">;</span> <span class="c1">// it *it is even, increment it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">elist</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">elist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// remove all elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">elist</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// also remove all elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;elist:&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">elist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----forward_list: insert_after, emplace_after, erase_after-----
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// forward_list also defines before_begin, returns an off-the-beginning iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">flist</span><span class="p">.</span><span class="n">before_begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">flist</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">flist</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">curr</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="n">curr</span> <span class="o">=</span> <span class="n">flist</span><span class="p">.</span><span class="n">erase_after</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">           <span class="o">++</span><span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;flist:&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">flist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------resize--------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// If current size is greater than requested size, elements are deleted from the back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// If the current size is less than new size, elements are added to the back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">zlist</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">zlist</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">zlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">zlist</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">zlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">zlist</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">zlist</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------iterator, reference, pointer may be invalidated------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="c1">// we can not store vi.end() to use it here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="n">it</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="c1">// duplicate current element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="n">it</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">           <span class="c1">// insert inserts before it, then refresh iterator to prevent invalidated it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="n">it</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;vi:&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------reserve, shrink_to_fit------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// The reserve tell the container how many elements it can hold before allocating more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// space. The reserve affects only how much memory the vector preallocate. It changes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// capacity only if the requested space exceeds the current capacity. Resize operation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// changes only the number of elements in the container, it may also change capacity.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// C++ 11, we can call shrink_to_fit to ask a deque, vector, or string to return 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// unneeded memory. Remember that:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// shrink_to_fit() is only a request, there is no guarantee it will work.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivx</span><span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">ivx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">// often double the current capacity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">ivx</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">ivx</span><span class="p">.</span><span class="n">shrink_to_fit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; capacity:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ivx</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------string: substr-----------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// substr throws an out_of_range exception if position exceeds the size of the string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span> <span class="o">=</span> <span class="s">&#34;Hello World&#34;</span><span class="p">;</span> <span class="c1">// null terminated array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">char</span> <span class="n">noNullArray</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s1</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span> <span class="c1">// copy up to the null in cp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s2</span><span class="p">(</span><span class="n">noNullArray</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// copy two characters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s3</span><span class="p">(</span><span class="n">noNullArray</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">s4</span><span class="p">(</span><span class="n">cp</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;s4:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s4</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s5</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s6</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s7</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s6</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">s7</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">xx</span> <span class="o">=</span> <span class="s">&#34;a&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">xx</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">xx</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">);</span> <span class="c1">// insert two characters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;xx:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">xx</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">xx</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">xx</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// erase last one characters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;xx:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">xx</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cx</span> <span class="o">=</span> <span class="s">&#34;Go Go Go, Oh lai Oh lai Oh Lai&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">cxp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cxp</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// assign 5 characters starting with the one pointed to by cx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;cxp:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">cxp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cxp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">cxp</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">cx</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// insert before the element at cxp[size()]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;cxp:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">cxp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">cxps</span> <span class="o">=</span> <span class="s">&#34;[]&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cxps</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cxp</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">cxp</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="c1">//insert cxp to cxps at the position before cxps[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;cxps:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">cxps</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//--string: append, replace, find, rfind, find_first_of, find_last_of--
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">as</span> <span class="o">=</span> <span class="s">&#34;C++&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">as</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">as</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&#34; Primer&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">as</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#34; 4th Edition&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">as</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">as</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;4&#34;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;5&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">as</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// find the first position that is a number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">as</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&#34;0123456789&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;position:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">as</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">ns</span> <span class="o">=</span> <span class="s">&#34;999123abc321&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// find first position that is not in numbers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">pos</span> <span class="o">=</span> <span class="n">ns</span><span class="p">.</span><span class="n">find_first_not_of</span><span class="p">(</span><span class="s">&#34;0123456789&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// find from right to left, with a start position argument
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">rpos</span> <span class="o">=</span> <span class="n">ns</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="n">ns</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ns</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">rpos</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------------string: compare---------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">c1</span> <span class="o">=</span> <span class="s">&#34;abc&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;equal value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&#34;abc&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;greater value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&#34;ab&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;less value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">&#34;abcd&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">c2</span> <span class="o">=</span> <span class="s">&#34;1abc2&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// position from 0 in c1, from 1 in c2, both 3 elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c1</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------to_string, stoi, stof, stod----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// If the string can&#39;t be converted to a number, throw an invalid_argument exception
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// If the conversion generates a value that can&#39;t be represented, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// throw out_of_range exception
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//string s = to_string(i);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//double d = stod(s);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//--Sequential Container Adaptors: stack, queue, priority_queue--
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// adaptor: Library type, function, or iterator that, given a type, function, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// or iterator, make it act like another. both stack and queue are implemented
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// on deque, priority_queue is implemented on a vector.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">deq</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">(</span><span class="n">deq</span><span class="p">);</span> <span class="c1">// copy from deq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// we can also use other container to implement a stack by naming a container as a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// second type argument. There are constraints on which containers can be used for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// a given adaptor, all of the adaptors require ability to add and remove elements.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// So they cannot be built on array. Similarly, we cannot use forward_list, because
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// all of the adaptors require operations that add, remove, or access the last
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// element in the container.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// (1) A stack requires push_back, pop_back, and back, so we can use any of the 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//     remaining types for it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// (2) The queue adaptor requires back, push_back, front, and push_front, so it 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//     can be built on a list or deque but not on a vector.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// (3) A priority_queue requires random access, front, push_back, pop_back. It can 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//     be built on a vector or a deque but not on a list.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">stack</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">str_stk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;stk top value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">stk</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">(</span><span class="n">deq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;que front value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;que back value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">que</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">priority_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ends</span><span class="p">;</span> <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When we use these operations, we must remember that the containers use different strategies for allocating elements and that affect performance. Adding elements anywhere but at the end of a vector or string, or anywhere but the beginning or end of a deque, requires elements to be moved. Moreover, adding elements to a vector or string may cause the entire object to be reallocated.  Reallocating an object requires allocating new memory and moving elements from the old space to the new.</p>
<h2 id="generic-algorithms">Generic Algorithms</h2>
<ol>
<li>Most of algorithms are defined in the algorithm header, some numeric algorithms are defined in the numeric header.</li>
<li>Iterators make the algorithm container independent &hellip; but algorithm depend on element-type operations. Algorithms never execute container operations, they operate in terms of iterators and iterator operations. The aim of this design is to separate algorithms and operation provided by member function. Cause algorithms operate on iterators, not containers. Thus, an algorithm cannot (directly) add or remove elements.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delim</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">delim</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">elems</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">elems</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------find---------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">v1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v1</span><span class="p">);</span> <span class="c1">// find in vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">result1</span> <span class="o">==</span> <span class="n">s1</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="s">&#34; is not present&#34;</span> <span class="o">:</span> 
</span></span><span class="line"><span class="cl">       <span class="s">&#34; is present&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="n">v2</span> <span class="o">=</span> <span class="sc">&#39;v&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s2</span>  <span class="o">=</span> <span class="s">&#34;very much&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// find in string, with iterator range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v2</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">result2</span> <span class="o">==</span> <span class="n">s2</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="s">&#34; is not present&#34;</span> <span class="o">:</span> 
</span></span><span class="line"><span class="cl">       <span class="s">&#34; is present&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="n">v3</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="n">s3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;v&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">result3</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">s3</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">s3</span><span class="p">),</span> <span class="n">v3</span><span class="p">);</span> <span class="c1">// find in built-in array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;The value &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v3</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">result3</span> <span class="o">==</span> <span class="n">end</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span> <span class="o">?</span> <span class="s">&#34; is not present&#34;</span> <span class="o">:</span> 
</span></span><span class="line"><span class="cl">       <span class="s">&#34; is present&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------count---------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">char</span> <span class="n">v4</span> <span class="o">=</span> <span class="sc">&#39;i&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">s4</span> <span class="o">=</span> <span class="s">&#34;This is a good idea!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// count nums of v4 in s4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;count result:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span><span class="p">(</span><span class="n">s4</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s4</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------accumulate------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// initial sum is 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;accumulate int:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">s1</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v5</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;accumulate string:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">v5</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v5</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">dd</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// &#34;.f&#34; is important
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;accumulate double:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">dd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dd</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mf">0.f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------equal---------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// whether two sequences hold the same values, element type can be different as we use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// == to compare. It assumes that the second sequence is at least as big as the first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">v6</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;x&#34;</span><span class="p">,</span> <span class="s">&#34;y&#34;</span><span class="p">,</span> <span class="s">&#34;z&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;equal result:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">equal</span><span class="p">(</span><span class="n">v5</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v5</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">v6</span><span class="p">.</span><span class="n">cbegin</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------fill, fill_n------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">fill</span><span class="p">(</span><span class="n">v6</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v6</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="s">&#34;-&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v6</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v7</span><span class="p">;</span> <span class="c1">// empty vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">fill_n</span><span class="p">(</span><span class="n">v7</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v7</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// reset all elements to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//back_inserter return an insert iterator bound that container. When we assign through
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the iterator, the assignment calls push_back to add an element with the given value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//to the container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="n">it</span> <span class="o">=</span> <span class="mi">35</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;v7 size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v7</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">v7</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//frequently use back_inserter to create an iterator to use as destination of an
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//algorithm. fill_n cannot change the size of container, back_inserter will use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the member &#34;push_back&#34; of the container to change container size,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//but back_inserter is an iterator adaptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">v7</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">fill_n</span><span class="p">(</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">v7</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// append 10 elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">v7</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v7</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------copy---------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="n">v8</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">v8x</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">v8</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">v8</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// copy v8 into v8x, return iterator past the last element in v8x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v8</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v8</span><span class="p">),</span> <span class="n">v8x</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------replace, replace_copy-------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">replace</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v8x</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v8x</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span> <span class="c1">// replace any element 0 with 9
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v8x</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v8x</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//if we do not want to change origional sequence, we can call replace_copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v9</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="s">&#34;q&#34;</span><span class="p">,</span> <span class="s">&#34;q&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v9x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// result will store at v9x, v9 is not changed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">replace_copy</span><span class="p">(</span><span class="n">v9</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v9</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v9x</span><span class="p">),</span> <span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="s">&#34;q&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">v9x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v9x</span><span class="p">.</span><span class="n">end</span><span class="p">(),[](</span><span class="n">string</span> <span class="n">s</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------sort, unique---------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="s">&#34;the quick red fox jumps over the slow red turtle&#34;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//Once sorted, the unique rearrange the input range to &#34;eliminate&#34; adjacent duplicated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//entries. size of words is unchanged, &#34;eliminate&#34; means that it overwrites adjacent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//duplicates so that the unique elements appear at the front of the sequence.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//note: algorithm only operate on iterators, not containers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//So they cannot(directly) add or remove elements.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">end_unique</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//because algorithms cannot do container operations, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//we&#39;ll use erase to actually remove elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">words</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">end_unique</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">string</span> <span class="n">s</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Algorithms compare elements default use either the element type&rsquo;s &lt; or == operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Employee</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Employee</span><span class="p">(</span><span class="kt">int</span> <span class="n">_age</span><span class="p">,</span> <span class="n">string</span> <span class="n">_name</span><span class="p">)</span> <span class="o">:</span> <span class="n">age</span><span class="p">(</span><span class="n">_age</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">_name</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// this class is used for sorting, also it can record some states if you need
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">EmployeeSortByAge</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// this function is just for sorting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">isShorter</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------stable_sort, sort-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">centence</span> <span class="o">=</span> <span class="s">&#34;what do you think about this problem&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">istringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">centence</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">svec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">copy</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ss</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">svec</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// sort by alphabetical order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// stable_sort preserve the physical order of semantically equivalent values, while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// sort doesn&#39;t. stable_sort maintains the original alphabetical order among those
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// elements that have the same length. Actually, we can not see difference 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// here if we use sort. This makes me confused ... Where is the equality ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">stable_sort</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">isShorter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">copy</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employees1</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="n">Employee</span><span class="p">(</span><span class="mi">108</span><span class="p">,</span> <span class="s">&#34;Zaphod&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="n">Employee</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="s">&#34;Arthur&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="n">Employee</span><span class="p">(</span><span class="mi">108</span><span class="p">,</span> <span class="s">&#34;Ford&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// the 3rd parameter is a function object that takes two arguments.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">employees1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">employees1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">EmployeeSortByAge</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">employees1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">employees1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">age</span>
</span></span><span class="line"><span class="cl">       <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// greater_equal, less, less_equal, equal_to, not_equal_to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------partition-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the partition will separate elements into two parts with the condition
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// you can use stable_partition if you care about original order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">firstIt</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------partial_sort-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">partial_sort</span><span class="p">(</span><span class="n">firstIt</span><span class="p">,</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------nth_element-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Rearranges elements in the range, in such a way that the element at the nth element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//is the element that would be in that position in a sorted sequence.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">elements</span> <span class="o">=</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">nth_element</span><span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elements</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">elements</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">elements</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elements</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>We can pass any kind of callable object to an algorithm. An object or expression is callable if we can apply the call operator to it. That is, if e is a callable expression, we can write e (args). The only callables we&rsquo;ve used so far are functions and function pointers. There are two other kinds of callables: classes that overload the function-call operator (), which is also named function object,  and lambda expressions.
C++ 11, A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function.
<code>[capture list] (parameter list) -&gt; return type { function body }</code>
Unlike a function, lambdas may be defined inside a function. The capture list is an list of local variables defined in the enclosing function; return type, parameter list, and function body are the same as ordinary function.
We can omit either or both of the parameter list and return type but must include capture list and function body: <code>auto f = [] { return 42; }</code>
If we omit the return type, the lambda has an inferred return type that depends on the code in the function body. Unlike a function, lambda may not have default arguments.  Also, a lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list. When we pass a lambda to a function, we are defining both a new type and an object of that type.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check_size</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">maxSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">is_shorter</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">ls</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">rs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">ls</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span> <span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------------Lambda------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;to&#34;</span><span class="p">,</span> <span class="s">&#34;find&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;good&#34;</span><span class="p">,</span> <span class="s">&#34;job&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words_copy</span> <span class="o">=</span> <span class="n">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// first sort by size using lambda
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ls</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rs</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">ls</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// then find the first value that make the predict true. The local static variable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// need not be put in capture list. Here we cannot use a function in place of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// the lambda because the lambda need the local variable sz.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// To solve this problem, we can use a new library function named bind
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it_wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">sz</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// finally print result using for_each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">it_wc</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------Capture by Reference or Value---------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">size_t</span> <span class="n">v1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//capture by value that is copied when the lambda is created
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v1</span><span class="p">;</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">//capture by reference object that must exist at the time the lambda is executed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">fx</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">v1</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v1</span><span class="p">;</span> <span class="p">};</span> 
</span></span><span class="line"><span class="cl">   <span class="n">v1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//If possible, avoid capturing pointers or references
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">fx</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------Implicit Captures----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span> <span class="o">=</span> <span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// c explicitly captured by value, other variables implicitly captured by reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">words_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words_copy</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// os explicitly captured by reference, other variables implicitly captured by value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// when we mix implicit and explicit captures, the first item in the capture list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// must be an &amp; or =
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">words_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words_copy</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">]</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------Mutable Lambdas-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//If we want to change a variable captured by value , we must add the keyword mutable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">v1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">fm</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="p">()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="k">return</span> <span class="o">++</span><span class="n">v1</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">v1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">fm</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------Lambda Return Type---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="kt">long</span> <span class="n">negativeNumberNums</span> <span class="o">=</span> <span class="n">count_if</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">negativeNumberNums</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// replace negative value with its absolute value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">i</span> <span class="p">:</span> <span class="n">i</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//Here we must define a return type for the lambda, otherwise compiler cannot deduce
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the return typeactually, the gcc compiler can compile if we don&#39;t add a return type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">               <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span> <span class="k">else</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------------bind, ref--------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//bind and placeholders are defined in functional header.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//sort by size, this bind may be unnecessary but it invert the meaning of isShorter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sort</span><span class="p">(</span><span class="n">words_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words_copy</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">is_shorter</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//the bind generates a callable object that binds the second argument of check_size to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the value of sz
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it_wc_2</span><span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words_copy</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">check_size</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">sz</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//Here we can&#39;t use bind directly, because bind copies its arguments and we cannot 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//copy an ostream. If we want to pass an object to bind without copying it, we must
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//use the library ref function. The ref function returns an object that contains 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//the given reference and that is itself copyable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//Like bind, ref and cref functions are defined in the functional header.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">for_each</span><span class="p">(</span><span class="n">it_wc_2</span><span class="p">,</span> <span class="n">words_copy</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span> <span class="n">_1</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>In addition to iterators that are defined for each of the containers, there are some other iterators:
（1）Insert iterators: These iterators are bound to a container and can be used to insert elements.
（2）Stream iterators: bound to input or output streams and can be used to iterate through associated IO stream.
（3）Reverse iterators: These iterators move backward, rather than forward. Only forward_list doesn&rsquo;t have.
（4）Move iterators: These iterators move rather than copy their elements.</li>
</ol>
<p>When we assign a value through an insert iterator, the iterator calls a container operation to add an element. The operations the insert iterators support are: it = t, *it, ++it, it++ There are three kinds of inserters: back_inserter, front_inserter, inserter. We can use front_inserter only if the container has push_front. Similarly, we can use back_inserter only if it has push_back.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">T</span> <span class="n">elements</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span> <span class="n">elements</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------------inserter-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// v1 must have member function push_back, and we cannot use front_inserter here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="o">*</span><span class="n">it1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// insert ahead of v1.begin(), duplicated elements in v2 will not be inserted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">unique_copy</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v2</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">inserter</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">begin</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------istream_iterator, ostream_iterator-----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// An istream_iterator reads an input stream, ostream_iterator writes an output stream
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// we can create an istream_iterator for any type that has an input operator &gt;&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// Similarly, we can define an ostream_iterator for any type that has an output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// operator &lt;&lt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_iter</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">eof</span><span class="p">;</span> <span class="c1">// reads ints from cin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">(</span><span class="n">in_iter</span><span class="p">,</span> <span class="n">eof</span><span class="p">);</span> <span class="c1">// construct vector from an iterator range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">//while (in_iter != eof) v3.push_back(*in_iter++); // equivalently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span> <span class="n">v3</span><span class="p">)</span> <span class="o">*</span><span class="n">out_iter</span><span class="o">++</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// assignment writes element to cout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">e</span><span class="p">:</span> <span class="n">v3</span><span class="p">)</span> <span class="n">out_iter</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// equivalently, but not good style
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">copy</span><span class="p">(</span><span class="n">v3</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v3</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">out_iter</span><span class="p">);</span> <span class="c1">// print elements easily
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------reverse iterators---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// reverse iterator is an iterator that traverses a container backward, from the last
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// element toward the first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// reverse iterator inverts the meaning of increment (++it) and decrement (--it)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// we obtain a reverse iterator by calling rbegin, rend, crbegin, and crend members.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v4</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">r_iter</span><span class="o">=</span> <span class="n">v4</span><span class="p">.</span><span class="n">crbegin</span><span class="p">();</span> <span class="n">r_iter</span> <span class="o">!=</span> <span class="n">v4</span><span class="p">.</span><span class="n">crend</span><span class="p">();</span> <span class="o">++</span><span class="n">r_iter</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">r_iter</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">sort</span><span class="p">(</span><span class="n">v4</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">v4</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span> <span class="c1">// sort in reverse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">print</span><span class="p">(</span><span class="n">v4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//we can define a reverse iterator only from an iterator that support -- as well as ++
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// The forward_list and stream iterators do not support
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// To transform a reverse iterator to an ordinary iterator, we can use base member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">line</span> <span class="o">=</span> <span class="s">&#34;we can fix it, hide it,or just remove it&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">rcomma</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">crbegin</span><span class="p">(),</span> <span class="n">line</span><span class="p">.</span><span class="n">crend</span><span class="p">(),</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">string</span><span class="p">(</span><span class="n">rcomma</span><span class="p">.</span><span class="n">base</span><span class="p">(),</span> <span class="n">line</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>The iterator operations required by the algorithms are grouped into five iterator categories:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Input iterator              Read, but not write; single-pass, increment only
</span></span><span class="line"><span class="cl">Output iterator             Write, but not read; single-pass, increment only
</span></span><span class="line"><span class="cl">Forward iterator            Read and write; multi-pass, increment only
</span></span><span class="line"><span class="cl">Bidirectional iterator      Read and write; multi-pass, increment and decrement
</span></span><span class="line"><span class="cl">Random-access iterator      Read and write; multi-pass, full iterator arithmetic
</span></span></code></pre></td></tr></table>
</div>
</div><p>A second way to classify algorithms is by whether they read, write, or reorder the elements in the sequence.</p>
<p>（1）Input iterators: can read elements in a sequence. An input iterator must provide
A. equality and inequality operators <code>==, !=</code> to compare iterators
B. prefix and postfix increment <code>++</code> to advance the iterator
C. dereference operator <code>*</code> to read an element; deference may appear only on right-hand side of assignment
D. the arrow operator <code>-&gt;</code> as a synonym for <code>(*it).member</code> to dereference the iterator and fetch a member</p>
<p>Input iterators may be used only sequentially, only for single-pass algorithms. The find and accumulate algorithms require input iterators; istream_iterator is input iterator.</p>
<p>（2）Output iterators: write rather than read elements. Output iterators must provide
A. prefix and postfix increment <code>++</code> to advance the iterator
B. deference <code>*</code>, which may appear only as the left-hand side of an assignment</p>
<p>We may assign to a given value of an output iterator only once. Output iterators may be used only for single-pass algorithms. Iterators used as a destination are typically output iterators. The third parameter to copy is an output iterator; the ostream_iterator type is an output iterator.</p>
<p>（3）Forward iterators: can read and write a given sequence. They move in only one direction through the sequence. Forward iterators support all operations of both input iterators and output iterators. Moreover, they can read or write the same element multiple times. Therefore, we can use the saved state of a forward iterator. Hence, algorithms that use forward iterators may make multiple  passes through the sequence. The replace algorithm requires a forward iterator; iterators on forward_list are forward iterators.</p>
<p>（4）Bidirectional iterators: can read and write a sequence forward or backward. In addition to supporting all the operations of a forward iterator, a bidirectional iterator also supports the prefix and postfix decrement <code>--</code> operator. The reverse algorithm requires bidirectional iterators, and aside from forward_list, the library containers supply iterators that meet the requirements for a bidirectional iterator.</p>
<p>（5）Random-access iterators: provide constant-time access to any position in the sequence. These iterators support all functionality of bidirectional iterators. In addition, random-access iterators support
A. the relational operations <code>&lt;, &lt;=, &gt;, &gt;=</code> to compare relative positions of two iterators
B. Addition and subtraction operations <code>+, +=, - , -=</code> on an iterator and an integral value.
C. The subtraction operator <code>-</code> when applied to two iterators, which yields the distance between two iterators
D. The subscript operator <code>iter[n]</code> as a synonym for <code>*(iter + n)</code></p>
<p>The sort algorithms require random-access iterator. Iterators for array, deque, string, and vector are random-access iterators, as are pointers when used to access elements of a built-in array.</p>
<ol start="7">
<li>Algorithm Parameter Patterns. Most of algorithms have one of the following forms:</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">alg(beg, end, other args);
</span></span><span class="line"><span class="cl">alg(beg, end, dest, other args);
</span></span><span class="line"><span class="cl">alg(beg, end, beg2, other args);
</span></span><span class="line"><span class="cl">alg(beg, end, beg2, end2, other args);
</span></span></code></pre></td></tr></table>
</div>
</div><p>The alg is the name of the algorithm, beg and end denote the input range. In addition to these iterator parameters, some algorithms take additional, noniterator parameters.</p>
<p>（1）Algorithms with a single destination iterator.  A dest parameter is an iterator that denotes a destination in which the algorithm can write its output. Algorithms assume that it is safe to write as many elements as needed.  More commonly, dest is bound to an insert iterator or an ostream_iterator.
（2）Algorithms with a second input sequence. The input range denoted by [beg, end), and a second input range denoted by [beg2, end2). These algorithms assume that the range starting at beg2 is at least as large as the one denoted by beg and end.</p>
<ol start="8">
<li>Separate from parameter conventions, the algorithms also conform to a set of naming and overload conventions.
（1）Use Overloading to Pass a Predicate. Algorithms that take a predicate to use in place of the &lt; or == operator, typically are overloaded. One version of the function uses the element type&rsquo;s operator to compare elements; the second takes an extra parameter that is a predicate to use in place of &lt; or ==</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">unique(beg,  end);  // uses the == operator to compare the elements
</span></span><span class="line"><span class="cl">unique(beg, end, comp); // uses comp to compare the elements
</span></span></code></pre></td></tr></table>
</div>
</div><p>（2）Algorithms with _if Versions. Algorithms take an element value typically have a second named version that take a predicate in place of the value. These algorithms provide a named version rather than an overloaded one because both versions of the algorithms take the same number of arguments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">find(beg,  end, val);  // find the first instance of val in the input range
</span></span><span class="line"><span class="cl">find_if(beg, end, pred); // find the first instance for which pred is true
</span></span></code></pre></td></tr></table>
</div>
</div><p>（3）Algorithms with _copy Versions. By default, algorithms that rearrange elements write the rearranged elements back into the given input range. These algorithms provide a second version that writes to a specified output destination.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">reverse(beg,  end);  // reverse the elements in the input range
</span></span><span class="line"><span class="cl">reverse_copy(beg, end, dest);// copy elements in reverse order into dest
</span></span></code></pre></td></tr></table>
</div>
</div><p>Some algorithms provide both _copy and _if versions. They take a destination iterator and a predicate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// removes the odd elements from v1
</span></span><span class="line"><span class="cl">remove_if(v1.begin(), v1.end(), [](int i) { return i % 2; });
</span></span><span class="line"><span class="cl">// copies only the even elements from v1 into v2; v1 is unchanged
</span></span><span class="line"><span class="cl">remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i) { return i % 2; });
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="9">
<li>Unlike other containers, list and forward_list define several algorithms as members. In particular, the list types define their own versions of sort, merge, remove, reverse, and unique. The generic sort algorithm requires random-access iterators, so sort can not be used.
The list-specific algorithms can achieve much better performance than the corresponding generic versions. Most of the list-specific algorithms are similar to generic algorithms. However, an important difference is that the list versions change the underlying container. For example, the remove algorithm do remove the elements.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;forward_list&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// range constructor [first, last)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst1</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst2</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//-------------------------merge-----------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// all elements will be combined into lst1, lst2 will be clear
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">lst1</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lst2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lst2 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">lst2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// generic merge algorithm, the input sequences are unchanged
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">char</span> <span class="n">first</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="kt">char</span> <span class="n">second</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;x&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="p">,</span> <span class="sc">&#39;z&#39;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">merge</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">second</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------remove_if-----------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// list-specific algorithms do remove elements, the erase operation is not needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">lst1</span><span class="p">.</span><span class="n">remove_if</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//--------------------------sort---------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">lst1</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//--------------------------splice-------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst3</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst3</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst3</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// move all elements from lst3 to lst1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">lst1</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">lst3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;lst3 size: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">lst3</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// move one element denoted by last to lst3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="o">--</span><span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">lst3</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lst3</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// move a range of elements into lst3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">lst3</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lst3</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">,</span> <span class="n">lst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst1</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">lst3</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lst3</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------------------splice_after----------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flst1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flst2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// move elements after flst1.begin(), so flst1.end() can not be used here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">flst1</span><span class="p">.</span><span class="n">splice_after</span><span class="p">(</span><span class="n">flst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">flst2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">flst1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">flst1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="associative-containers">Associative Containers</h2>
<ol>
<li>Elements in an associative container are stored and retrieved by a key; elements in a sequential container are stored and accessed sequentially by their position in the container. Associative containers support efficient lookup and retrieval by a key. The two primary associative-container types are map and set.
The elements in a map are key-value pairs: The key serves as an index into the map, the value represents the data associated with that index. A set element contains only a key; a set supports efficient queries as to whether a given key is present.
In the eight associative containers, each container is
(1) a set or a map
(2) requires unique keys or allow multiple keys
(3) stores the elements in order or not.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">map         	associative array; holds key-value pairs
</span></span><span class="line"><span class="cl">set         	container in which the key is the value
</span></span><span class="line"><span class="cl">multimap        map in which a key can appear multiple times
</span></span><span class="line"><span class="cl">multiset        set in which a key can appear multiple times
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">unordered_map       map organized by a hash function
</span></span><span class="line"><span class="cl">unordered_set       set organized by a hash function
</span></span><span class="line"><span class="cl">unordered_multimap  Hashed map; keys can appear mutliple times
</span></span><span class="line"><span class="cl">unordered_multiset  Hashed set; keys can appear multiple times
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>For the ordered containers: map, multimap, set, and multiset—the key type must define a way to compare the elements. By default, the library use &lt; operator to compare the keys. The library type pair is defined in utility header, it holds two data members named first and second.
Note: the value_type of a map is a pair and that we can change the value but not the key member of that pair.
When we use an iterator to traverse a map, multimap, set, or multiset, the iterators yield elements in ascending key order.
C++ 11, the easiest way to create a pair is to use brace initialization inside the argument list.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// keep only words, transform words to lower case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">prepareForSentence</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">sentence</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">sentence</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;&#39;s&#34;</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">s</span> <span class="p">:</span> <span class="n">sentence</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">&lt;</span> <span class="sc">&#39;A&#39;</span> <span class="o">||</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">||</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="sc">&#39;z&#39;</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">           <span class="n">s</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">transform</span><span class="p">(</span><span class="n">sentence</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sentence</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">sentence</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="o">::</span><span class="n">tolower</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Sales_data</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// C++ 11, the default constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">       <span class="n">revenue</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="nf">isbn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">bookNo</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">avg_price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">units_sold</span> <span class="o">?</span> <span class="n">revenue</span><span class="o">/</span><span class="nl">units_sold</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">unsigned</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">compareIsbn</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// explicitly constructed return value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">size</span><span class="p">()};</span> <span class="c1">// list initialize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------------map, set------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// Although set type define both the iterator and const_iterator type, they give us 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// read-only access to the set elements. Just as we cannot change the key part of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// a map element, the keys in a set are const.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="n">sentence</span> <span class="o">=</span> <span class="s">&#34;A </span><span class="se">\&#34;</span><span class="s">map</span><span class="se">\&#34;</span><span class="s"> is a collection of key-value pairs. For example, each&#34;</span>
</span></span><span class="line"><span class="cl">     <span class="s">&#34; pair might contain a person&#39;s name as a key and a phone number as its value.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">prepareForSentence</span><span class="p">(</span><span class="n">sentence</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">istringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">sentence</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">copy</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ss</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">words</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">exclude</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;its&#34;</span><span class="p">,</span> <span class="s">&#34;pairs&#34;</span><span class="p">};</span> <span class="c1">// using a set is better thant a vector here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span> <span class="o">=</span> <span class="p">{{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="s">&#34;of&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">word_count</span><span class="p">,</span> <span class="n">exclude</span><span class="p">]</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="n">exclude</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">exclude</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">++</span><span class="n">word_count</span><span class="p">[</span><span class="n">s</span><span class="p">];</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// pair is a template type that holds two data elements named first and second
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// iterators yield elements in ascending key order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">StrCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">word_count</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">word_count</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[]</span> <span class="p">(</span><span class="n">StrCount</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">w</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">w</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------Adding elements to set: insert, emplace
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">set2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// result indicate whether the element is inserted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">pair</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;insert result:&#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mset2</span><span class="p">(</span><span class="n">set2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">set2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// For multiset and multimap, insert return an iterator to the new element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">mit</span> <span class="o">=</span> <span class="n">mset2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;insert value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">mit</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------Remove elements: erase
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// return size_type indicating the number of elements removed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">rr</span> <span class="o">=</span> <span class="n">mset2</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;erase result:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">rr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// return an iterator to element after begin() or end().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">afterIt</span> <span class="o">=</span> <span class="n">mset2</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">mset2</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">   <span class="n">mset2</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">mset2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">mset2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// remove all elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------Adding elements to map: insert
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;true&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span>
</span></span><span class="line"><span class="cl">   <span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;false&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;lose&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">(</span><span class="s">&#34;win&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------subscript operation for map and unordered_map that is not const
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// If the key is not present, a new element is created and inserted, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// the associated value is value initialized
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mapped value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">word_count</span><span class="p">[</span><span class="s">&#34;Anna&#34;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">mappedResult</span> <span class="o">=</span> <span class="n">word_count</span><span class="p">[</span><span class="s">&#34;Anna&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;mapped value:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">mappedResult</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------multimap, multiset------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">iset</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">miset</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;iset:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">iset</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; miset:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">miset</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// We can&#39;t directly define a multiset of Sales_data because it doesn&#39;t have 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// a &lt; operator. Also, we cannot define a map from list&lt;int&gt;::iterator to int.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// But vector&lt;int&gt;::iterator is ok. However, we can use our own operation by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// defining the multiset with two types: key type, comparison type.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">using</span> <span class="n">compareType</span> <span class="o">=</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">multiset</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="p">,</span> <span class="n">compareType</span><span class="o">&gt;</span> <span class="n">books</span><span class="p">(</span><span class="n">compareIsbn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// When we use decltype to form a function pointer, we must add * to indicate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// that we are using a pointer to the given function type. We initialize
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// bookstore from compareIsbn means that when we add elements to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// bookstore, those bookstore will be ordered by calling compareIsbn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">multiset</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">compareIsbn</span><span class="p">)</span><span class="o">*&gt;</span> <span class="n">bookstore</span><span class="p">(</span><span class="n">compareIsbn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">bookstore</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Sales_data</span><span class="p">(</span><span class="s">&#34;a10&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">bookstore</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Sales_data</span><span class="p">(</span><span class="s">&#34;a52&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">30</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">bookstore</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Sales_data</span><span class="p">(</span><span class="s">&#34;a05&#34;</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">for_each</span><span class="p">(</span><span class="n">bookstore</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">bookstore</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Sales_data</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">avg_price</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//------------find, count, lower_bound, upper_bound, equal_range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">se</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;set find:&#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">se</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, count:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">se</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// Using find Instead of Subscript for the map without change it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">word_count</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;foobar&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="n">word_count</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;foobar is not in the map&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// When a multimap or multiset has multiple elements of a given key, 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// those elements will be adjacent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">multiset</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ms</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ivec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">search_item</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">ms_it</span> <span class="o">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;find elements:&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ms_it</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="o">++</span><span class="n">ms_it</span><span class="p">;</span> <span class="c1">// advance to the next element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="o">--</span><span class="n">entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// If the key is in the container, the iterator returned from lower_bound will refer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// to the first instance of that key and the iterator returned from upper_bound 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// will refer just after the last instance of the key. If the element is not in the 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// multimap, then lower_bound and upper_bound will return equal iterators; both will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// refer to the point at which the key can be inserted without disrupting the order.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// Note: If lower_bound and upper_bound return the same iterator, then the given key 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// is not in the container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">search_item</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">       <span class="n">beg</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">beg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">beg</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">// If the key is present, the first iterator refers to the first instance of the key 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// and the second iterator refers one past the last instance of the key. If no
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// matching element is found, both the first and second
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// iterators refer to the position where this key can be inserted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">ms</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">search_item</span><span class="p">);</span> <span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">pos</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------------------------pair---------------------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">;</span> <span class="c1">// value initialized, empty string and 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">author</span><span class="p">{</span><span class="s">&#34;James&#34;</span><span class="p">,</span> <span class="s">&#34;Joyce&#34;</span><span class="p">};</span> <span class="c1">// initialize with defined value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// C++ 11, we can list initialize a return value to return a pair
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;world&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">unknown</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pair:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">unknown</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">unknown</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------------Associative Container Additional Type Aliases----------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// v1 is a string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">key_type</span> <span class="n">v2</span><span class="p">;</span>   <span class="c1">// v2 is a string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// v3 is a pair&lt;const string, int&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">key_type</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// v4 is a string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">mapped_type</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// v5 is an int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">//---------------------The Word Transformation Problem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">trans_map</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;brb&#34;</span><span class="p">,</span> <span class="s">&#34;be right back&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;k&#34;</span><span class="p">,</span> <span class="s">&#34;okay?&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;y&#34;</span><span class="p">,</span> <span class="s">&#34;why&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;r&#34;</span><span class="p">,</span> <span class="s">&#34;are&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;u&#34;</span><span class="p">,</span> <span class="s">&#34;you&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;pic&#34;</span><span class="p">,</span> <span class="s">&#34;picture&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;thk&#34;</span><span class="p">,</span> <span class="s">&#34;thanks!&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">       <span class="p">{</span><span class="s">&#34;18r&#34;</span><span class="p">,</span> <span class="s">&#34;later&#34;</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">   <span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">&#34;y dont u send me a pic&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">istringstream</span> <span class="n">stream</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="n">firstword</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">stream</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="n">firstword</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="n">firstword</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">else</span>
</span></span><span class="line"><span class="cl">           <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">string</span> <span class="n">transformed</span> <span class="o">=</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">auto</span> <span class="n">map_it</span> <span class="o">=</span> <span class="n">trans_map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="p">(</span><span class="n">map_it</span> <span class="o">!=</span> <span class="n">trans_map</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">           <span class="n">transformed</span> <span class="o">=</span> <span class="n">map_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">transformed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Rather than using a comparison operation to organize their elements, the unordered associative containers use a hash function and the key type&rsquo;s == operator. Although hashing gives better average case performance in principle, achieving good results in practice often requires a fair bit of performance testing and tweaking. As a result, it is usually easier and better performance to use an ordered container.</li>
</ol>
<p>The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. These containers use a hash function to map elements to buckets. The container puts all of its elements with a given hash value into the same bucket. As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">bucket_count</span><span class="p">()</span>        <span class="n">Number</span> <span class="n">of</span> <span class="n">buckets</span> <span class="ow">in</span> <span class="n">use</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">max_bucket_count</span><span class="p">()</span>    <span class="n">Largest</span> <span class="n">number</span> <span class="n">of</span> <span class="n">buckets</span> <span class="n">this</span> <span class="n">container</span> <span class="n">can</span> <span class="n">hold</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">bucket_size</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>        <span class="n">Number</span> <span class="n">of</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">nth</span> <span class="n">bucket</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">bucket</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>             <span class="n">Bucket</span> <span class="ow">in</span> <span class="n">which</span> <span class="n">elements</span> <span class="n">with</span> <span class="n">key</span> <span class="n">k</span> <span class="n">would</span> <span class="n">be</span> <span class="n">found</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">local_iterator</span>          <span class="n">Iterator</span> <span class="n">type</span> <span class="n">that</span> <span class="n">can</span> <span class="n">access</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">bucket</span>
</span></span><span class="line"><span class="cl"><span class="n">const_local_iterator</span>    <span class="k">const</span> <span class="n">version</span> <span class="n">of</span> <span class="n">the</span> <span class="n">bucket</span> <span class="n">iterator</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">end</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>    <span class="n">Iterator</span> <span class="n">to</span> <span class="n">the</span> <span class="n">first</span><span class="p">,</span> <span class="n">one</span> <span class="n">past</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">bucket</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">cbegin</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">cend</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="n">Return</span> <span class="n">const_local_iterator</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">load_factor</span><span class="p">()</span>         <span class="n">average</span> <span class="n">number</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">per</span> <span class="n">bucket</span><span class="o">.</span> <span class="n">Returns</span> <span class="ne">float</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">max_load_factor</span><span class="p">()</span>     <span class="n">average</span> <span class="n">bucket</span> <span class="n">size</span> <span class="n">that</span> <span class="n">c</span> <span class="n">tries</span> <span class="n">to</span> <span class="n">maintain</span><span class="o">.</span> <span class="n">c</span> <span class="n">add</span> <span class="n">buckets</span>
</span></span><span class="line"><span class="cl">                       <span class="n">to</span> <span class="n">keep</span> <span class="n">load_factor</span> <span class="o">&lt;=</span> <span class="n">max_load_factor</span><span class="o">.</span> <span class="n">Returns</span> <span class="ne">float</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">rehash</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>             <span class="n">Reorganize</span> <span class="n">storage</span> <span class="n">so</span> <span class="n">that</span> <span class="n">bucket_count</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">and</span>
</span></span><span class="line"><span class="cl">                       <span class="n">bucket_count</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">/</span><span class="n">max_load_factor</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span><span class="o">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>            <span class="n">Reorganize</span> <span class="n">so</span> <span class="n">that</span> <span class="n">c</span> <span class="n">can</span> <span class="n">hold</span> <span class="n">n</span> <span class="n">elements</span> <span class="n">without</span> <span class="n">a</span> <span class="n">rehash</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By default, unordered containers use == operator on the key type to compare elements. They also use an object of type hash&lt;key_type&gt; to generate the hash code for each element. The library supplies versions of the hash template for the built-in types, including pointers. It also define hash for some library types, including string and smart pointer. If we want to define an unordered container that uses a our own class type for its key type, we must supply our own version of the hash template. Instead of using the default hash, we can use a strategy similar to the one we used to override the default comparison operation on keys for the ordered containers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Sales_data</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span> <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">       <span class="n">revenue</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="nf">isbn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">bookNo</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="nf">avg_price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">units_sold</span> <span class="o">?</span> <span class="n">revenue</span><span class="o">/</span><span class="nl">units_sold</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">unsigned</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">double</span> <span class="n">revenue</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// To use Sales_data as the key of unordered container, we need to supply functions to
</span></span></span><span class="line"><span class="cl"><span class="c1">// replace both the == operator and to calculate a hash code.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">size_t</span> <span class="nf">hasher</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">sd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">sd</span><span class="p">.</span><span class="n">isbn</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">eqOp</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">SD_multiset</span><span class="o">=</span> <span class="n">unordered_multiset</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">hasher</span><span class="p">)</span><span class="o">*</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">eqOp</span><span class="p">)</span><span class="o">*&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// bucket size and pointers to hash function and equality operator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">SD_multiset</span> <span class="n">bookstore</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">hasher</span><span class="p">,</span> <span class="n">eqOp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The advantages of an unordered container:
（1）userful when when we have a key type which there is no obvious ordering relationship among the elements
（2）userful for applications in which the cost of maintaining the elements in order is prohibitive
The advantages of the ordered version:
（1）iterators for ordered containers access elements in order by key
（2）we can directly define an ordered container that uses a our own class types for its key type</p>
<h2 id="dynamic-memory">Dynamic Memory</h2>
<ol>
<li>In addition to supporting automatic and static objects, C++ lets us allocate objects dynamically. Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed. To make using dyanmic objects safer, the library define two smart pointer types that manage dynamically allocated objects. Smart pointers ensure that objects to which they point are automatically freed when it is appropriate to do so.</li>
</ol>
<p>Our programs have used only static or stack memory. Static memory is used for local static objects, for class static data members, and for variables defined outside any function. Stack memory is used for nonstatic objects defined inside functions. Objects allocated in static or stack memory are automatically created and destroyed by the compiler. Stack objects exist only while the block in which they are defined is executing; static objects are allocated before they are used, and they are destroyed when the program ends. In addition to static or stack memory, every program also has a pool of memory that it can use. This memory is referred to as the free store or heap. Programs use heap for objects they dynamically allocate—that is, for objects that the program allocates at run time. Program must explicitly destroy such objects when they are no longer needed.</p>
<ol start="2">
<li>
<p>In C++, dynamic memory is managed through a pair of operators: new, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and delete, which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.
Dynamic memory is problematic because it is surprisingly hard to ensure that we free memory at the right time. Either we forget to free the memory, in which case we have a memory leak, or we free the memory when there are still pointers referring to that memory, in which case we have a pointer refers to memory that is invalid.
C++ 11, the new library provides two smart pointer types that manage dynamic objects. A smart pointer acts like a regular pointer with the important exception that it automatically deletes the objects to which it points. Two kinds of smart pointers: shared_ptr, which allows multiple pointers to refer to the same object, and unique_ptr, which &ldquo;owns&rdquo; the object to which it points. The library also defines a companion class named weak_ptr that is a weak reference to an object managed by a shared_ptr.  All three are defined in the memory header.</p>
</li>
<li>
<p>We can think of a shared_ptr as if it has an associated counter, usually referred to as a reference count. The counter is incremented when we use the shared_ptr to initialize another shared_ptr, when we use it as the right-hand operand of an assignment, or when we pass it to or return it from a function by value. The counter is decremented when we assign a new value to the shared_ptr and when the shared_ptr itself is destroyed, such as when a local shared_ptr goes out of scope. Once a shared_ptr counter goes to zero, the shared_ptr automatically frees the object that it manages.
Note: If you put shared_ptr in a container, and you subsequently need to use some, but not all, of the elements, remeber to erase the elements you no longer need.
Attention: If there is a circular reference, the shared_ptr object can not be recycled. Also, shared_ptr is not appropriate for parallel programming, this can be solved by locking, but the performance is still a problem. (this paragraph is not in the book)</p>
</li>
</ol>
<p>Programs tend to use dynamic memory for one of three purposes:
（1）They don&rsquo;t know how many objects they&rsquo;ll need
（2）They don&rsquo;t know the precise type of the objects they need
（3）They want to share data between several objects
One common reason to use dynamic memory is to allow multiple objects to share the same state.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrBlob</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">SIZE_TYPE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// allocate an empty vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">StrBlob</span><span class="p">()</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">())</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">   <span class="c1">// use initializer_list as parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">StrBlob</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">il</span><span class="p">))</span> <span class="p">{}</span> 
</span></span><span class="line"><span class="cl">   <span class="n">SIZE_TYPE</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">()</span> <span class="p">{</span> <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;pop_back on empty StrBlob&#34;</span><span class="p">);</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="p">{</span> <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;front on empty StrBlob&#34;</span><span class="p">);</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="p">{</span> <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;back on empty StrBlob&#34;</span><span class="p">);</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">SIZE_TYPE</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// throws msg if data[i] is invalid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">StrBlob</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">SIZE_TYPE</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">//-----------------------------shared_ptr----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// can point at a string, default holds a null pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="s">&#34;hi&#34;</span><span class="p">;</span> <span class="c1">// dereference to assign a new value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="c1">//----------------------------make_shared-----------------------------
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// allocate and initialize an object in dynamic memory and return a shared_ptr 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// that point to that object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// use auto to define an object to hold the result of make_shared
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">q</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// p and q point to the same object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// increase count for object to which q point; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// reduce count of object to which r had pointed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">StrBlob</span> <span class="n">b1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">StrBlob</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;an&#34;</span><span class="p">,</span> <span class="s">&#34;the&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">       <span class="n">b1</span> <span class="o">=</span> <span class="n">b2</span><span class="p">;</span> <span class="c1">// b1 and b2 share the same data, no deep copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">b2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;about&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;b1 size:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">b1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>By default, dynamically allocated objects are default initialized, which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor.
C++ 11, we can initialize a dynamically allocated object using direct initialization. We can use traditional construction, and under the new standard, we can also use list initialization.
For class type (such as string) that define their own constructor, requesting value initialization is of no consequence; regardless of form, the object is initialized by the default constructor.
In the case of built-in type the difference is significant; a value-initialized object of built-in type has a well-defined value but a default-initialized object does not.
C++ 11, when we use auto to deduce the type of object we want to allocate, we must use parentheses, not curly braces.</li>
</ol>
<p>Once a program has used all of its available memory, new expressions will fail. If new is unable to allocate requested storage, it throws an exception of type bad_alloc. We can prevent new from throwing an exception by using a different form of new which is referred to as placement new. A placement new expression lets us pass additional arguments to new.</p>
<p>We return memory to the system through a delete expression. A delete expression takes a pointer to the object we want to free. A delete expression peforms two actions: It destroys the object to which its given pointer points, and it frees the corresponding memory.
The pointer we pass to delete must either point to dynamically allocated memory or be a null pointer. Deleting a pointer to memory that was not allocated by new, or deleting the same pointer value more than once, is undefined.</p>
<p>Memory that is managed through a shared_ptr is automatically deleted when last shared_ptr is destroyed. A dynamic object managed through a built-in pointer exists until it is explicitly deleted. Functions that return pointers to dynamic memory put a burden on their callers, the caller must remember to delete the memory.
There are three common problems with using new and delete to manage dynamic memory:
（1）Forgetting to delete memory, known as &ldquo;memory leak&rdquo; because the memory is never returned to the free store.
（2）Using an object after is has been deleted. This error can sometimes be detected by making the pointer null after the delete.
（3）Deleting the same memory twice. Then the free store may be corrupted.
You can avoid all of these error-prone problems by using smart pointers exclusively.</p>
<p>When we delete a pointer, that pointer becomes invalid. Although it is invalid, the pointer continues to hold the address of the dynamic memory. After delete, the pointer becomes what is referred to as a dangling pointer. A dangling pointer is one that refers to memory that once held an object but no longer does so. We can avoid this problem by deleting the memory associated with a pointer just before the pointer itself goes out of scope. If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="nf">factory</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// caller is responsible for deleting this memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// pi points to a dynamically allocated, unnamed, uninitialized int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="o">*</span><span class="n">pi2</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span> <span class="c1">// value initialized to 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span> <span class="c1">// default initialized to empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="o">*</span><span class="n">ps2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">();</span> <span class="c1">// value initialized to empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">pix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// traditional construction with parentheses
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">string</span> <span class="o">*</span><span class="n">psx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span> <span class="c1">// list initialize with curly braces
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">ap</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// must use parentheses when using auto, ap is int*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// use new to allocate const object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// if allocation fail, throw std::bad_alloc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// if allocation fail, return a null pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">delete</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">// the deleting object must point to dynamically allocated object or be null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">delete</span> <span class="n">p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">p2</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// do this can prevent the dangling pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">delete</span> <span class="n">pci</span><span class="p">;</span> <span class="c1">// delete the const object, but we cannot make it nullptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="kt">int</span> <span class="o">*</span><span class="n">pf</span> <span class="o">=</span> <span class="n">factory</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="c1">//remember to free memory that we no longer need. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="c1">//Or the pointer will be a dangling pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="k">delete</span> <span class="n">pf</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">       <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// reset p has no effect on q which may be a dangling pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>Don&rsquo;t mix ordinary pointers and smart pointers. It is dangerous to use a built-in pointer to access an object owned by a smart pointer, because we may not know when that object is destroyed.
The function get() return a built-in pointer to the object that the smart pointer is managing. The code that use the return from get must not delete that pointer. And, never use get to initialize or assign to another smart pointer.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// ptr is created and initialized when process is called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// use ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// ptr goes out of scope and is destroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// use direct initialization, can not use implicitly convert: p1 = new int(1024);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">process</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">// ok, after process, reference count of p2 is 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// dangerous, x is a plain pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// legal, but the memory will be deleted by this temporary shared_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="c1">// undefined: x is a dangling pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// ok, but don&#39;t use p in any way that might delete its pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="c1">// undefined: two independent shared_ptr point to the same memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">           <span class="c1">// block ends, p is destroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// undefined: the memory was freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p2</span><span class="p">.</span><span class="n">unique</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">24</span><span class="p">));</span> <span class="c1">// if not alone, allocate a new copy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="o">*</span><span class="n">p2</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// now that we know we&#39;re the only pointer, okay to change this object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="6">
<li>The program that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed. One easy way to make sure resources are freed is to use smart pointers. In contrast, memory that we manage directly is not automatically freed when an exception occurs.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void f()
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">   int *ip = new int(42);
</span></span><span class="line"><span class="cl">   // code that throws an exception that is not caught inside this function
</span></span><span class="line"><span class="cl">   delete ip; // if exception occurs, this memory can never be freed
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="7">
<li>By default, shared_ptr assume that they point to dynamic memory. Hence, by default, when a shared_ptr is destroyed, it executes delete on the pointer. When we create a shared_ptr, we can pass an optional argument that points to a deleter function. Then the deleter function in place of delete will be called when the shared_ptr is destroyed.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Connection</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">Connection</span><span class="p">(</span><span class="n">string</span> <span class="n">_ip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_port</span><span class="p">)</span> <span class="o">:</span> <span class="n">ip</span><span class="p">(</span><span class="n">_ip</span><span class="p">),</span> <span class="n">port</span><span class="p">(</span><span class="n">_port</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;connect!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl">   <span class="kt">void</span> <span class="nf">Disconnect</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;disConnect!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">EndConnection</span><span class="p">(</span><span class="n">Connection</span><span class="o">*</span> <span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">conn</span><span class="o">-&gt;</span><span class="n">Disconnect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;endConnection&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">pConn</span><span class="p">(</span><span class="k">new</span> <span class="n">Connection</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">,</span> <span class="mi">80</span><span class="p">),</span> <span class="n">EndConnection</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">pConn</span><span class="o">-&gt;</span><span class="n">Connect</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// if forget to call Disconnect, it still can be called 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// by the deleter function when shared_ptr is destroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">f</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="8">
<li>
<p>To use smart pointer correctly, we must adhere to a set of conventions:
（1）don&rsquo;t use the same built-in pointer value to initialize (or reset) more than one smart pointer
（2）don&rsquo;t delete the pointer returned from get()
（3）don&rsquo;t use get() to initialize or reset another smart pointer
（4）if you use a pointer returned by get(), remember that the pointer will become invalid when the last corresponding smart pointer goes away.
（5）if you use a smart pointer to manage a resource other than memory allocated by new, remember to pass a deleter.</p>
</li>
<li>
<p>C++11, a unique_ptr &ldquo;owns&rdquo; the object to which it points. Unlike shared_ptr, only one unique_ptr at a time can point to a given object. The object to which a unique_ptr points is destroyed when the unique_ptr is destroyed. When we define a unique_ptr, we bind it to a pointer returned by new. As with shared_ptr, we must use the direct form of initialization. Because a unique_ptr owns the object to which it points, unique_ptr does not support ordinary copy or assignment. But we can transfer ownership from one (nonConst) unique_ptr to another by calling release or reset.</p>
</li>
</ol>
<p>There is one exception to the rule that we cannot copy a unique_ptr: We can copy or assign a unique_ptr that is about to be destroyed. In such cases, the compiler does a special kind of &ldquo;copy&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// return a copy of unique_ptr from a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Stegosaurus&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// release makes p1 null, transfer ownership from p1 to p2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">   <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Trex&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">   <span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// reset delete the memory to which p2 had pointed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p2</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">// ok, but we must remember to delete(p)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>auto_ptr: earlier library included a class named auto_ptr that had some properties of unique_ptr. In particular, it was not possible to store an auto_ptr in a container, nor could we return one from a function. Although auto_ptr is still part of the standard library, programs should use unique_ptr instead.</p>
<p>The way unique_ptr manages its deleter is different from the way shared_ptr does.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">void f(){
</span></span><span class="line"><span class="cl">   // unique_ptr&lt;objT, delT&gt; p(new objT, fcn);
</span></span><span class="line"><span class="cl">   // p points to an object of type objT and
</span></span><span class="line"><span class="cl">   // uses an object of type delT to free that object
</span></span><span class="line"><span class="cl">   unique_ptr&lt;Connection, decltype(EndConnection)*&gt; pConn(
</span></span><span class="line"><span class="cl">       new Connection(&#34;127.0.0.1&#34;, 80), EndConnection);
</span></span><span class="line"><span class="cl">   pConn-&gt;Connect();
</span></span><span class="line"><span class="cl">   // if forget to call Disconnect, it still can be called by
</span></span><span class="line"><span class="cl">   // the deleter function when pConn is destroyed
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="10">
<li>A weak_ptr is a smart pointer that does not control the lifetime of the object to which it points. Instead, a weak_ptr points to an object that is managed by a shared_ptr. Binding a weak_ptr to a shared_ptr does not change the reference count of that shared_ptr. Once the last shared_ptr pointing to the object goes away, the object itself will be deleted. The object will be deleted even if there are weak_ptr pointing to it.
Because the object might no longer exist, we cannot use a weak_ptr to access its object directly. To access the object, we must call lock. The lock function checks whether the object to which the weak_ptr points still exists. If so, lock return a shared_ptr to the shared object.
For example, the StrBlobPtr class will store a weak_ptr to the data member. By using a weak_ptr, we don&rsquo;t affect the lifetime of that vector. However, we can prevent the user from attempting to access a vector that no longer exists.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">StrBlobPtr</span><span class="p">()</span><span class="o">:</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="n">StrBlobPtr</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">wptr</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span><span class="o">&amp;</span> <span class="n">deref</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">incr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">size_t</span> <span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">check</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">wptr</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// is the vector still around ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">throw</span> <span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;unbound StrBlobPtr&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// otherwise, return a shared_ptr to the vector
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">deref</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="n">incr</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;increment past end of StrBlobPtr&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="o">++</span><span class="n">curr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// wp weakly shares with p; use count in p is unchanged
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">()){</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// inside if, np shares its object with p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="11">
<li>The new and delete operators allocate objects one at a time. Some applications need allocate storage for many objects at once. The language defines a second kind of new expression that allocates and initializes an array of objects. The library includes a template class named allocator that lets us separate allocation from initialization. Classes that use the containers can use the default versions of operations for copy, assignment, and destruction. Classes that allocate dynamic arrays must define their own versions of these operations to manage the associated memory. So do not allocate dynamic arrays until you have read the &ldquo;Copy Control&rdquo; chapter.</li>
</ol>
<p>Alghough it is common to refer to memory allocated by new T[] as a &ldquo;dynamic array&rdquo;, but we do not get an object with an array type. Instead, we get a pointer to the element type of the array. Becausethe allocated memory does not have an array type, we cannot call begin or end on a dynamic array. Also, we cannot use a range for to process the elements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int size = 3;
</span></span><span class="line"><span class="cl">int *pia = new int[size]; // pia points to the first of these ints
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">typedef int arrT[10]; // arrT names the type array of ints
</span></span><span class="line"><span class="cl">int *p = new arrT;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note: It is important to remember that what we call a dynamic array does not have an array type.</p>
<p>By default, objects allocated by new are default initialized. We can value initialize the elements in an array by following the size with an empty pair of parentheses. Under the new standard, we can provide a braced list of element initializers. When we list initialize an object of built-in type, if there are fewer initializers than elements, the remaining elements are value initialized. If there are more initializers than the given size, then the new expression throw an exception of type bad_array_length. Like bad_alloc, this type is defined in the new header.
We cannot supply an element initializer inside the parentheses, this means that we cannot use auto to allocate an array. It is legal to dynamically allocate an empty array. The new will return a valid, nonzero pointer for zero-element array. We can use this pointer in ways that we use an off-the-end iterator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int *pia = new int[10]; // uninitialized int
</span></span><span class="line"><span class="cl">int *pia2= new int[10](); // value initialized to 0
</span></span><span class="line"><span class="cl">int *pia3= new int[10] {0,1,2,3,4,5,6,7,8}; //remaining elements are value initialized to 0
</span></span><span class="line"><span class="cl">int *pia4= new int[0]; // ordinary array can not use 0 for size
</span></span></code></pre></td></tr></table>
</div>
</div><p>To free a dynamic array, we use a special form of delete that includes an empty pair of square brackets []. Elements in an array are destroyed in reverse order. That is, the last element is destroyed first. The brackes when we delete a pointer to an array is essential, it is undefined if we omit the brackets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">typedef int arrT[42];
</span></span><span class="line"><span class="cl">int *p = new arrT;
</span></span><span class="line"><span class="cl">// bracket is necessary, p must point to a dynamically allocated array or be null
</span></span><span class="line"><span class="cl">delete []p; 
</span></span></code></pre></td></tr></table>
</div>
</div><p>The library provides a version of unique_ptr that can manage arrays allocated by new. When a unique_ptr points to an array, we cannot use the dot and arrow member access operator, but we can use the subscript operator to access the elements. Unlike unique_ptr, shared_ptr provide no direct support for managing a dynamic array. If we want to use a shared_ptr to manage a dynamic array, we must provide our own deleter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// for array, we cannot use the dot and the arrow member access operator
</span></span><span class="line"><span class="cl">unique_ptr&lt;int[]&gt; up(new int[10]); 
</span></span><span class="line"><span class="cl">   for (int i = 0; i != 10; ++i)
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">       //When a unique_ptr points to an array, we can use subscript operator to
</span></span><span class="line"><span class="cl">       //access elements
</span></span><span class="line"><span class="cl">       up[i] = i; 
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   up.release(); // automatically use delete[] to destroy it
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   // we must supply a deleter to use a shared_ptr
</span></span><span class="line"><span class="cl">   shared_ptr&lt;int&gt; sp(new int[10], [](int *p) { delete []p; }); 
</span></span><span class="line"><span class="cl">   // shared_ptr don&#39;t have subscript operator and don&#39;t support pointer arithmetic
</span></span><span class="line"><span class="cl">   for (int i = 0; i != 10; ++i)
</span></span><span class="line"><span class="cl">   {
</span></span><span class="line"><span class="cl">       *(sp.get() + i) = i; // use get to get a built-in pointer
</span></span><span class="line"><span class="cl">   }
</span></span><span class="line"><span class="cl">   sp.reset(); // use delete[] to free the array
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="12">
<li>The library allocator class lets us separate allocation from construction. It provides type-aware allocation of raw, unconstructed, memory. When an allocator object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type.
The memory an allocator allocates is unconstructed. We use this memory by constructing objects in that memory. It is an error to use raw memory in which an object has not been constructed.
When we finished using the objects, we must destroy the elements we constructed, which we do by calling destroy on each constructed elememt. We may destroy only elements that are acutally constructed. Once destroyed, we can either reuse the memory or return it to the system by calling deallocate. The library also defines two algorithms that can construct objects in uninitialized memory.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="c1">// allocate unconstructed memory for these strings
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// q will point to one past the last constructed element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">);</span> <span class="c1">// *q is the empty string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">q</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">alloc</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="o">--</span><span class="n">q</span><span class="p">);</span> <span class="c1">// destroy elements that are actually constructed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">   <span class="c1">// Once elements have been destroyed, we can either reuse the memory or return 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// it to system. p cannot be null, it must point to memory allocated by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// allocate; the size must be the same.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">   <span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">allocI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// allocate twice as many elements as vi holds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizeI</span> <span class="o">=</span> <span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">auto</span> <span class="n">pI</span> <span class="o">=</span> <span class="n">allocI</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">sizeI</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// construct elements starting at pI, the destination iterator must denote 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// unconstructed memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// unlike copy, uninitialized_copy constructs elements in its destination
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// like copy, uninitialized_copy return its destination iterator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">qI</span> <span class="o">=</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pI</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// initialize remaining elements to 7
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">uninitialized_fill_n</span><span class="p">(</span><span class="n">qI</span><span class="p">,</span> <span class="n">vi</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">allocI</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">pI</span><span class="p">,</span> <span class="n">sizeI</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="13">
<li>To conclude, we&rsquo;ll implement a simple text-query program. This program let us search a given file for words that might occur in it. The result will be the number of times the word occurs and a list of lines on which taht word appears.
Alghough we could write our program using vector, set, and map directly, it will be more useful if we define a more abstract solution. We&rsquo;ll start by designing a class to hold the input file in a way that makes querying the file easy. This class, which we&rsquo;ll name TextQuery, will hold a vector and a map. The vector will hold the text of input file; the map will associate each word to the set of line numbers on which that word appears. We define a second class, named QueryResult, to hold the result of a query. Because the data that a QueryResult needs are stored in a TextQuery object, we have to decide how to access them. We could avoid making copies by returning iterators into the TextQuery object. However, what happens if the TextQuery object is destroyed. The best way is using shared_ptr to reflect the sharing in our data structures.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">QueryResult</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">QueryResult</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">line_no</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">QueryResult</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="p">)</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">       <span class="n">sought</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">lines</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">sought</span><span class="p">;</span> <span class="c1">// word this query represents
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">lines</span><span class="p">;</span> <span class="c1">// lines it&#39;s on
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span> <span class="c1">// input file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TextQuery</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">using</span> <span class="n">line_no</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">TextQuery</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">QueryResult</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">sought</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">   <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">;</span> <span class="c1">// input file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="c1">// map of each word to the set of the lines in which that word appears
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;&gt;</span> <span class="n">wm</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">TextQuery</span><span class="o">::</span><span class="n">TextQuery</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">)</span><span class="o">:</span> <span class="n">file</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">text</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">is</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="n">file</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// the current line number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="n">istringstream</span> <span class="nf">line</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each word in that line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="k">auto</span> <span class="o">&amp;</span><span class="n">lines</span> <span class="o">=</span> <span class="n">wm</span><span class="p">[</span><span class="n">word</span><span class="p">];</span> <span class="c1">// lines is a reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="c1">// that pointer is null the first time we see word
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lines</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">               <span class="n">lines</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">           <span class="n">lines</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">QueryResult</span> <span class="n">TextQuery</span><span class="o">::</span><span class="n">query</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">sought</span><span class="p">)</span> <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// we&#39;ll return a pointer to this set if we don&#39;t find sought
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">static</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">nodata</span><span class="p">(</span><span class="k">new</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// use find and not a subscript to avoid adding words to wm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">auto</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">wm</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">sought</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="n">wm</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">QueryResult</span><span class="p">(</span><span class="n">sought</span><span class="p">,</span> <span class="n">nodata</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="nf">QueryResult</span><span class="p">(</span><span class="n">sought</span><span class="p">,</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">make_plural</span><span class="p">(</span><span class="n">size_t</span> <span class="n">ctr</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">word</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">ending</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="p">(</span><span class="n">ctr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">word</span> <span class="o">+</span> <span class="nl">ending</span> <span class="p">:</span> <span class="n">word</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">qr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">qr</span><span class="p">.</span><span class="n">sought</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; occurs &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> 
</span></span><span class="line"><span class="cl">       <span class="n">make_plural</span><span class="p">(</span><span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="s">&#34;time&#34;</span><span class="p">,</span> <span class="s">&#34;s&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">num</span><span class="p">:</span> <span class="o">*</span><span class="n">qr</span><span class="p">.</span><span class="n">lines</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s">(line &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;) &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">qr</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">string</span> <span class="n">paragraph</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;nice to meet you</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;welcome to my office</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;it is very big</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;what do you think about it</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">   <span class="s">&#34;do you like it&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">istringstream</span> <span class="n">file</span><span class="p">(</span><span class="n">paragraph</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">ifstream</span> <span class="n">file2</span><span class="p">(</span><span class="s">&#34;d:/a.txt&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="n">TextQuery</span> <span class="n">q</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">QueryResult</span> <span class="n">qr</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="s">&#34;you&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">qr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">huijian142857</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2015-09-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cpp/">cpp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/cpp_primer_part_3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">C&#43;&#43; Primer 第五版 学习笔记 Part III</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/android_3rd_login/">
            <span class="next-text nav-default">为Android游戏接入第三方登录功能</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://gitee.com/huijian142857" class="iconfont icon-github" title="github"></a>
  <a href="https://huijian142857.gitee.io/post/cpp_primer_part_1_2/" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>huijian142857</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
